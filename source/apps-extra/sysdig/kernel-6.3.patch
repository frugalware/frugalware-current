From d452b80de822702a8806f8e594361bb1bc0c9723 Mon Sep 17 00:00:00 2001
From: Federico Di Pierro <nierro92@gmail.com>
Date: Tue, 2 May 2023 13:08:33 +0200
Subject: [PATCH] fix(driver): fixed 6.3 kernel build and verifier issues.

Signed-off-by: Federico Di Pierro <nierro92@gmail.com>
---
 driver/bpf/fillers.h | 24 ++++++++++++++++++++++++
 driver/ppm_fillers.c | 24 ++++++++++++++++++++++--
 2 files changed, 46 insertions(+), 2 deletions(-)

diff --git a/driver/bpf/fillers.h b/driver/bpf/fillers.h
index 8908b24984..c9c4a3387a 100644
--- a/driver/bpf/fillers.h
+++ b/driver/bpf/fillers.h
@@ -2855,17 +2855,29 @@ FILLER(execve_family_flags, true)
 
 	/* Parameter 21: cap_inheritable (type: PT_UINT64) */
 	kernel_cap_t cap = _READ(cred->cap_inheritable);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	res = bpf_val_to_ring(data, capabilities_to_scap(((unsigned long)cap.cap[1] << 32) | cap.cap[0]));
+#else
+	res = bpf_val_to_ring(data, capabilities_to_scap((unsigned long)cap.val));
+#endif
 	CHECK_RES(res);
 
 	/* Parameter 22: cap_permitted (type: PT_UINT64) */
 	cap = _READ(cred->cap_permitted);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	res = bpf_val_to_ring(data, capabilities_to_scap(((unsigned long)cap.cap[1] << 32) | cap.cap[0]));
+#else
+	res = bpf_val_to_ring(data, capabilities_to_scap((unsigned long)cap.val));
+#endif
 	CHECK_RES(res);
 
 	/* Parameter 23: cap_effective (type: PT_UINT64) */
 	cap = _READ(cred->cap_effective);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	res = bpf_val_to_ring(data, capabilities_to_scap(((unsigned long)cap.cap[1] << 32) | cap.cap[0]));
+#else
+	res = bpf_val_to_ring(data, capabilities_to_scap((unsigned long)cap.val));
+#endif
 	CHECK_RES(res);
 
 	/* Parameter 24: exe_file ino (type: PT_UINT64) */
@@ -6022,19 +6034,31 @@ FILLER(sys_capset_x, true)
 	struct cred *cred = (struct cred*) _READ(task->cred);
 
 	cap = _READ(cred->cap_inheritable);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	val = ((unsigned long)cap.cap[1] << 32) | cap.cap[0];
+#else
+	val = (unsigned long)cap.val;
+#endif
 	res = bpf_val_to_ring(data, capabilities_to_scap(val));
 	if(unlikely(res != PPM_SUCCESS))
 		return res;
 
 	cap = _READ(cred->cap_permitted);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	val = ((unsigned long)cap.cap[1] << 32) | cap.cap[0];
+#else
+	val = (unsigned long)cap.val;
+#endif
 	res = bpf_val_to_ring(data, capabilities_to_scap(val));
 	if(unlikely(res != PPM_SUCCESS))
 		return res;
 
 	cap = _READ(cred->cap_effective);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	val = ((unsigned long)cap.cap[1] << 32) | cap.cap[0];
+#else
+	val = (unsigned long)cap.val;
+#endif
 	res = bpf_val_to_ring(data, capabilities_to_scap(val));
 	if(unlikely(res != PPM_SUCCESS))
 		return res;
diff --git a/driver/ppm_fillers.c b/driver/ppm_fillers.c
index 8130699bf2..af9e99906b 100644
--- a/driver/ppm_fillers.c
+++ b/driver/ppm_fillers.c
@@ -1331,7 +1331,10 @@ int f_proc_startupdate(struct event_filler_arguments *args)
 			{
 
 				/* Support exe_writable */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+				exe_writable |= (file_permission(exe_file, MAY_WRITE) == 0);
+				exe_writable |= inode_owner_or_capable(file_mnt_idmap(exe_file), file_inode(exe_file));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 				exe_writable |= (inode_permission(current_user_ns(), file_inode(exe_file), MAY_WRITE) == 0);
 				exe_writable |= inode_owner_or_capable(current_user_ns(), file_inode(exe_file));
 #else
@@ -1427,9 +1430,15 @@ int f_proc_startupdate(struct event_filler_arguments *args)
 		 * capabilities
 		 */
 		cred = get_current_cred();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 		cap_inheritable = ((uint64_t)cred->cap_inheritable.cap[1] << 32) | cred->cap_inheritable.cap[0];
 		cap_permitted = ((uint64_t)cred->cap_permitted.cap[1] << 32) | cred->cap_permitted.cap[0];
 		cap_effective = ((uint64_t)cred->cap_effective.cap[1] << 32) | cred->cap_effective.cap[0];
+#else
+		cap_inheritable = (uint64_t)cred->cap_inheritable.val;
+		cap_permitted = (uint64_t)cred->cap_permitted.val;
+		cap_effective = (uint64_t)cred->cap_effective.val;
+#endif
 		put_cred(cred);
 
 		/* Parameter 21: cap_inheritable (type: PT_UINT64) */
@@ -6618,18 +6627,29 @@ int f_sys_capset_x(struct event_filler_arguments *args)
 		return res;
 
 	cred = get_current_cred();
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	val = ((uint64_t)cred->cap_inheritable.cap[1] << 32) | cred->cap_inheritable.cap[0];
+#else
+	val = (uint64_t)cred->cap_inheritable.val;
+#endif
 	res = val_to_ring(args, capabilities_to_scap(val), 0, false, 0);
 	if(unlikely(res != PPM_SUCCESS))
 		goto out;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	val = ((uint64_t)cred->cap_permitted.cap[1] << 32) | cred->cap_permitted.cap[0];
+#else
+	val = (uint64_t)cred->cap_permitted.val;
+#endif
 	res = val_to_ring(args, capabilities_to_scap(val), 0, false, 0);
 	if(unlikely(res != PPM_SUCCESS))
 		goto out;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
 	val = ((uint64_t)cred->cap_effective.cap[1] << 32) | cred->cap_effective.cap[0];
+#else
+	val = (uint64_t)cred->cap_effective.val;
+#endif
 	res = val_to_ring(args, capabilities_to_scap(val), 0, false, 0);
 	if(unlikely(res != PPM_SUCCESS))
 		goto out;
