diff -Naur libs-0.13.4/driver/API_VERSION~ libs-0.13.4.new/driver/API_VERSION~
--- libs-0.13.4/driver/API_VERSION~	1970-01-01 01:00:00.000000000 +0100
+++ libs-0.13.4.new/driver/API_VERSION~	2023-10-26 18:38:45.000000000 +0200
@@ -0,0 +1 @@
+5.0.0
diff -Naur libs-0.13.4/driver/bpf/fillers.h libs-0.13.4.new/driver/bpf/fillers.h
--- libs-0.13.4/driver/bpf/fillers.h	2023-10-26 18:38:45.000000000 +0200
+++ libs-0.13.4.new/driver/bpf/fillers.h	2024-01-16 19:19:37.460435872 +0100
@@ -2849,7 +2849,11 @@
 	CHECK_RES(res);
 
 	/* Parameter 26: exe_file mtime (last modification time, epoch value in nanoseconds) (type: PT_ABSTIME) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+	time = _READ(inode->__i_mtime);
+#else
 	time = _READ(inode->i_mtime);
+#endif
 	res = bpf_push_u64_to_ring(data, bpf_epoch_ns_from_time(time));
 	CHECK_RES(res);
 
@@ -6709,7 +6713,11 @@
 	CHECK_RES(res);
 
 	/* Parameter 26: exe_file mtime (last modification time, epoch value in nanoseconds) (type: PT_ABSTIME) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+	time = _READ(inode->__i_mtime);
+#else
 	time = _READ(inode->i_mtime);
+#endif
 	res = bpf_push_u64_to_ring(data, bpf_epoch_ns_from_time(time));
 	CHECK_RES(res);
 
diff -Naur libs-0.13.4/driver/modern_bpf/definitions/struct_flavors.h libs-0.13.4.new/driver/modern_bpf/definitions/struct_flavors.h
--- libs-0.13.4/driver/modern_bpf/definitions/struct_flavors.h	2023-10-26 18:38:45.000000000 +0200
+++ libs-0.13.4.new/driver/modern_bpf/definitions/struct_flavors.h	2024-01-16 19:21:12.399097235 +0100
@@ -40,6 +40,12 @@
 	struct timespec64 __i_ctime;
 };
 
+struct inode___v6_7 {
+       struct timespec64 __i_mtime;
+};
+
+
+
 #ifndef BPF_NO_PRESERVE_ACCESS_INDEX
 #pragma clang attribute pop
 #endif
diff -Naur libs-0.13.4/driver/modern_bpf/definitions/struct_flavors.h~ libs-0.13.4.new/driver/modern_bpf/definitions/struct_flavors.h~
--- libs-0.13.4/driver/modern_bpf/definitions/struct_flavors.h~	1970-01-01 01:00:00.000000000 +0100
+++ libs-0.13.4.new/driver/modern_bpf/definitions/struct_flavors.h~	2023-10-26 18:38:45.000000000 +0200
@@ -0,0 +1,65 @@
+/* We need this header to keep track of all struct/field/enum changes between kernel versions */
+
+#ifndef __STRUCT_FLAVORS_H__
+#define __STRUCT_FLAVORS_H__
+
+#include "vmlinux.h"
+
+#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
+#pragma clang attribute push(__attribute__((preserve_access_index)), apply_to = record)
+#endif
+
+struct mm_struct___v6_2
+{
+	struct percpu_counter rss_stat[NR_MM_COUNTERS];
+};
+
+typedef struct
+{
+	u64 val;
+} kernel_cap_t___v6_3;
+
+/* COS kernels handle audit field differently, see [1]. To support both
+ * versions define COS subset of task_struct with a flavor suffix (which will
+ * be ignored during relocation matching [2]).
+ *
+ * [1]: https://chromium.googlesource.com/chromiumos/third_party/kernel/+/096925a44076ba5c52faa84d255a847130ff341e%5E%21/#F2
+ * [2]: https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/tools/lib/bpf/libbpf.c#n5347
+ */
+struct audit_task_info {
+	kuid_t			loginuid;
+	unsigned int		sessionid;
+	struct audit_context	*ctx;
+};
+
+struct task_struct___cos {
+	struct audit_task_info		*audit;
+};
+
+struct inode___v6_6 {
+	struct timespec64 __i_ctime;
+};
+
+#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
+#pragma clang attribute pop
+#endif
+
+/* We don't need relocation on these structs, they are internally defined by us as a fallback!
+ * Use the prefix `modern_bpf__` before the real name of the struct we want to replace.
+ */
+
+/* We use this as a fallback for kernels where `struct __kernel_timespec` is not defined. */
+struct modern_bpf__kernel_timespec
+{
+	long int tv_sec;
+	long int tv_nsec;
+};
+
+/* We use this as a fallback for kernels where `struct __kernel_timex_timeval` is not defined. */
+struct modern_bpf__kernel_timex_timeval
+{
+	long long int tv_sec;
+	long long int tv_usec;
+};
+
+#endif /* __STRUCT_FLAVORS_H__ */
diff -Naur libs-0.13.4/driver/modern_bpf/programs/attached/events/sched_process_exec.bpf.c libs-0.13.4.new/driver/modern_bpf/programs/attached/events/sched_process_exec.bpf.c
--- libs-0.13.4/driver/modern_bpf/programs/attached/events/sched_process_exec.bpf.c	2023-10-26 18:38:45.000000000 +0200
+++ libs-0.13.4.new/driver/modern_bpf/programs/attached/events/sched_process_exec.bpf.c	2024-01-16 19:19:37.460435872 +0100
@@ -226,7 +226,15 @@
 	auxmap__store_u64_param(auxmap, extract__epoch_ns_from_time(time));
 
 	/* Parameter 26: exe_file mtime (last modification time, epoch value in nanoseconds) (type: PT_ABSTIME) */
-	BPF_CORE_READ_INTO(&time, exe_inode, i_mtime);
+	if(bpf_core_field_exists(exe_inode->i_mtime))
+	{
+		BPF_CORE_READ_INTO(&time, exe_inode, i_mtime);
+	}
+	else
+	{
+		struct inode___v6_7 *exe_inode_v6_7 = (void *)exe_inode;
+		BPF_CORE_READ_INTO(&time, exe_inode_v6_7, __i_mtime);
+	}
 	auxmap__store_u64_param(auxmap, extract__epoch_ns_from_time(time));
 
 	/* Parameter 27: euid (type: PT_UID) */
diff -Naur libs-0.13.4/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execveat.bpf.c libs-0.13.4.new/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execveat.bpf.c
--- libs-0.13.4/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execveat.bpf.c	2023-10-26 18:38:45.000000000 +0200
+++ libs-0.13.4.new/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execveat.bpf.c	2024-01-16 19:19:37.461435879 +0100
@@ -306,7 +306,15 @@
 	auxmap__store_u64_param(auxmap, extract__epoch_ns_from_time(time));
 
 	/* Parameter 26: exe_file mtime (last modification time, epoch value in nanoseconds) (type: PT_ABSTIME) */
-	BPF_CORE_READ_INTO(&time, exe_inode, i_mtime);
+	if(bpf_core_field_exists(exe_inode->i_mtime))
+	{
+		BPF_CORE_READ_INTO(&time, exe_inode, i_mtime);
+	}
+	else
+	{
+		struct inode___v6_7 *exe_inode_v6_7 = (void *)exe_inode;
+		BPF_CORE_READ_INTO(&time, exe_inode_v6_7, __i_mtime);
+	}
 	auxmap__store_u64_param(auxmap, extract__epoch_ns_from_time(time));
 
 	/* Parameter 27: euid (type: PT_UID) */
diff -Naur libs-0.13.4/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execve.bpf.c libs-0.13.4.new/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execve.bpf.c
--- libs-0.13.4/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execve.bpf.c	2023-10-26 18:38:45.000000000 +0200
+++ libs-0.13.4.new/driver/modern_bpf/programs/tail_called/events/syscall_dispatched_events/execve.bpf.c	2024-01-16 19:19:37.460435872 +0100
@@ -290,7 +290,15 @@
 	auxmap__store_u64_param(auxmap, extract__epoch_ns_from_time(time));
 
 	/* Parameter 26: exe_file mtime (last modification time, epoch value in nanoseconds) (type: PT_ABSTIME) */
-	BPF_CORE_READ_INTO(&time, exe_inode, i_mtime);
+	if(bpf_core_field_exists(exe_inode->i_mtime))
+	{
+		BPF_CORE_READ_INTO(&time, exe_inode, i_mtime);
+	}
+	else
+	{
+		struct inode___v6_7 *exe_inode_v6_7 = (void *)exe_inode;
+		BPF_CORE_READ_INTO(&time, exe_inode_v6_7, __i_mtime);
+	}
 	auxmap__store_u64_param(auxmap, extract__epoch_ns_from_time(time));
 
 	/* Parameter 27: euid (type: PT_UID) */
diff -Naur libs-0.13.4/driver/ppm_fillers.c libs-0.13.4.new/driver/ppm_fillers.c
--- libs-0.13.4/driver/ppm_fillers.c	2023-10-26 18:38:45.000000000 +0200
+++ libs-0.13.4.new/driver/ppm_fillers.c	2024-01-16 19:19:37.462435886 +0100
@@ -596,6 +596,12 @@
 	if (exe_file && !get_file_rcu(exe_file))
 		exe_file = NULL;
 	rcu_read_unlock();
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+	// Since linux 6.7.0, `get_file_rcu` is no more a define and takes a double pointer parameter.
+	// See https://github.com/torvalds/linux/commit/0ede61d8589cc2d93aa78230d74ac58b5b8d0244.
+	rcu_read_lock();
+	exe_file = get_file_rcu(&mm->exe_file);
+	rcu_read_unlock();
 #else
 	/* We need mmap_sem to protect against races with removal of
 	 * VM_EXECUTABLE vmas */
@@ -1525,7 +1531,15 @@
 				 * During kernel versions `i_mtime` changed from `struct timespec` to `struct timespec64`
 				 * but fields names should be always the same.
 				 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+				{
+					struct timespec64 inode_mtime;
+					inode_mtime = inode_get_mtime(file_inode(exe_file));
+					mtime = inode_mtime.tv_sec * (uint64_t)1000000000 + inode_mtime.tv_nsec;
+				}
+#else
 				mtime = file_inode(exe_file)->i_mtime.tv_sec * (uint64_t) 1000000000 + file_inode(exe_file)->i_mtime.tv_nsec;
+#endif
 			}
 #endif
 			/* Before freeing the exefile we catch the resolved path for symlink resolution */
@@ -7796,7 +7810,15 @@
 			 * During kernel versions `i_mtime` changed from `struct timespec` to `struct timespec64`
 			 * but fields names should be always the same.
 			 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+			{
+				struct timespec64 inode_mtime;
+				inode_mtime = inode_get_mtime(file_inode(exe_file));
+				mtime = inode_mtime.tv_sec * (uint64_t)1000000000 + inode_mtime.tv_nsec;
+			}
+#else
 			mtime = file_inode(exe_file)->i_mtime.tv_sec * (uint64_t) 1000000000 + file_inode(exe_file)->i_mtime.tv_nsec;
+#endif
 		}
 		/* Before free the exefile we catch the resolved path for symlink resolution */
 		trusted_exepath = d_path(&exe_file->f_path, buf, PAGE_SIZE);
