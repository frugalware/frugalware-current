diff -Naur firefox-78.15.0/python/mach/mach/config.py firefox-78.15.0.new/python/mach/mach/config.py
--- firefox-78.15.0/python/mach/mach/config.py	2021-09-28 12:04:57.000000000 +0200
+++ firefox-78.15.0.new/python/mach/mach/config.py	2022-08-24 19:30:18.978782840 +0200
@@ -17,6 +17,7 @@
 from __future__ import absolute_import, unicode_literals
 
 import collections
+import collections.abc
 import os
 import sys
 import six
@@ -144,7 +145,7 @@
     return _
 
 
-class ConfigSettings(collections.Mapping):
+class ConfigSettings(collections.abc.Mapping):
     """Interface for configuration settings.
 
     This is the main interface to the configuration.
@@ -190,7 +191,7 @@
     will result in exceptions being raised.
     """
 
-    class ConfigSection(collections.MutableMapping, object):
+    class ConfigSection(collections.abc.MutableMapping, object):
         """Represents an individual config section."""
         def __init__(self, config, name, settings):
             object.__setattr__(self, '_config', config)
diff -Naur firefox-78.15.0/python/mach/mach/decorators.py firefox-78.15.0.new/python/mach/mach/decorators.py
--- firefox-78.15.0/python/mach/mach/decorators.py	2021-09-28 12:04:57.000000000 +0200
+++ firefox-78.15.0.new/python/mach/mach/decorators.py	2022-08-24 19:30:18.978782840 +0200
@@ -6,6 +6,7 @@
 
 import argparse
 import collections
+import collections.abc
 
 from .base import MachError
 from .registrar import Registrar
@@ -140,7 +141,7 @@
               'Conditions argument must take a list ' + \
               'of functions. Found %s instead.'
 
-        if not isinstance(command.conditions, collections.Iterable):
+        if not isinstance(command.conditions, collections.abc.Iterable):
             msg = msg % (command.name, type(command.conditions))
             raise MachError(msg)
 
diff -Naur firefox-78.15.0/python/mach/mach/main.py firefox-78.15.0.new/python/mach/mach/main.py
--- firefox-78.15.0/python/mach/mach/main.py	2021-09-28 12:04:57.000000000 +0200
+++ firefox-78.15.0.new/python/mach/mach/main.py	2022-08-24 19:30:18.978782840 +0200
@@ -16,7 +16,7 @@
 import sys
 import traceback
 import uuid
-from collections import Iterable
+from collections.abc import Iterable
 
 from six import string_types
 
diff -Naur firefox-78.15.0/python/mozbuild/mozbuild/backend/configenvironment.py firefox-78.15.0.new/python/mozbuild/mozbuild/backend/configenvironment.py
--- firefox-78.15.0/python/mozbuild/mozbuild/backend/configenvironment.py	2021-09-28 12:04:57.000000000 +0200
+++ firefox-78.15.0.new/python/mozbuild/mozbuild/backend/configenvironment.py	2022-08-24 19:30:18.978782840 +0200
@@ -9,7 +9,8 @@
 import sys
 import json
 
-from collections import Iterable, OrderedDict
+from collections.abc import Iterable
+from collections import OrderedDict
 from types import ModuleType
 
 import mozpack.path as mozpath
diff -Naur firefox-78.15.0/python/mozbuild/mozbuild/makeutil.py firefox-78.15.0.new/python/mozbuild/mozbuild/makeutil.py
--- firefox-78.15.0/python/mozbuild/mozbuild/makeutil.py	2021-09-28 12:04:57.000000000 +0200
+++ firefox-78.15.0.new/python/mozbuild/mozbuild/makeutil.py	2022-08-24 19:30:18.979782785 +0200
@@ -7,7 +7,7 @@
 import os
 import re
 import six
-from collections import Iterable
+from collections.abc import Iterable
 
 
 class Makefile(object):
diff -Naur firefox-78.15.0/python/mozbuild/mozbuild/util.py firefox-78.15.0.new/python/mozbuild/mozbuild/util.py
--- firefox-78.15.0/python/mozbuild/mozbuild/util.py	2021-09-28 12:04:57.000000000 +0200
+++ firefox-78.15.0.new/python/mozbuild/mozbuild/util.py	2022-08-24 19:30:18.979782785 +0200
@@ -9,6 +9,7 @@
 
 import argparse
 import collections
+import collections.abc
 import ctypes
 import difflib
 import errno
@@ -782,7 +783,7 @@
         self._strings = StrictOrderingOnAppendList()
         self._children = {}
 
-    class StringListAdaptor(collections.Sequence):
+    class StringListAdaptor(collections.abc.Sequence):
         def __init__(self, hsl):
             self._hsl = hsl
 
diff -Naur firefox-78.15.0/taskcluster/taskgraph/util/schema.py firefox-78.15.0.new/taskcluster/taskgraph/util/schema.py
--- firefox-78.15.0/taskcluster/taskgraph/util/schema.py	2021-09-28 12:04:58.000000000 +0200
+++ firefox-78.15.0.new/taskcluster/taskgraph/util/schema.py	2022-08-24 19:30:18.979782785 +0200
@@ -7,6 +7,7 @@
 import re
 import pprint
 import collections
+import collections.abc
 import voluptuous
 
 from six import text_type, iteritems
@@ -160,7 +161,7 @@
                     'Unexpected type in YAML schema: {} @ {}'.format(
                         type(k).__name__, path))
 
-        if isinstance(sch, collections.Mapping):
+        if isinstance(sch, collections.abc.Mapping):
             for k, v in iteritems(sch):
                 child = "{}[{!r}]".format(path, k)
                 check_identifier(child, k)
diff -Naur firefox-78.15.0/testing/mozbase/manifestparser/manifestparser/filters.py firefox-78.15.0.new/testing/mozbase/manifestparser/manifestparser/filters.py
--- firefox-78.15.0/testing/mozbase/manifestparser/manifestparser/filters.py	2021-09-28 12:04:57.000000000 +0200
+++ firefox-78.15.0.new/testing/mozbase/manifestparser/manifestparser/filters.py	2022-08-24 19:30:18.980782729 +0200
@@ -12,7 +12,8 @@
 
 import itertools
 import os
-from collections import defaultdict, MutableSequence
+from collections import defaultdict
+from collections.abc import MutableSequence
 
 import six
 from six import string_types
diff -Naur firefox-78.15.0/third_party/python/gyp/pylib/gyp/common.py firefox-78.15.0.new/third_party/python/gyp/pylib/gyp/common.py
--- firefox-78.15.0/third_party/python/gyp/pylib/gyp/common.py	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/gyp/pylib/gyp/common.py	2022-08-24 19:30:18.980782729 +0200
@@ -5,6 +5,7 @@
 from __future__ import with_statement
 
 import collections
+import collections.abc
 import errno
 import filecmp
 import os.path
@@ -494,7 +495,7 @@
 
 
 # Based on http://code.activestate.com/recipes/576694/.
-class OrderedSet(collections.MutableSet):
+class OrderedSet(collections.abc.MutableSet):
   def __init__(self, iterable=None):
     self.end = end = []
     end += [None, end, end]         # sentinel node for doubly linked list
diff -Naur firefox-78.15.0/third_party/python/requirements.in firefox-78.15.0.new/third_party/python/requirements.in
--- firefox-78.15.0/third_party/python/requirements.in	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/requirements.in	2022-08-24 19:30:18.980782729 +0200
@@ -42,4 +42,4 @@
 responses==0.10.6
 sentry-sdk==0.14.3
 six==1.13.0
-voluptuous==0.11.5
+voluptuous==0.12.1
diff -Naur firefox-78.15.0/third_party/python/requirements.txt firefox-78.15.0.new/third_party/python/requirements.txt
--- firefox-78.15.0/third_party/python/requirements.txt	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/requirements.txt	2022-08-24 19:30:18.981782674 +0200
@@ -172,9 +172,9 @@
     --hash=sha256:3018294ebefce6572a474f0604c2021e33b3fd8006ecd11d62107a5d2a963527 \
     --hash=sha256:88206b0eb87e6d677d424843ac5209e3fb9d0190d0ee169599165ec25e9d9115 \
     # via sentry-sdk
-voluptuous==0.11.5 \
-    --hash=sha256:303542b3fc07fb52ec3d7a1c614b329cdbee13a9d681935353d8ea56a7bfa9f1 \
-    --hash=sha256:567a56286ef82a9d7ae0628c5842f65f516abcb496e74f3f59f1d7b28df314ef \
+voluptuous==0.12.1 \
+    --hash=sha256:663572419281ddfaf4b4197fd4942d181630120fb39b333e3adad70aeb56444b \
+    --hash=sha256:8ace33fcf9e6b1f59406bfaf6b8ec7bcc44266a9f29080b4deb4fe6ff2492386
     # via -r requirements-mach-vendor-python.in
 
 # WARNING: The following packages were not pinned, but pip requires them to be
diff -Naur firefox-78.15.0/third_party/python/voluptuous/README.md firefox-78.15.0.new/third_party/python/voluptuous/README.md
--- firefox-78.15.0/third_party/python/voluptuous/README.md	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/voluptuous/README.md	1970-01-01 01:00:00.000000000 +0100
@@ -1,723 +0,0 @@
-# Voluptuous is a Python data validation library
-
-[![Build Status](https://travis-ci.org/alecthomas/voluptuous.png)](https://travis-ci.org/alecthomas/voluptuous)
-[![Coverage Status](https://coveralls.io/repos/github/alecthomas/voluptuous/badge.svg?branch=master)](https://coveralls.io/github/alecthomas/voluptuous?branch=master) [![Gitter chat](https://badges.gitter.im/alecthomas.png)](https://gitter.im/alecthomas/Lobby)
-
-Voluptuous, *despite* the name, is a Python data validation library. It
-is primarily intended for validating data coming into Python as JSON,
-YAML, etc.
-
-It has three goals:
-
-1.  Simplicity.
-2.  Support for complex data structures.
-3.  Provide useful error messages.
-
-## Contact
-
-Voluptuous now has a mailing list! Send a mail to
-[<voluptuous@librelist.com>](mailto:voluptuous@librelist.com) to subscribe. Instructions
-will follow.
-
-You can also contact me directly via [email](mailto:alec@swapoff.org) or
-[Twitter](https://twitter.com/alecthomas).
-
-To file a bug, create a [new issue](https://github.com/alecthomas/voluptuous/issues/new) on GitHub with a short example of how to replicate the issue.
-
-## Documentation
-
-The documentation is provided [here](http://alecthomas.github.io/voluptuous/).
-
-## Changelog
-
-See [CHANGELOG.md](https://github.com/alecthomas/voluptuous/blob/master/CHANGELOG.md).
-
-## Show me an example
-
-Twitter's [user search API](https://dev.twitter.com/rest/reference/get/users/search) accepts
-query URLs like:
-
-```
-$ curl 'https://api.twitter.com/1.1/users/search.json?q=python&per_page=20&page=1'
-```
-
-To validate this we might use a schema like:
-
-```pycon
->>> from voluptuous import Schema
->>> schema = Schema({
-...   'q': str,
-...   'per_page': int,
-...   'page': int,
-... })
-
-```
-
-This schema very succinctly and roughly describes the data required by
-the API, and will work fine. But it has a few problems. Firstly, it
-doesn't fully express the constraints of the API. According to the API,
-`per_page` should be restricted to at most 20, defaulting to 5, for
-example. To describe the semantics of the API more accurately, our
-schema will need to be more thoroughly defined:
-
-```pycon
->>> from voluptuous import Required, All, Length, Range
->>> schema = Schema({
-...   Required('q'): All(str, Length(min=1)),
-...   Required('per_page', default=5): All(int, Range(min=1, max=20)),
-...   'page': All(int, Range(min=0)),
-... })
-
-```
-
-This schema fully enforces the interface defined in Twitter's
-documentation, and goes a little further for completeness.
-
-"q" is required:
-
-```pycon
->>> from voluptuous import MultipleInvalid, Invalid
->>> try:
-...   schema({})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "required key not provided @ data['q']"
-True
-
-```
-
-...must be a string:
-
-```pycon
->>> try:
-...   schema({'q': 123})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "expected str for dictionary value @ data['q']"
-True
-
-```
-
-...and must be at least one character in length:
-
-```pycon
->>> try:
-...   schema({'q': ''})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "length of value must be at least 1 for dictionary value @ data['q']"
-True
->>> schema({'q': '#topic'}) == {'q': '#topic', 'per_page': 5}
-True
-
-```
-
-"per\_page" is a positive integer no greater than 20:
-
-```pycon
->>> try:
-...   schema({'q': '#topic', 'per_page': 900})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "value must be at most 20 for dictionary value @ data['per_page']"
-True
->>> try:
-...   schema({'q': '#topic', 'per_page': -10})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "value must be at least 1 for dictionary value @ data['per_page']"
-True
-
-```
-
-"page" is an integer \>= 0:
-
-```pycon
->>> try:
-...   schema({'q': '#topic', 'per_page': 'one'})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc)
-"expected int for dictionary value @ data['per_page']"
->>> schema({'q': '#topic', 'page': 1}) == {'q': '#topic', 'page': 1, 'per_page': 5}
-True
-
-```
-
-## Defining schemas
-
-Schemas are nested data structures consisting of dictionaries, lists,
-scalars and *validators*. Each node in the input schema is pattern
-matched against corresponding nodes in the input data.
-
-### Literals
-
-Literals in the schema are matched using normal equality checks:
-
-```pycon
->>> schema = Schema(1)
->>> schema(1)
-1
->>> schema = Schema('a string')
->>> schema('a string')
-'a string'
-
-```
-
-### Types
-
-Types in the schema are matched by checking if the corresponding value
-is an instance of the type:
-
-```pycon
->>> schema = Schema(int)
->>> schema(1)
-1
->>> try:
-...   schema('one')
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "expected int"
-True
-
-```
-
-### URL's
-
-URL's in the schema are matched by using `urlparse` library.
-
-```pycon
->>> from voluptuous import Url
->>> schema = Schema(Url())
->>> schema('http://w3.org')
-'http://w3.org'
->>> try:
-...   schema('one')
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "expected a URL"
-True
-
-```
-
-### Lists
-
-Lists in the schema are treated as a set of valid values. Each element
-in the schema list is compared to each value in the input data:
-
-```pycon
->>> schema = Schema([1, 'a', 'string'])
->>> schema([1])
-[1]
->>> schema([1, 1, 1])
-[1, 1, 1]
->>> schema(['a', 1, 'string', 1, 'string'])
-['a', 1, 'string', 1, 'string']
-
-```
-
-However, an empty list (`[]`) is treated as is. If you want to specify a list that can
-contain anything, specify it as `list`:
-
-```pycon
->>> schema = Schema([])
->>> try:
-...   schema([1])
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "not a valid value @ data[1]"
-True
->>> schema([])
-[]
->>> schema = Schema(list)
->>> schema([])
-[]
->>> schema([1, 2])
-[1, 2]
-
-```
-
-### Sets and frozensets
-
-Sets and frozensets are treated as a set of valid values. Each element
-in the schema set is compared to each value in the input data:
-
-```pycon
->>> schema = Schema({42})
->>> schema({42}) == {42}
-True
->>> try:
-...   schema({43})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "invalid value in set"
-True
->>> schema = Schema({int})
->>> schema({1, 2, 3}) == {1, 2, 3}
-True
->>> schema = Schema({int, str})
->>> schema({1, 2, 'abc'}) == {1, 2, 'abc'}
-True
->>> schema = Schema(frozenset([int]))
->>> try:
-...   schema({3})
-...   raise AssertionError('Invalid not raised')
-... except Invalid as e:
-...   exc = e
->>> str(exc) == 'expected a frozenset'
-True
-
-```
-
-However, an empty set (`set()`) is treated as is. If you want to specify a set
-that can contain anything, specify it as `set`:
-
-```pycon
->>> schema = Schema(set())
->>> try:
-...   schema({1})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "invalid value in set"
-True
->>> schema(set()) == set()
-True
->>> schema = Schema(set)
->>> schema({1, 2}) == {1, 2}
-True
-
-```
-
-### Validation functions
-
-Validators are simple callables that raise an `Invalid` exception when
-they encounter invalid data. The criteria for determining validity is
-entirely up to the implementation; it may check that a value is a valid
-username with `pwd.getpwnam()`, it may check that a value is of a
-specific type, and so on.
-
-The simplest kind of validator is a Python function that raises
-ValueError when its argument is invalid. Conveniently, many builtin
-Python functions have this property. Here's an example of a date
-validator:
-
-```pycon
->>> from datetime import datetime
->>> def Date(fmt='%Y-%m-%d'):
-...   return lambda v: datetime.strptime(v, fmt)
-
-```
-
-```pycon
->>> schema = Schema(Date())
->>> schema('2013-03-03')
-datetime.datetime(2013, 3, 3, 0, 0)
->>> try:
-...   schema('2013-03')
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "not a valid value"
-True
-
-```
-
-In addition to simply determining if a value is valid, validators may
-mutate the value into a valid form. An example of this is the
-`Coerce(type)` function, which returns a function that coerces its
-argument to the given type:
-
-```python
-def Coerce(type, msg=None):
-    """Coerce a value to a type.
-
-    If the type constructor throws a ValueError, the value will be marked as
-    Invalid.
-    """
-    def f(v):
-        try:
-            return type(v)
-        except ValueError:
-            raise Invalid(msg or ('expected %s' % type.__name__))
-    return f
-
-```
-
-This example also shows a common idiom where an optional human-readable
-message can be provided. This can vastly improve the usefulness of the
-resulting error messages.
-
-### Dictionaries
-
-Each key-value pair in a schema dictionary is validated against each
-key-value pair in the corresponding data dictionary:
-
-```pycon
->>> schema = Schema({1: 'one', 2: 'two'})
->>> schema({1: 'one'})
-{1: 'one'}
-
-```
-
-#### Extra dictionary keys
-
-By default any additional keys in the data, not in the schema will
-trigger exceptions:
-
-```pycon
->>> schema = Schema({2: 3})
->>> try:
-...   schema({1: 2, 2: 3})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "extra keys not allowed @ data[1]"
-True
-
-```
-
-This behaviour can be altered on a per-schema basis. To allow
-additional keys use
-`Schema(..., extra=ALLOW_EXTRA)`:
-
-```pycon
->>> from voluptuous import ALLOW_EXTRA
->>> schema = Schema({2: 3}, extra=ALLOW_EXTRA)
->>> schema({1: 2, 2: 3})
-{1: 2, 2: 3}
-
-```
-
-To remove additional keys use
-`Schema(..., extra=REMOVE_EXTRA)`:
-
-```pycon
->>> from voluptuous import REMOVE_EXTRA
->>> schema = Schema({2: 3}, extra=REMOVE_EXTRA)
->>> schema({1: 2, 2: 3})
-{2: 3}
-
-```
-
-It can also be overridden per-dictionary by using the catch-all marker
-token `extra` as a key:
-
-```pycon
->>> from voluptuous import Extra
->>> schema = Schema({1: {Extra: object}})
->>> schema({1: {'foo': 'bar'}})
-{1: {'foo': 'bar'}}
-
-```
-
-#### Required dictionary keys
-
-By default, keys in the schema are not required to be in the data:
-
-```pycon
->>> schema = Schema({1: 2, 3: 4})
->>> schema({3: 4})
-{3: 4}
-
-```
-
-Similarly to how extra\_ keys work, this behaviour can be overridden
-per-schema:
-
-```pycon
->>> schema = Schema({1: 2, 3: 4}, required=True)
->>> try:
-...   schema({3: 4})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "required key not provided @ data[1]"
-True
-
-```
-
-And per-key, with the marker token `Required(key)`:
-
-```pycon
->>> schema = Schema({Required(1): 2, 3: 4})
->>> try:
-...   schema({3: 4})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "required key not provided @ data[1]"
-True
->>> schema({1: 2})
-{1: 2}
-
-```
-
-#### Optional dictionary keys
-
-If a schema has `required=True`, keys may be individually marked as
-optional using the marker token `Optional(key)`:
-
-```pycon
->>> from voluptuous import Optional
->>> schema = Schema({1: 2, Optional(3): 4}, required=True)
->>> try:
-...   schema({})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "required key not provided @ data[1]"
-True
->>> schema({1: 2})
-{1: 2}
->>> try:
-...   schema({1: 2, 4: 5})
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "extra keys not allowed @ data[4]"
-True
-
-```
-
-```pycon
->>> schema({1: 2, 3: 4})
-{1: 2, 3: 4}
-
-```
-
-### Recursive / nested schema
-
-You can use `voluptuous.Self` to define a nested schema:
-
-```pycon
->>> from voluptuous import Schema, Self
->>> recursive = Schema({"more": Self, "value": int})
->>> recursive({"more": {"value": 42}, "value": 41}) == {'more': {'value': 42}, 'value': 41}
-True
-
-```
-
-### Extending an existing Schema
-
-Often it comes handy to have a base `Schema` that is extended with more
-requirements. In that case you can use `Schema.extend` to create a new
-`Schema`:
-
-```pycon
->>> from voluptuous import Schema
->>> person = Schema({'name': str})
->>> person_with_age = person.extend({'age': int})
->>> sorted(list(person_with_age.schema.keys()))
-['age', 'name']
-
-```
-
-The original `Schema` remains unchanged.
-
-### Objects
-
-Each key-value pair in a schema dictionary is validated against each
-attribute-value pair in the corresponding object:
-
-```pycon
->>> from voluptuous import Object
->>> class Structure(object):
-...     def __init__(self, q=None):
-...         self.q = q
-...     def __repr__(self):
-...         return '<Structure(q={0.q!r})>'.format(self)
-...
->>> schema = Schema(Object({'q': 'one'}, cls=Structure))
->>> schema(Structure(q='one'))
-<Structure(q='one')>
-
-```
-
-### Allow None values
-
-To allow value to be None as well, use Any:
-
-```pycon
->>> from voluptuous import Any
-
->>> schema = Schema(Any(None, int))
->>> schema(None)
->>> schema(5)
-5
-
-```
-
-## Error reporting
-
-Validators must throw an `Invalid` exception if invalid data is passed
-to them. All other exceptions are treated as errors in the validator and
-will not be caught.
-
-Each `Invalid` exception has an associated `path` attribute representing
-the path in the data structure to our currently validating value, as well
-as an `error_message` attribute that contains the message of the original
-exception. This is especially useful when you want to catch `Invalid`
-exceptions and give some feedback to the user, for instance in the context of
-an HTTP API.
-
-
-```pycon
->>> def validate_email(email):
-...     """Validate email."""
-...     if not "@" in email:
-...         raise Invalid("This email is invalid.")
-...     return email
->>> schema = Schema({"email": validate_email})
->>> exc = None
->>> try:
-...     schema({"email": "whatever"})
-... except MultipleInvalid as e:
-...     exc = e
->>> str(exc)
-"This email is invalid. for dictionary value @ data['email']"
->>> exc.path
-['email']
->>> exc.msg
-'This email is invalid.'
->>> exc.error_message
-'This email is invalid.'
-
-```
-
-The `path` attribute is used during error reporting, but also during matching
-to determine whether an error should be reported to the user or if the next
-match should be attempted. This is determined by comparing the depth of the
-path where the check is, to the depth of the path where the error occurred. If
-the error is more than one level deeper, it is reported.
-
-The upshot of this is that *matching is depth-first and fail-fast*.
-
-To illustrate this, here is an example schema:
-
-```pycon
->>> schema = Schema([[2, 3], 6])
-
-```
-
-Each value in the top-level list is matched depth-first in-order. Given
-input data of `[[6]]`, the inner list will match the first element of
-the schema, but the literal `6` will not match any of the elements of
-that list. This error will be reported back to the user immediately. No
-backtracking is attempted:
-
-```pycon
->>> try:
-...   schema([[6]])
-...   raise AssertionError('MultipleInvalid not raised')
-... except MultipleInvalid as e:
-...   exc = e
->>> str(exc) == "not a valid value @ data[0][0]"
-True
-
-```
-
-If we pass the data `[6]`, the `6` is not a list type and so will not
-recurse into the first element of the schema. Matching will continue on
-to the second element in the schema, and succeed:
-
-```pycon
->>> schema([6])
-[6]
-
-```
-
-## Multi-field validation
-
-Validation rules that involve multiple fields can be implemented as
-custom validators. It's recommended to use `All()` to do a two-pass
-validation - the first pass checking the basic structure of the data,
-and only after that, the second pass applying your cross-field
-validator:
-
-```python
-def passwords_must_match(passwords):
-    if passwords['password'] != passwords['password_again']:
-        raise Invalid('passwords must match')
-    return passwords
-
-s=Schema(All(
-    # First "pass" for field types
-    {'password':str, 'password_again':str},
-    # Follow up the first "pass" with your multi-field rules
-    passwords_must_match
-))
-
-# valid
-s({'password':'123', 'password_again':'123'})
-
-# raises MultipleInvalid: passwords must match
-s({'password':'123', 'password_again':'and now for something completely different'})
-
-```
-
-With this structure, your multi-field validator will run with
-pre-validated data from the first "pass" and so will not have to do
-its own type checking on its inputs.
-
-The flipside is that if the first "pass" of validation fails, your
-cross-field validator will not run:
-
-```
-# raises Invalid because password_again is not a string
-# passwords_must_match() will not run because first-pass validation already failed
-s({'password':'123', 'password_again': 1337})
-```
-
-## Running tests.
-
-Voluptuous is using nosetests:
-
-    $ nosetests
-
-
-## Why use Voluptuous over another validation library?
-
-**Validators are simple callables**
-:   No need to subclass anything, just use a function.
-
-**Errors are simple exceptions.**
-:   A validator can just `raise Invalid(msg)` and expect the user to get
-useful messages.
-
-**Schemas are basic Python data structures.**
-:   Should your data be a dictionary of integer keys to strings?
-`{int: str}` does what you expect. List of integers, floats or
-strings? `[int, float, str]`.
-
-**Designed from the ground up for validating more than just forms.**
-:   Nested data structures are treated in the same way as any other
-type. Need a list of dictionaries? `[{}]`
-
-**Consistency.**
-:   Types in the schema are checked as types. Values are compared as
-values. Callables are called to validate. Simple.
-
-## Other libraries and inspirations
-
-Voluptuous is heavily inspired by
-[Validino](http://code.google.com/p/validino/), and to a lesser extent,
-[jsonvalidator](http://code.google.com/p/jsonvalidator/) and
-[json\_schema](http://blog.sendapatch.se/category/json_schema.html).
-
-[pytest-voluptuous](https://github.com/F-Secure/pytest-voluptuous) is a
-[pytest](https://github.com/pytest-dev/pytest) plugin that helps in
-using voluptuous validators in `assert`s.
-
-I greatly prefer the light-weight style promoted by these libraries to
-the complexity of libraries like FormEncode.
diff -Naur firefox-78.15.0/third_party/python/voluptuous/voluptuous/error.py firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/error.py
--- firefox-78.15.0/third_party/python/voluptuous/voluptuous/error.py	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/error.py	2022-08-24 19:30:18.982782618 +0200
@@ -142,11 +142,11 @@
 
 
 class UrlInvalid(Invalid):
-    """The value is not a url."""
+    """The value is not a URL."""
 
 
 class EmailInvalid(Invalid):
-    """The value is not a email."""
+    """The value is not an email address."""
 
 
 class FileInvalid(Invalid):
diff -Naur firefox-78.15.0/third_party/python/voluptuous/voluptuous/__init__.py firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/__init__.py
--- firefox-78.15.0/third_party/python/voluptuous/voluptuous/__init__.py	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/__init__.py	2022-08-24 19:30:18.982782618 +0200
@@ -5,5 +5,5 @@
 from voluptuous.util import *
 from voluptuous.error import *
 
-__version__ = '0.11.5'
+__version__ = '0.12.1'
 __author__ = 'alecthomas'
diff -Naur firefox-78.15.0/third_party/python/voluptuous/voluptuous/schema_builder.py firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/schema_builder.py
--- firefox-78.15.0/third_party/python/voluptuous/voluptuous/schema_builder.py	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/schema_builder.py	2022-08-24 19:30:18.983782562 +0200
@@ -22,6 +22,11 @@
     def iteritems(d):
         return d.iteritems()
 
+if sys.version_info >= (3, 3):
+    _Mapping = collections.abc.Mapping
+else:
+    _Mapping = collections.Mapping
+
 """Schema validation for Python data structures.
 
 Given eg. a nested data structure like this:
@@ -280,7 +285,7 @@
             return schema.__voluptuous_compile__(self)
         if isinstance(schema, Object):
             return self._compile_object(schema)
-        if isinstance(schema, collections.Mapping):
+        if isinstance(schema, _Mapping):
             return self._compile_dict(schema)
         elif isinstance(schema, list):
             return self._compile_list(schema)
@@ -610,11 +615,11 @@
             if not isinstance(data, seq_type):
                 raise er.SequenceTypeInvalid('expected a %s' % seq_type_name, path)
 
-            # Empty seq schema, allow any data.
+            # Empty seq schema, reject any data.
             if not schema:
                 if data:
                     raise er.MultipleInvalid([
-                        er.ValueInvalid('not a valid value', [value]) for value in data
+                        er.ValueInvalid('not a valid value', path if path else data)
                     ])
                 return data
 
@@ -735,7 +740,7 @@
 
         result = self.schema.copy()
 
-        # returns the key that may have been passed as arugment to Marker constructor
+        # returns the key that may have been passed as an argument to Marker constructor
         def key_literal(key):
             return (key.schema if isinstance(key, Marker) else key)
 
@@ -771,9 +776,10 @@
                 result[key] = value
 
         # recompile and send old object
+        result_cls = type(self)
         result_required = (required if required is not None else self.required)
         result_extra = (extra if extra is not None else self.extra)
-        return Schema(result, required=result_required, extra=result_extra)
+        return result_cls(result, required=result_required, extra=result_extra)
 
 
 def _compile_scalar(schema):
@@ -809,7 +815,7 @@
         def validate_callable(path, data):
             try:
                 return schema(data)
-            except ValueError as e:
+            except ValueError:
                 raise er.ValueInvalid('not a valid value', path)
             except er.Invalid as e:
                 e.prepend(path)
@@ -1121,8 +1127,11 @@
     True
     """
 
-    def __init__(self, schema, group_of_inclusion, msg=None):
-        super(Inclusive, self).__init__(schema, msg=msg)
+    def __init__(self, schema, group_of_inclusion,
+                 msg=None, description=None, default=UNDEFINED):
+        super(Inclusive, self).__init__(schema, msg=msg,
+                                        default=default,
+                                        description=description)
         self.group_of_inclusion = group_of_inclusion
 
 
diff -Naur firefox-78.15.0/third_party/python/voluptuous/voluptuous/util.py firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/util.py
--- firefox-78.15.0/third_party/python/voluptuous/voluptuous/util.py	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/util.py	2022-08-24 19:30:18.983782562 +0200
@@ -7,6 +7,14 @@
 __author__ = 'tusharmakkar08'
 
 
+def _fix_str(v):
+    if sys.version_info[0] == 2 and isinstance(v, unicode):
+        s = v
+    else:
+        s = str(v)
+    return s
+
+
 def Lower(v):
     """Transform a string to lower case.
 
@@ -14,7 +22,7 @@
     >>> s('HI')
     'hi'
     """
-    return str(v).lower()
+    return _fix_str(v).lower()
 
 
 def Upper(v):
@@ -24,7 +32,7 @@
     >>> s('hi')
     'HI'
     """
-    return str(v).upper()
+    return _fix_str(v).upper()
 
 
 def Capitalize(v):
@@ -34,7 +42,7 @@
     >>> s('hello world')
     'Hello world'
     """
-    return str(v).capitalize()
+    return _fix_str(v).capitalize()
 
 
 def Title(v):
@@ -44,7 +52,7 @@
     >>> s('hello world')
     'Hello World'
     """
-    return str(v).title()
+    return _fix_str(v).title()
 
 
 def Strip(v):
@@ -54,7 +62,7 @@
     >>> s('  hello world  ')
     'hello world'
     """
-    return str(v).strip()
+    return _fix_str(v).strip()
 
 
 class DefaultTo(object):
diff -Naur firefox-78.15.0/third_party/python/voluptuous/voluptuous/validators.py firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/validators.py
--- firefox-78.15.0/third_party/python/voluptuous/voluptuous/validators.py	2021-09-28 12:05:01.000000000 +0200
+++ firefox-78.15.0.new/third_party/python/voluptuous/voluptuous/validators.py	2022-08-24 19:30:18.983782562 +0200
@@ -192,15 +192,26 @@
     def __init__(self, *validators, **kwargs):
         self.validators = validators
         self.msg = kwargs.pop('msg', None)
+        self.required = kwargs.pop('required', False)
+        self.discriminant = kwargs.pop('discriminant', None)
 
     def __voluptuous_compile__(self, schema):
-        self._compiled = [
-            schema._compile(v)
-            for v in self.validators
-        ]
+        self._compiled = []
+        old_required = schema.required
+        self.schema = schema
+        for v in self.validators:
+            schema.required = self.required
+            self._compiled.append(schema._compile(v))
+        schema.required = old_required
         return self._run
 
     def _run(self, path, value):
+        if self.discriminant is not None:
+            self._compiled = [
+                self.schema._compile(v)
+                for v in self.discriminant(value, self.validators)
+            ]
+
         return self._exec(self._compiled, value, path)
 
     def __call__(self, v):
@@ -218,7 +229,7 @@
     """Use the first validated value.
 
     :param msg: Message to deliver to user if validation fails.
-    :param kwargs: All other keyword arguments are passed to the sub-Schema constructors.
+    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.
     :returns: Return value of the first validator that passes.
 
     >>> validate = Schema(Any('true', 'false',
@@ -262,13 +273,57 @@
 Or = Any
 
 
+class Union(_WithSubValidators):
+    """Use the first validated value among those selected by discriminant.
+
+    :param msg: Message to deliver to user if validation fails.
+    :param discriminant(value, validators): Returns the filtered list of validators based on the value.
+    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.
+    :returns: Return value of the first validator that passes.
+
+    >>> validate = Schema(Union({'type':'a', 'a_val':'1'},{'type':'b', 'b_val':'2'},
+    ...                         discriminant=lambda val, alt: filter(
+    ...                         lambda v : v['type'] == val['type'] , alt)))
+    >>> validate({'type':'a', 'a_val':'1'}) == {'type':'a', 'a_val':'1'}
+    True
+    >>> with raises(MultipleInvalid, "not a valid value for dictionary value @ data['b_val']"):
+    ...   validate({'type':'b', 'b_val':'5'})
+
+    ```discriminant({'type':'b', 'a_val':'5'}, [{'type':'a', 'a_val':'1'},{'type':'b', 'b_val':'2'}])``` is invoked
+
+    Without the discriminant, the exception would be "extra keys not allowed @ data['b_val']"
+    """
+
+    def _exec(self, funcs, v, path=None):
+        error = None
+        for func in funcs:
+            try:
+                if path is None:
+                    return func(v)
+                else:
+                    return func(path, v)
+            except Invalid as e:
+                if error is None or len(e.path) > len(error.path):
+                    error = e
+        else:
+            if error:
+                raise error if self.msg is None else AnyInvalid(
+                    self.msg, path=path)
+            raise AnyInvalid(self.msg or 'no valid value found',
+                             path=path)
+
+
+# Convenience alias
+Switch = Union
+
+
 class All(_WithSubValidators):
     """Value must pass all validators.
 
     The output of each validator is passed as input to the next.
 
     :param msg: Message to deliver to user if validation fails.
-    :param kwargs: All other keyword arguments are passed to the sub-Schema constructors.
+    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.
 
     >>> validate = Schema(All('10', Coerce(int)))
     >>> validate('10')
@@ -303,7 +358,7 @@
     >>> with raises(MultipleInvalid, 'expected string or buffer'):
     ...   validate(123)
 
-    Pattern may also be a _compiled regular expression:
+    Pattern may also be a compiled regular expression:
 
     >>> validate = Schema(Match(re.compile(r'0x[A-F0-9]+', re.I)))
     >>> validate('0x123ef4')
@@ -361,38 +416,38 @@
     return parsed
 
 
-@message('expected an Email', cls=EmailInvalid)
+@message('expected an email address', cls=EmailInvalid)
 def Email(v):
-    """Verify that the value is an Email or not.
+    """Verify that the value is an email address or not.
 
     >>> s = Schema(Email())
-    >>> with raises(MultipleInvalid, 'expected an Email'):
+    >>> with raises(MultipleInvalid, 'expected an email address'):
     ...   s("a.com")
-    >>> with raises(MultipleInvalid, 'expected an Email'):
+    >>> with raises(MultipleInvalid, 'expected an email address'):
     ...   s("a@.com")
-    >>> with raises(MultipleInvalid, 'expected an Email'):
+    >>> with raises(MultipleInvalid, 'expected an email address'):
     ...   s("a@.com")
     >>> s('t@x.com')
     't@x.com'
     """
     try:
         if not v or "@" not in v:
-            raise EmailInvalid("Invalid Email")
+            raise EmailInvalid("Invalid email address")
         user_part, domain_part = v.rsplit('@', 1)
 
         if not (USER_REGEX.match(user_part) and DOMAIN_REGEX.match(domain_part)):
-            raise EmailInvalid("Invalid Email")
+            raise EmailInvalid("Invalid email address")
         return v
     except:
         raise ValueError
 
 
-@message('expected a Fully qualified domain name URL', cls=UrlInvalid)
+@message('expected a fully qualified domain name URL', cls=UrlInvalid)
 def FqdnUrl(v):
-    """Verify that the value is a Fully qualified domain name URL.
+    """Verify that the value is a fully qualified domain name URL.
 
     >>> s = Schema(FqdnUrl())
-    >>> with raises(MultipleInvalid, 'expected a Fully qualified domain name URL'):
+    >>> with raises(MultipleInvalid, 'expected a fully qualified domain name URL'):
     ...   s("http://localhost/")
     >>> s('http://w3.org')
     'http://w3.org'
@@ -423,14 +478,14 @@
         raise ValueError
 
 
-@message('not a file', cls=FileInvalid)
+@message('Not a file', cls=FileInvalid)
 @truth
 def IsFile(v):
     """Verify the file exists.
 
     >>> os.path.basename(IsFile()(__file__)).startswith('validators.py')
     True
-    >>> with raises(FileInvalid, 'not a file'):
+    >>> with raises(FileInvalid, 'Not a file'):
     ...   IsFile()("random_filename_goes_here.py")
     >>> with raises(FileInvalid, 'Not a file'):
     ...   IsFile()(None)
@@ -445,7 +500,7 @@
         raise FileInvalid('Not a file')
 
 
-@message('not a directory', cls=DirInvalid)
+@message('Not a directory', cls=DirInvalid)
 @truth
 def IsDir(v):
     """Verify the directory exists.
@@ -487,11 +542,11 @@
         raise PathInvalid("Not a Path")
 
 
-def Maybe(validator):
+def Maybe(validator, msg=None):
     """Validate that the object matches given validator or is None.
 
-    :raises Invalid: if the value does not match the given validator and is not
-        None
+    :raises Invalid: If the value does not match the given validator and is not
+        None.
 
     >>> s = Schema(Maybe(int))
     >>> s(10)
@@ -500,7 +555,7 @@
     ...  s("string")
 
     """
-    return Any(None, validator)
+    return Any(validator, None, msg=msg)
 
 
 class Range(object):
@@ -533,23 +588,30 @@
         self.msg = msg
 
     def __call__(self, v):
-        if self.min_included:
-            if self.min is not None and not v >= self.min:
-                raise RangeInvalid(
-                    self.msg or 'value must be at least %s' % self.min)
-        else:
-            if self.min is not None and not v > self.min:
-                raise RangeInvalid(
-                    self.msg or 'value must be higher than %s' % self.min)
-        if self.max_included:
-            if self.max is not None and not v <= self.max:
-                raise RangeInvalid(
-                    self.msg or 'value must be at most %s' % self.max)
-        else:
-            if self.max is not None and not v < self.max:
-                raise RangeInvalid(
-                    self.msg or 'value must be lower than %s' % self.max)
-        return v
+        try:
+            if self.min_included:
+                if self.min is not None and not v >= self.min:
+                    raise RangeInvalid(
+                        self.msg or 'value must be at least %s' % self.min)
+            else:
+                if self.min is not None and not v > self.min:
+                    raise RangeInvalid(
+                        self.msg or 'value must be higher than %s' % self.min)
+            if self.max_included:
+                if self.max is not None and not v <= self.max:
+                    raise RangeInvalid(
+                        self.msg or 'value must be at most %s' % self.max)
+            else:
+                if self.max is not None and not v < self.max:
+                    raise RangeInvalid(
+                        self.msg or 'value must be lower than %s' % self.max)
+
+            return v
+
+        # Objects that lack a partial ordering, e.g. None or strings will raise TypeError
+        except TypeError:
+            raise RangeInvalid(
+                self.msg or 'invalid value or type (must have a partial ordering)')
 
     def __repr__(self):
         return ('Range(min=%r, max=%r, min_included=%r,'
@@ -579,11 +641,17 @@
         self.msg = msg
 
     def __call__(self, v):
-        if self.min is not None and v < self.min:
-            v = self.min
-        if self.max is not None and v > self.max:
-            v = self.max
-        return v
+        try:
+            if self.min is not None and v < self.min:
+                v = self.min
+            if self.max is not None and v > self.max:
+                v = self.max
+            return v
+
+        # Objects that lack a partial ordering, e.g. None or strings will raise TypeError
+        except TypeError:
+            raise RangeInvalid(
+                self.msg or 'invalid value or type (must have a partial ordering)')
 
     def __repr__(self):
         return 'Clamp(min=%s, max=%s)' % (self.min, self.max)
@@ -598,13 +666,19 @@
         self.msg = msg
 
     def __call__(self, v):
-        if self.min is not None and len(v) < self.min:
-            raise LengthInvalid(
-                self.msg or 'length of value must be at least %s' % self.min)
-        if self.max is not None and len(v) > self.max:
-            raise LengthInvalid(
-                self.msg or 'length of value must be at most %s' % self.max)
-        return v
+        try:
+            if self.min is not None and len(v) < self.min:
+                raise LengthInvalid(
+                    self.msg or 'length of value must be at least %s' % self.min)
+            if self.max is not None and len(v) > self.max:
+                raise LengthInvalid(
+                    self.msg or 'length of value must be at most %s' % self.max)
+            return v
+
+        # Objects that havbe no length e.g. None or strings will raise TypeError
+        except TypeError:
+            raise RangeInvalid(
+                self.msg or 'invalid value or type')
 
     def __repr__(self):
         return 'Length(min=%s, max=%s)' % (self.min, self.max)
@@ -663,7 +737,8 @@
         except TypeError:
             check = True
         if check:
-            raise InInvalid(self.msg or 'value is not allowed')
+            raise InInvalid(self.msg or 
+                            'value must be one of {}'.format(sorted(self.container)))
         return v
 
     def __repr__(self):
@@ -683,7 +758,8 @@
         except TypeError:
             check = True
         if check:
-            raise NotInInvalid(self.msg or 'value is not allowed')
+            raise NotInInvalid(self.msg or 
+                               'value must not be one of {}'.format(sorted(self.container)))
         return v
 
     def __repr__(self):
@@ -722,7 +798,7 @@
     the validators.
 
     :param msg: Message to deliver to user if validation fails.
-    :param kwargs: All other keyword arguments are passed to the sub-Schema
+    :param kwargs: All other keyword arguments are passed to the sub-schema
         constructors.
 
     >>> from voluptuous import Schema, ExactSequence
@@ -887,7 +963,7 @@
 class Number(object):
     """
     Verify the number of digits that are present in the number(Precision),
-    and the decimal places(Scale)
+    and the decimal places(Scale).
 
     :raises Invalid: If the value does not match the provided Precision and Scale.
 
@@ -951,13 +1027,13 @@
     The output of each validator is passed as input to the next.
 
     :param min_valid: Minimum number of valid schemas.
-    :param validators: a list of schemas or validators to match input against
+    :param validators: List of schemas or validators to match input against.
     :param max_valid: Maximum number of valid schemas.
     :param msg: Message to deliver to user if validation fails.
-    :param kwargs: All other keyword arguments are passed to the sub-Schema constructors.
+    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.
 
-    :raises NotEnoughValid: if the minimum number of validations isn't met
-    :raises TooManyValid: if the more validations than the given amount is met
+    :raises NotEnoughValid: If the minimum number of validations isn't met.
+    :raises TooManyValid: If the maximum number of validations is exceeded.
 
     >>> validate = Schema(SomeOf(min_valid=2, validators=[Range(1, 5), Any(float, int), 6.6]))
     >>> validate(6.6)
