From 0a26de5e33ababd1fb0cac6772c67b005ed8cde7 Mon Sep 17 00:00:00 2001
From: Ben Boeckel <mathstuf@gmail.com>
Date: Fri, 26 Apr 2019 20:22:40 -0400
Subject: [PATCH 21/29] codespell: fix spelling errors

(cherry picked from commit 5238e9575906297608ff802a27e2ff9effa3b338)
---
 NEWS                                             | 12 ++++++------
 README                                           |  2 +-
 TODO                                             | 10 +++++-----
 catalog/systemd.catalog.in                       |  2 +-
 docs/TEMPORARY_DIRECTORIES.md                    |  2 +-
 hwdb/70-pointingstick.hwdb                       |  2 +-
 man/resolvectl.xml                               |  2 +-
 man/sd_bus_close.xml                             |  2 +-
 man/sd_bus_message_new_method_error.xml          |  2 +-
 man/sd_bus_message_rewind.xml                    |  4 ++--
 man/sd_bus_message_verify_type.xml               |  2 +-
 man/systemd-analyze.xml                          |  2 +-
 man/systemd-boot.xml                             |  2 +-
 man/systemd-gpt-auto-generator.xml               |  2 +-
 man/systemd-networkd-wait-online.service.xml     |  2 +-
 man/systemd-resolved.service.xml                 |  2 +-
 man/systemd.exec.xml                             |  4 ++--
 man/systemd.mount.xml                            |  2 +-
 man/systemd.netdev.xml                           |  4 ++--
 man/systemd.network.xml                          |  6 +++---
 man/systemd.nspawn.xml                           |  2 +-
 man/systemd.swap.xml                             |  2 +-
 man/systemd.timer.xml                            |  2 +-
 man/systemd.unit.xml                             |  6 +++---
 man/user-system-options.xml                      |  2 +-
 meson.build                                      |  2 +-
 src/basic/audit-util.c                           |  2 +-
 src/basic/blockdev-util.c                        |  2 +-
 src/basic/cgroup-util.c                          |  4 ++--
 src/basic/conf-files.c                           |  2 +-
 src/basic/fd-util.c                              |  2 +-
 src/basic/locale-util.c                          |  2 +-
 src/basic/raw-clone.h                            |  2 +-
 src/basic/terminal-util.c                        |  2 +-
 src/basic/user-util.c                            |  2 +-
 src/basic/virt.c                                 |  2 +-
 src/boot/efi/console.c                           |  2 +-
 src/boot/efi/shim.c                              |  2 +-
 src/cgtop/cgtop.c                                |  2 +-
 src/core/cgroup.c                                |  4 ++--
 src/core/cgroup.h                                |  2 +-
 src/core/dbus-unit.c                             |  2 +-
 src/core/dbus.c                                  |  2 +-
 src/core/device.c                                |  6 +++---
 src/core/execute.c                               |  4 ++--
 src/core/job.h                                   |  2 +-
 src/core/main.c                                  |  4 ++--
 src/core/manager.c                               | 16 ++++++++--------
 src/core/socket.c                                |  4 ++--
 src/core/unit.c                                  |  4 ++--
 src/core/unit.h                                  |  4 ++--
 src/coredump/coredump.c                          |  2 +-
 src/coredump/coredumpctl.c                       |  4 ++--
 src/import/curl-util.c                           |  2 +-
 src/import/pull-common.c                         |  2 +-
 src/journal-remote/microhttpd-util.h             |  2 +-
 src/journal/cat.c                                |  2 +-
 src/journal/journalctl.c                         |  4 ++--
 src/journal/journald-audit.c                     |  2 +-
 src/journal/journald-context.c                   |  2 +-
 src/journal/lookup3.c                            |  2 +-
 src/libsystemd-network/test-ndisc-ra.c           |  4 ++--
 src/libsystemd/sd-bus/GVARIANT-SERIALIZATION     |  2 +-
 src/libsystemd/sd-bus/bus-control.c              |  2 +-
 src/libsystemd/sd-bus/bus-internal.c             |  2 +-
 src/libsystemd/sd-bus/bus-message.c              |  2 +-
 src/libsystemd/sd-bus/sd-bus.c                   |  8 ++++----
 src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c |  2 +-
 src/libsystemd/sd-event/sd-event.c               |  2 +-
 src/libudev/libudev-monitor.c                    |  2 +-
 src/login/logind-dbus.c                          |  2 +-
 src/login/logind-session-device.c                |  2 +-
 src/login/logind-user.c                          |  2 +-
 src/login/pam_systemd.c                          |  2 +-
 src/network/netdev/bridge.c                      |  2 +-
 src/network/networkd-dhcp4.c                     |  2 +-
 src/network/networkd-link.c                      |  2 +-
 src/network/networkd-network.c                   |  4 ++--
 src/network/networkd-util.c                      |  4 ++--
 src/network/networkd-util.h                      |  2 +-
 src/notify/notify.c                              |  2 +-
 src/nspawn/nspawn-cgroup.c                       |  2 +-
 src/nspawn/nspawn-oci.c                          |  1 +
 src/nspawn/nspawn-patch-uid.c                    |  2 +-
 src/nspawn/nspawn.c                              |  6 +++---
 src/nss-resolve/nss-resolve.c                    |  2 +-
 src/portable/portable.c                          |  2 +-
 src/resolve/resolvconf-compat.c                  |  2 +-
 src/resolve/resolved-dns-dnssec.c                |  4 ++--
 src/resolve/resolved-dns-packet.c                |  2 +-
 src/resolve/resolved-dns-question.c              |  2 +-
 src/resolve/resolved-dns-scope.c                 |  2 +-
 src/resolve/resolved-dns-server.c                |  4 ++--
 src/resolve/resolved-dns-stream.c                |  2 +-
 src/resolve/resolved-dns-transaction.c           |  8 ++++----
 src/resolve/resolved-dns-trust-anchor.c          |  4 ++--
 src/resolve/resolved-dns-zone.c                  |  2 +-
 src/resolve/resolved-dnstls-gnutls.c             |  2 +-
 src/shared/bootspec.c                            |  4 ++--
 src/shared/dissect-image.c                       |  2 +-
 src/shared/dissect-image.h                       |  2 +-
 src/shared/exec-util.c                           |  2 +-
 src/shared/format-table.c                        |  2 +-
 src/shared/fstab-util.c                          |  2 +-
 src/shared/install.c                             |  4 ++--
 src/shared/journal-util.c                        |  2 +-
 src/shared/json.h                                |  4 ++--
 src/shared/main-func.h                           |  2 +-
 src/shared/mount-util.c                          |  2 +-
 src/shared/nscd-flush.c                          |  4 ++--
 src/shared/os-util.c                             |  2 +-
 src/shutdown/shutdown.c                          |  2 +-
 src/shutdown/umount.c                            |  6 +++---
 src/systemctl/systemctl.c                        | 16 ++++++++--------
 src/systemd/sd-bus-vtable.h                      | 10 +++++-----
 src/test/test-bpf.c                              |  2 +-
 src/test/test-fileio.c                           |  2 +-
 src/test/test-install-root.c                     |  2 +-
 src/test/test-pretty-print.c                     |  2 +-
 src/test/test-sleep.c                            |  4 ++--
 src/test/test-systemd-tmpfiles.py                |  4 ++--
 src/time-wait-sync/time-wait-sync.c              |  2 +-
 src/timesync/timesyncd.c                         |  2 +-
 src/udev/cdrom_id/cdrom_id.c                     |  2 +-
 src/udev/net/naming-scheme.h                     |  2 +-
 src/vconsole/vconsole-setup.c                    |  2 +-
 test/TEST-20-MAINPIDGAMES/testsuite.sh           |  4 ++--
 test/TEST-21-SYSUSERS/unhappy-2.input            |  2 +-
 test/TEST-22-TMPFILES/test-03.sh                 |  2 +-
 test/mkosi.default.networkd-test                 |  2 +-
 test/sysv-generator-test.py                      |  2 +-
 test/test-network/systemd-networkd-tests.py      |  2 +-
 test/udev-test.pl                                |  2 +-
 travis-ci/Dockerfile                             |  2 +-
 134 files changed, 202 insertions(+), 201 deletions(-)

diff --git a/NEWS b/NEWS
index 2cf96c2a82..77bcb46390 100644
--- a/NEWS
+++ b/NEWS
@@ -732,7 +732,7 @@ CHANGES WITH 240:
         * Journal messages that are generated whenever a unit enters the failed
           state are now tagged with a unique MESSAGE_ID. Similarly, messages
           generated whenever a service process exits are now made recognizable,
-          too. A taged message is also emitted whenever a unit enters the
+          too. A tagged message is also emitted whenever a unit enters the
           "dead" state on success.
 
         * systemd-run gained a new switch --working-directory= for configuring
@@ -974,7 +974,7 @@ CHANGES WITH 239:
           not created by systemd-sysusers anymore.
 
           NOTE: This has a chance of breaking nss-ldap and similar NSS modules
-          that embedd a network facing module into any process using getpwuid()
+          that embed a network facing module into any process using getpwuid()
           or related call: the dynamic allocation of the user ID for
           systemd-resolved.service means the service manager has to check NSS
           if the user name is already taken when forking off the service. Since
@@ -1243,7 +1243,7 @@ CHANGES WITH 239:
           PrivateDevices=, ProtectSystem=, â€¦) are used. This option is hence
           primarily useful for services that do not use any of the other file
           system namespacing options. One such service is systemd-udevd.service
-          wher this is now used by default.
+          where this is now used by default.
 
         * ConditionSecurity= gained a new value "uefi-secureboot" that is true
           when the system is booted in UEFI "secure mode".
@@ -2226,7 +2226,7 @@ CHANGES WITH 234:
           /etc/machine-id. If the machine ID could not be determined,
           $KERNEL_INSTALL_MACHINE_ID will be empty. Plugins should not put
           anything in the entry directory (passed as the second argument) if
-          $KERNEL_INSTALL_MACHINE_ID is empty. For backwards compatiblity, a
+          $KERNEL_INSTALL_MACHINE_ID is empty. For backwards compatibility, a
           temporary directory is passed as the entry directory and removed
           after all the plugins exit.
 
@@ -5954,7 +5954,7 @@ CHANGES WITH 214:
         * We temporarily dropped the "-l" switch for fsck invocations,
           since they collide with the flock() logic above. util-linux
           upstream has been changed already to avoid this conflict,
-          and we will readd "-l" as soon as util-linux with this
+          and we will re-add "-l" as soon as util-linux with this
           change has been released.
 
         * The dependency on libattr has been removed. Since a long
@@ -6240,7 +6240,7 @@ CHANGES WITH 213:
           where the local administrator's configuration in /etc always
           overrides any other settings.
 
-        Contributions fron: Ali H. Caliskan, Alison Chaiken, Bas van
+        Contributions from: Ali H. Caliskan, Alison Chaiken, Bas van
         den Berg, Brandon Philips, Cristian RodrÃ­guez, Daniel Buch,
         Dan Kilman, Dave Reisner, David HÃ¤rdeman, David Herrmann,
         David Strauss, Dimitris Spingos, Djalal Harouni, Eelco
diff --git a/README b/README
index c6523193fa..fcf20ed9f8 100644
--- a/README
+++ b/README
@@ -182,7 +182,7 @@ REQUIREMENTS:
         To build in directory build/:
           meson build/ && ninja -C build
 
-        Any configuration options can be specfied as -Darg=value... arguments
+        Any configuration options can be specified as -Darg=value... arguments
         to meson. After the build directory is initially configured, meson will
         refuse to run again, and options must be changed with:
           mesonconf -Darg=value...
diff --git a/TODO b/TODO
index 663e4fedd8..69d4dc957f 100644
--- a/TODO
+++ b/TODO
@@ -167,7 +167,7 @@ Features:
   selected user is resolvable in the service even if it ships its own /etc/passwd)
 
 * Fix DECIMAL_STR_MAX or DECIMAL_STR_WIDTH. One includes a trailing NUL, the
-  other doesn't. What a desaster. Probably to exclude it. Also
+  other doesn't. What a disaster. Probably to exclude it. Also
   DECIMAL_STR_WIDTH should probably add an extra "-" into account for negative
   numbers.
 
@@ -196,7 +196,7 @@ Features:
   specific paths only like this.
 
 * add CopyFile= or so as unit file setting that may be used to copy files or
-  directory trees from the host to te services RootImage= and RootDirectory=
+  directory trees from the host to the services RootImage= and RootDirectory=
   environment. Which we can use for /etc/machine-id and in particular
   /etc/resolv.conf. Should be smart and do something useful on read-only
   images, for example fallback to read-only bind mounting the file instead.
@@ -456,7 +456,7 @@ Features:
 * PID 1 should send out sd_notify("WATCHDOG=1") messages (for usage in the --user mode, and when run via nspawn)
 
 * there's probably something wrong with having user mounts below /sys,
-  as we have for debugfs. for exmaple, src/core/mount.c handles mounts
+  as we have for debugfs. for example, src/core/mount.c handles mounts
   prefixed with /sys generally special.
   http://lists.freedesktop.org/archives/systemd-devel/2015-June/032962.html
 
@@ -518,7 +518,7 @@ Features:
 
 * systemctl: if some operation fails, show log output?
 
-* systemctl edit: use equvalent of cat() to insert existing config as a comment, prepended with #.
+* systemctl edit: use equivalent of cat() to insert existing config as a comment, prepended with #.
   Upon editor exit, lines with one # are removed, lines with two # are left with one #, etc.
 
 * exponential backoff in timesyncd when we cannot reach a server
@@ -732,7 +732,7 @@ Features:
   - sd-journal: speed up sd_journal_get_data() with transparent hash table in bg
   - journald: when dropping msgs due to ratelimit make sure to write
     "dropped %u messages" not only when we are about to print the next
-    message that works, but alraedy after a short tiemout
+    message that works, but already after a short timeout
   - check if we can make journalctl by default use --follow mode inside of less if called without args?
   - maybe add API to send pairs of iovecs via sd_journal_send
   - journal: add a setgid "systemd-journal" utility to invoke from libsystemd-journal, which passes fds via STDOUT and does PK access
diff --git a/catalog/systemd.catalog.in b/catalog/systemd.catalog.in
index 5c6799ee5d..acf2b10897 100644
--- a/catalog/systemd.catalog.in
+++ b/catalog/systemd.catalog.in
@@ -384,7 +384,7 @@ The following "tags" are possible:
 - "split-usr" â€” /usr is a separate file system and was not mounted when systemd
   was booted
 - "cgroups-missing" â€” the kernel was compiled without cgroup support or access
-  to expected interface files is resticted
+  to expected interface files is restricted
 - "var-run-bad" â€” /var/run is not a symlink to /run
 - "overflowuid-not-65534" â€” the kernel user ID used for "unknown" users (with
   NFS or user namespaces) is not 65534
diff --git a/docs/TEMPORARY_DIRECTORIES.md b/docs/TEMPORARY_DIRECTORIES.md
index 0ea88f8fc6..9271e0e478 100644
--- a/docs/TEMPORARY_DIRECTORIES.md
+++ b/docs/TEMPORARY_DIRECTORIES.md
@@ -154,7 +154,7 @@ strategies to avoid these issues:
    in these directories when they are no longer needed, in particular when the
    program dies unexpectedly. Note: this strategy is only really suitable for
    packages that operate in a "system wide singleton" fashion with "long"
-   persistance of its data or state, i.e. as opposed to programs that run in
+   persistence of its data or state, i.e. as opposed to programs that run in
    multiple parallel or short-living instances. This is because a private
    directory under `/run` (and the other mentioned directories) is itself
    system and package specific singleton with greater longevity.
diff --git a/hwdb/70-pointingstick.hwdb b/hwdb/70-pointingstick.hwdb
index 553465a87e..92d079f22f 100644
--- a/hwdb/70-pointingstick.hwdb
+++ b/hwdb/70-pointingstick.hwdb
@@ -60,7 +60,7 @@
 # Trackpoint const accel settings are specified as
 #    POINTINGSTICK_CONST_ACCEL=<accel>
 #
-# Where <accel> is a floating point number, using a '.' seperator, specifying
+# Where <accel> is a floating point number, using a '.' separator, specifying
 # by how much to multiply deltas generated by the pointingstick to get
 # normalized deltas.
 #
diff --git a/man/resolvectl.xml b/man/resolvectl.xml
index f986e98ba3..d4c04a1e32 100644
--- a/man/resolvectl.xml
+++ b/man/resolvectl.xml
@@ -255,7 +255,7 @@
           through external means. The <option>dns</option> command expects IPv4 or IPv6 address specifications of DNS
           servers to use. The <option>domain</option> command expects valid DNS domains, possibly prefixed with
           <literal>~</literal>, and configures a per-interface search or route-only domain. The
-          <option>default-route</option> command expects a boolean paremeter, and configures whether the link may be
+          <option>default-route</option> command expects a boolean parameter, and configures whether the link may be
           used as default route for DNS lookups, i.e. if it is suitable for lookups on domains no other link explicitly
           is configured for. The <option>llmnr</option>, <option>mdns</option>, <option>dnssec</option> and
           <option>dnsovertls</option> commands may be used to configure the per-interface LLMNR, MulticastDNS, DNSSEC
diff --git a/man/sd_bus_close.xml b/man/sd_bus_close.xml
index b09f488874..d81c593878 100644
--- a/man/sd_bus_close.xml
+++ b/man/sd_bus_close.xml
@@ -44,7 +44,7 @@
 
     <para><function>sd_bus_close()</function> disconnects the specified bus connection. When this call is invoked and
     the specified bus object refers to an active connection it is immediately terminated. No further messages may be
-    sent or receieved on it. Any messages queued in the bus object (both incoming and outgoing) are released. If
+    sent or received on it. Any messages queued in the bus object (both incoming and outgoing) are released. If
     invoked on <constant>NULL</constant> bus object or when the bus connection is already closed this function executes
     no operation. This call does not free or unreference the bus object itself. Use
     <citerefentry><refentrytitle>sd_bus_unref</refentrytitle><manvolnum>3</manvolnum></citerefentry> for that.</para>
diff --git a/man/sd_bus_message_new_method_error.xml b/man/sd_bus_message_new_method_error.xml
index 27cec8ed01..0c471c534f 100644
--- a/man/sd_bus_message_new_method_error.xml
+++ b/man/sd_bus_message_new_method_error.xml
@@ -116,7 +116,7 @@
     project='man-pages'><refentrytitle>printf</refentrytitle><manvolnum>3</manvolnum></citerefentry>
     format string <parameter>format</parameter> and corresponding arguments.
     <literal>%m</literal> may be used in the format string to refer to the error
-    string corresponding to the specified errno code. The error message is initalized
+    string corresponding to the specified errno code. The error message is initialized
     using the error identifier generated from <constant>error</constant> and the
     formatted string. (If <parameter>error</parameter> is zero, no error is actually
     set, and an error reply with no information is created.)</para>
diff --git a/man/sd_bus_message_rewind.xml b/man/sd_bus_message_rewind.xml
index aa8aea987b..cbfa2511d2 100644
--- a/man/sd_bus_message_rewind.xml
+++ b/man/sd_bus_message_rewind.xml
@@ -19,7 +19,7 @@
   <refnamediv>
     <refname>sd_bus_message_rewind</refname>
 
-    <refpurpose>Return to begining of message or current container</refpurpose>
+    <refpurpose>Return to beginning of message or current container</refpurpose>
   </refnamediv>
 
   <refsynopsisdiv>
@@ -38,7 +38,7 @@
     <title>Description</title>
 
     <para><function>sd_bus_message_rewind()</function> moves the "read pointer" in the message
-    <parameter>m</parameter> to either the begining of the message (if
+    <parameter>m</parameter> to either the beginning of the message (if
     <parameter>complete</parameter> is true) or to the beginning of the currently open container. If
     no container is open, <parameter>complete</parameter> has no effect.</para>
   </refsect1>
diff --git a/man/sd_bus_message_verify_type.xml b/man/sd_bus_message_verify_type.xml
index c3230e5833..e03a253885 100644
--- a/man/sd_bus_message_verify_type.xml
+++ b/man/sd_bus_message_verify_type.xml
@@ -70,7 +70,7 @@
           <listitem><para><parameter>m</parameter> or both <parameter>type</parameter> and
           <parameter>contents</parameter> are <constant>NULL</constant>.</para>
 
-          <para>Arguments do not satisfy other contraints listed above.</para>
+          <para>Arguments do not satisfy other constraints listed above.</para>
           </listitem>
         </varlistentry>
 
diff --git a/man/systemd-analyze.xml b/man/systemd-analyze.xml
index f559b858f9..abc05e9303 100644
--- a/man/systemd-analyze.xml
+++ b/man/systemd-analyze.xml
@@ -337,7 +337,7 @@ $ eog targets.svg</programlisting>
       </example>
 
       <para>Note that this verb prints the list that is compiled into <command>systemd-analyze</command>
-      itself, and does not comunicate with the running manager. Use
+      itself, and does not communicate with the running manager. Use
       <programlisting>systemctl [--user] [--global] show -p UnitPath --value</programlisting>
       to retrieve the actual list that the manager uses, with any empty directories omitted.</para>
     </refsect2>
diff --git a/man/systemd-boot.xml b/man/systemd-boot.xml
index 3b1319687f..2575ab3fe5 100644
--- a/man/systemd-boot.xml
+++ b/man/systemd-boot.xml
@@ -357,7 +357,7 @@
 
     <para><command>systemd-boot</command> implements a simple boot counting mechanism on top of the <ulink
     url="https://systemd.io/BOOT_LOADER_SPECIFICATION">Boot Loader Specification</ulink>, for automatic and unattended
-    fallback to older kernel versions/boot loader entries when a specific entry continously fails. Any boot loader
+    fallback to older kernel versions/boot loader entries when a specific entry continuously fails. Any boot loader
     entry file and unified kernel image file that contains a <literal>+</literal> followed by one or two numbers (if
     two they need to be separated by a <literal>-</literal>), before the <filename>.conf</filename> or
     <filename>.efi</filename> suffix is subject to boot counting: the first of the two numbers ('tries left') is
diff --git a/man/systemd-gpt-auto-generator.xml b/man/systemd-gpt-auto-generator.xml
index 0d6d4e307e..d94d6ac715 100644
--- a/man/systemd-gpt-auto-generator.xml
+++ b/man/systemd-gpt-auto-generator.xml
@@ -234,7 +234,7 @@
         <term><varname>root=</varname></term>
 
         <listitem><para>When used with the special value <literal>gpt-auto</literal>, automatic discovery of
-        the root parition based on the GPT partition type is enabled.  Any other value disables this
+        the root partition based on the GPT partition type is enabled.  Any other value disables this
         generator.</para></listitem>
       </varlistentry>
 
diff --git a/man/systemd-networkd-wait-online.service.xml b/man/systemd-networkd-wait-online.service.xml
index 7c82f68fb3..51b865dc0b 100644
--- a/man/systemd-networkd-wait-online.service.xml
+++ b/man/systemd-networkd-wait-online.service.xml
@@ -55,7 +55,7 @@
         one is necessary to access some network resources. When used, all other interfaces are ignored.
         This option may be used more than once to wait for multiple network interfaces. When this
         option is specified multiple times, then <command>systemd-networkd-wait-online</command> waits
-        for all specified interfaces to be online. Optinally, required minimum operational state can be
+        for all specified interfaces to be online. Optionally, required minimum operational state can be
         specified after a colon <literal>:</literal>. Please see
         <citerefentry><refentrytitle>networkctl</refentrytitle><manvolnum>1</manvolnum></citerefentry>
         for possible operational states. If the operational state is not specified here, then
diff --git a/man/systemd-resolved.service.xml b/man/systemd-resolved.service.xml
index 807c3238b8..53c46a1018 100644
--- a/man/systemd-resolved.service.xml
+++ b/man/systemd-resolved.service.xml
@@ -163,7 +163,7 @@
       <listitem><para>Otherwise the query is failed as no suitable DNS servers could be determined.</para></listitem>
     </itemizedlist>
 
-    <para>The "DNS default route" option is a boolean setting configureable with <command>resolvectl</command> or in
+    <para>The "DNS default route" option is a boolean setting configurable with <command>resolvectl</command> or in
     <filename>.network</filename> files. If not set, it is implicitly determined based on the configured DNS domains
     for a link: if there's any route-only domain (not matching <literal>~.</literal>) it defaults to false, otherwise
     to true.</para>
diff --git a/man/systemd.exec.xml b/man/systemd.exec.xml
index ae4bef5cc0..e6df20deb9 100644
--- a/man/systemd.exec.xml
+++ b/man/systemd.exec.xml
@@ -1298,7 +1298,7 @@ BindReadOnlyPaths=/var/lib/systemd</programlisting>
         running in user mode, or in system mode, but without the <constant>CAP_SYS_ADMIN</constant> capability
         (e.g. setting <varname>User=nobody</varname>), <varname>NoNewPrivileges=yes</varname> is implied. By default,
         no restrictions apply, all address families are accessible to processes. If assigned the empty string, any
-        previous address familiy restriction changes are undone. This setting does not affect commands prefixed with
+        previous address family restriction changes are undone. This setting does not affect commands prefixed with
         <literal>+</literal>.</para>
 
         <para>Use this option to limit exposure of processes to remote access, in particular via exotic and sensitive
@@ -1922,7 +1922,7 @@ SystemCallErrorNumber=EPERM</programlisting>
         <para>Note that services which specify <option>DefaultDependencies=no</option> and use
         <varname>StandardInput=</varname> or <varname>StandardOutput=</varname> with
         <option>tty</option>/<option>tty-force</option>/<option>tty-fail</option>, should specify
-        <option>After=systemd-vconsole-setup.service</option>, to make sure that the tty intialization is
+        <option>After=systemd-vconsole-setup.service</option>, to make sure that the tty initialization is
         finished before they start.</para></listitem>
       </varlistentry>
 
diff --git a/man/systemd.mount.xml b/man/systemd.mount.xml
index d0ccd39e38..022e227e83 100644
--- a/man/systemd.mount.xml
+++ b/man/systemd.mount.xml
@@ -312,7 +312,7 @@
         <listitem><para>The file system will be initialized
         on the device. If the device is not "empty", i.e. it contains any signature,
         the operation will be skipped. It is hence expected that this option
-        remains set even after the device has been initalized.</para>
+        remains set even after the device has been initialized.</para>
 
         <para>Note that this option can only be used in
         <filename>/etc/fstab</filename>, and will be ignored when part of the
diff --git a/man/systemd.netdev.xml b/man/systemd.netdev.xml
index 1836b5fe00..997785ec9f 100644
--- a/man/systemd.netdev.xml
+++ b/man/systemd.netdev.xml
@@ -826,13 +826,13 @@
       <varlistentry>
         <term><varname>Name=</varname></term>
         <listitem>
-          <para>Specifies the name of the sesssion. This option is compulsory.</para>
+          <para>Specifies the name of the session. This option is compulsory.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>SessionId=</varname></term>
         <listitem>
-          <para>Specifies the sesssion id. The value used must match the <literal>SessionId=</literal> value being used at the peer.
+          <para>Specifies the session id. The value used must match the <literal>SessionId=</literal> value being used at the peer.
           Ranges a number between 1 and 4294967295). This option is compulsory.</para>
         </listitem>
       </varlistentry>
diff --git a/man/systemd.network.xml b/man/systemd.network.xml
index bdac3a8150..8d68b0bf1a 100644
--- a/man/systemd.network.xml
+++ b/man/systemd.network.xml
@@ -637,7 +637,7 @@
           <para>Note that if this option is enabled a userspace implementation of the IPv6 RA protocol is
           used, and the kernel's own implementation remains disabled, since `networkd` needs to know all
           details supplied in the advertisements, and these are not available from the kernel if the kernel's
-          own implemenation is used.</para>
+          own implementation is used.</para>
         </listitem>
         </varlistentry>
         <varlistentry>
@@ -1069,7 +1069,7 @@
         <varlistentry>
           <term><varname>InvertRule=</varname></term>
           <listitem>
-            <para>A boolean. Specifies wheather the rule to be inverted. Defaults to false.</para>
+            <para>A boolean. Specifies whether the rule to be inverted. Defaults to false.</para>
           </listitem>
         </varlistentry>
       </variablelist>
@@ -1189,7 +1189,7 @@
         <varlistentry>
           <term><varname>InitialAdvertisedReceiveWindow=</varname></term>
           <listitem>
-            <para>The TCP initial advertised receive window is the amount of receive data (in bytes) that can initally be buffered at one time
+            <para>The TCP initial advertised receive window is the amount of receive data (in bytes) that can initially be buffered at one time
             on a connection. The sending host can send only that amount of data before waiting for an acknowledgment and window update
             from the receiving host. Takes a size in bytes between 1 and 4294967295 (2^32 - 1). The usual suffixes K, M, G are supported
             and are understood to the base of 1024. When unset, the kernel's default will be used.
diff --git a/man/systemd.nspawn.xml b/man/systemd.nspawn.xml
index 1485a26f02..70c6ff33a6 100644
--- a/man/systemd.nspawn.xml
+++ b/man/systemd.nspawn.xml
@@ -429,7 +429,7 @@
         <term><varname>Inaccessible=</varname></term>
 
         <listitem><para>Masks the specified file or directly in the container, by over-mounting it with an empty file
-        node of the same type with the most restrictive access mode. Takes a file system path as arugment. This option
+        node of the same type with the most restrictive access mode. Takes a file system path as argument. This option
         may be used multiple times to mask multiple files or directories. This option is equivalent to the command line
         switch <option>--inaccessible=</option>, see
         <citerefentry><refentrytitle>systemd-nspawn</refentrytitle><manvolnum>1</manvolnum></citerefentry> for details
diff --git a/man/systemd.swap.xml b/man/systemd.swap.xml
index 66d63503db..d2a9123b0b 100644
--- a/man/systemd.swap.xml
+++ b/man/systemd.swap.xml
@@ -148,7 +148,7 @@
 
         <listitem><para>The swap structure will be initialized on the device. If the device is not
         "empty", i.e. it contains any signature, the operation will be skipped. It is hence expected
-        that this option remains set even after the device has been initalized.</para>
+        that this option remains set even after the device has been initialized.</para>
 
         <para>Note that this option can only be used in <filename>/etc/fstab</filename>, and will be
         ignored when part of the <varname>Options=</varname> setting in a unit file.</para>
diff --git a/man/systemd.timer.xml b/man/systemd.timer.xml
index 6a13e52ccf..13b9ed35d2 100644
--- a/man/systemd.timer.xml
+++ b/man/systemd.timer.xml
@@ -314,7 +314,7 @@
         <term><varname>RemainAfterElapse=</varname></term>
 
         <listitem><para>Takes a boolean argument. If true, an elapsed
-        timer will stay loaded, and its state remains queriable. If
+        timer will stay loaded, and its state remains queryable. If
         false, an elapsed timer unit that cannot elapse anymore is
         unloaded. Turning this off is particularly useful for
         transient timer units that shall disappear after they first
diff --git a/man/systemd.unit.xml b/man/systemd.unit.xml
index 81a02253ed..fdeaef3db4 100644
--- a/man/systemd.unit.xml
+++ b/man/systemd.unit.xml
@@ -512,7 +512,7 @@
         <replaceable>description</replaceable>.</literal>, <literal>Reached target
         <replaceable>description</replaceable>.</literal>, <literal>Failed to start
         <replaceable>description</replaceable>.</literal>), so it should be capitalized, and should
-        not be a full sentence or a phrase with a continous verb. Bad examples include
+        not be a full sentence or a phrase with a continuous verb. Bad examples include
         <literal>exiting the container</literal> or <literal>updating the database once per
         day.</literal>.</para>
         </listitem>
@@ -886,7 +886,7 @@
         of powering down the system with similar semantics. <option>exit</option> causes the manager to exit following
         the normal shutdown procedure, and <option>exit-force</option> causes it terminate without shutting down
         services. When <option>exit</option> or <option>exit-force</option> is used by default the exit status of the
-        main process of the unit (if this applies) is returned from the service manager. However, this may be overriden
+        main process of the unit (if this applies) is returned from the service manager. However, this may be overridden
         with <varname>FailureActionExitStatus=</varname>/<varname>SuccessActionExitStatus=</varname>, see
         below.</para></listitem>
       </varlistentry>
@@ -1273,7 +1273,7 @@
         <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>=</literal>, <literal>!=</literal>,
         <literal>&gt;=</literal>, <literal>&gt;</literal>. Compares the number of CPUs in the CPU affinity mask
         configured of the service manager itself with the specified number, adhering to the specified
-        comparision operator. On physical systems the number of CPUs in the affinity mask of the service
+        comparison operator. On physical systems the number of CPUs in the affinity mask of the service
         manager usually matches the number of physical CPUs, but in special and virtual environments might
         differ. In particular, in containers the affinity mask usually matches the number of CPUs assigned to
         the container and not the physically available ones.</para>
diff --git a/man/user-system-options.xml b/man/user-system-options.xml
index 195c2e4163..8034735658 100644
--- a/man/user-system-options.xml
+++ b/man/user-system-options.xml
@@ -30,7 +30,7 @@
       <para>Execute the operation remotely. Specify a hostname, or a
       username and hostname separated by <literal>@</literal>, to
       connect to. The hostname may optionally be suffixed by a
-      port ssh is listening on, seperated by <literal>:</literal>, and then a
+      port ssh is listening on, separated by <literal>:</literal>, and then a
       container name, separated by <literal>/</literal>, which
       connects directly to a specific container on the specified
       host. This will use SSH to talk to the remote machine manager
diff --git a/meson.build b/meson.build
index 79195c9748..4377fe8419 100644
--- a/meson.build
+++ b/meson.build
@@ -1327,7 +1327,7 @@ if want_remote != 'false'
                      conf.get('HAVE_LIBCURL') == 1]
         # sd-j-remote requires Âµhttpd, and sd-j-upload requires libcurl, so
         # it's possible to build one without the other. Complain only if
-        # support was explictly requested. The auxiliary files like sysusers
+        # support was explicitly requested. The auxiliary files like sysusers
         # config should be installed when any of the programs are built.
         if want_remote == 'true' and not (have_deps[0] and have_deps[1])
                 error('remote support was requested, but dependencies are not available')
diff --git a/src/basic/audit-util.c b/src/basic/audit-util.c
index 5cbaef3eba..6eb224b2c8 100644
--- a/src/basic/audit-util.c
+++ b/src/basic/audit-util.c
@@ -23,7 +23,7 @@ int audit_session_from_pid(pid_t pid, uint32_t *id) {
         assert(id);
 
         /* We don't convert ENOENT to ESRCH here, since we can't
-         * really distuingish between "audit is not available in the
+         * really distinguish between "audit is not available in the
          * kernel" and "the process does not exist", both which will
          * result in ENOENT. */
 
diff --git a/src/basic/blockdev-util.c b/src/basic/blockdev-util.c
index 3017ecd55d..0d7ea83b75 100644
--- a/src/basic/blockdev-util.c
+++ b/src/basic/blockdev-util.c
@@ -59,7 +59,7 @@ int get_block_device(const char *path, dev_t *dev) {
         assert(path);
         assert(dev);
 
-        /* Get's the block device directly backing a file system. If
+        /* Gets the block device directly backing a file system. If
          * the block device is encrypted, returns the device mapper
          * block device. */
 
diff --git a/src/basic/cgroup-util.c b/src/basic/cgroup-util.c
index fc28109db8..dea9d677fe 100644
--- a/src/basic/cgroup-util.c
+++ b/src/basic/cgroup-util.c
@@ -1972,7 +1972,7 @@ int cg_slice_to_path(const char *unit, char **ret) {
 
 #if HAS_FEATURE_MEMORY_SANITIZER
                 /* msan doesn't instrument stpncpy, so it thinks
-                 * n is later used unitialized:
+                 * n is later used uninitialized:
                  * https://github.com/google/sanitizers/issues/926
                  */
                 zero(n);
@@ -2621,7 +2621,7 @@ int cg_enable_everywhere(
         if (r < 0)
                 return r;
         if (r == 0) {
-                /* On the legacy hiearchy there's no concept of "enabling" controllers in cgroups defined. Let's claim
+                /* On the legacy hierarchy there's no concept of "enabling" controllers in cgroups defined. Let's claim
                  * complete success right away. (If you wonder why we return the full mask here, rather than zero: the
                  * caller tends to use the returned mask later on to compare if all controllers where properly joined,
                  * and if not requeues realization. This use is the primary purpose of the return value, hence let's
diff --git a/src/basic/conf-files.c b/src/basic/conf-files.c
index d010fbb266..7c85022f08 100644
--- a/src/basic/conf-files.c
+++ b/src/basic/conf-files.c
@@ -99,7 +99,7 @@ static int files_add(
 
                 /* Does this node have the executable bit set? */
                 if (flags & CONF_FILES_EXECUTABLE)
-                        /* As requested: check if the file is marked exectuable. Note that we don't check access(X_OK)
+                        /* As requested: check if the file is marked executable. Note that we don't check access(X_OK)
                          * here, as we care about whether the file is marked executable at all, and not whether it is
                          * executable for us, because if so, such errors are stuff we should log about. */
 
diff --git a/src/basic/fd-util.c b/src/basic/fd-util.c
index b3b840145f..e571f6616e 100644
--- a/src/basic/fd-util.c
+++ b/src/basic/fd-util.c
@@ -387,7 +387,7 @@ int fd_get_path(int fd, char **ret) {
         r = readlink_malloc(procfs_path, ret);
         if (r == -ENOENT) {
                 /* ENOENT can mean two things: that the fd does not exist or that /proc is not mounted. Let's make
-                 * things debuggable and distuingish the two. */
+                 * things debuggable and distinguish the two. */
 
                 if (access("/proc/self/fd/", F_OK) < 0)
                         /* /proc is not available or not set up properly, we're most likely in some chroot
diff --git a/src/basic/locale-util.c b/src/basic/locale-util.c
index 6f41f50641..ce9daffa7b 100644
--- a/src/basic/locale-util.c
+++ b/src/basic/locale-util.c
@@ -235,7 +235,7 @@ bool is_locale_utf8(void) {
                 goto out;
         }
 
-        /* For LC_CTYPE=="C" return true, because CTYPE is effectly
+        /* For LC_CTYPE=="C" return true, because CTYPE is effectively
          * unset and everything can do to UTF-8 nowadays. */
         set = setlocale(LC_CTYPE, NULL);
         if (!set) {
diff --git a/src/basic/raw-clone.h b/src/basic/raw-clone.h
index b8857b0cdf..b12dea2aef 100644
--- a/src/basic/raw-clone.h
+++ b/src/basic/raw-clone.h
@@ -17,7 +17,7 @@
  * @flags: Flags to pass to the clone system call
  *
  * Uses the clone system call to create a new process with the cloning flags and termination signal passed in the flags
- * parameter. Opposed to glibc's clone funtion, using this function does not set up a separate stack for the child, but
+ * parameter. Opposed to glibc's clone function, using this function does not set up a separate stack for the child, but
  * relies on copy-on-write semantics on the one stack at a common virtual address, just as fork does.
  *
  * To obtain copy-on-write semantics, flags must not contain CLONE_VM, and thus CLONE_THREAD and CLONE_SIGHAND (which
diff --git a/src/basic/terminal-util.c b/src/basic/terminal-util.c
index b692c52e59..a2ea321243 100644
--- a/src/basic/terminal-util.c
+++ b/src/basic/terminal-util.c
@@ -1182,7 +1182,7 @@ bool colors_enabled(void) {
          * (which is the explicit way to turn colors on/off). If that didn't work we turn colors off unless we are on a
          * TTY. And if we are on a TTY we turn it off if $TERM is set to "dumb". There's one special tweak though: if
          * we are PID 1 then we do not check whether we are connected to a TTY, because we don't keep /dev/console open
-         * continously due to fear of SAK, and hence things are a bit weird. */
+         * continuously due to fear of SAK, and hence things are a bit weird. */
 
         if (cached_colors_enabled < 0) {
                 int val;
diff --git a/src/basic/user-util.c b/src/basic/user-util.c
index a479590e47..2090675b0d 100644
--- a/src/basic/user-util.c
+++ b/src/basic/user-util.c
@@ -55,7 +55,7 @@ int parse_uid(const char *s, uid_t *ret) {
 
         if (!uid_is_valid(uid))
                 return -ENXIO; /* we return ENXIO instead of EINVAL
-                                * here, to make it easy to distuingish
+                                * here, to make it easy to distinguish
                                 * invalid numeric uids from invalid
                                 * strings. */
 
diff --git a/src/basic/virt.c b/src/basic/virt.c
index 5dd1bd6633..284d9b4d44 100644
--- a/src/basic/virt.c
+++ b/src/basic/virt.c
@@ -234,7 +234,7 @@ static int detect_vm_xen_dom0(void) {
                 if (streq(cap, "control_d"))
                         break;
         if (!cap) {
-                log_debug("Virtualization XEN DomU found (/proc/xen/capabilites)");
+                log_debug("Virtualization XEN DomU found (/proc/xen/capabilities)");
                 return 0;
         }
 
diff --git a/src/boot/efi/console.c b/src/boot/efi/console.c
index 4d72bada62..7f6bad1538 100644
--- a/src/boot/efi/console.c
+++ b/src/boot/efi/console.c
@@ -114,7 +114,7 @@ EFI_STATUS console_key_read(UINT64 *key, BOOLEAN wait) {
         /* fallback for firmware which does not support SimpleTextInputExProtocol
          *
          * This is also called in case ReadKeyStrokeEx did not return a key, because
-         * some broken firmwares offer SimpleTextInputExProtocol, but never acually
+         * some broken firmwares offer SimpleTextInputExProtocol, but never actually
          * handle any key. */
         err  = uefi_call_wrapper(ST->ConIn->ReadKeyStroke, 2, ST->ConIn, &k);
         if (EFI_ERROR(err))
diff --git a/src/boot/efi/shim.c b/src/boot/efi/shim.c
index f6ffed143c..9ec54796ec 100644
--- a/src/boot/efi/shim.c
+++ b/src/boot/efi/shim.c
@@ -158,7 +158,7 @@ static EFIAPI EFI_STATUS security_policy_authentication (const EFI_SECURITY_PROT
         if (status != EFI_SUCCESS)
                 return status;
 
-        /* No need to check return value, this already happend in efi_main() */
+        /* No need to check return value, this already happened in efi_main() */
         root = LibOpenRoot(h);
         dev_path_str = DevicePathToStr(dev_path);
 
diff --git a/src/cgtop/cgtop.c b/src/cgtop/cgtop.c
index f27c80120d..bde58f47a8 100644
--- a/src/cgtop/cgtop.c
+++ b/src/cgtop/cgtop.c
@@ -111,7 +111,7 @@ static bool is_root_cgroup(const char *path) {
          *
          * There's one extra complication in all of this, though ðŸ˜£: if the path to the cgroup indicates we are in the
          * root cgroup this might actually not be the case, because cgroup namespacing might be in effect
-         * (CLONE_NEWCGROUP). Since there's no nice way to distuingish a real cgroup root from a fake namespaced one we
+         * (CLONE_NEWCGROUP). Since there's no nice way to distinguish a real cgroup root from a fake namespaced one we
          * do an explicit container check here, under the assumption that CLONE_NEWCGROUP is generally used when
          * container managers are used too.
          *
diff --git a/src/core/cgroup.c b/src/core/cgroup.c
index ad67ba0438..cb6ebcf9eb 100644
--- a/src/core/cgroup.c
+++ b/src/core/cgroup.c
@@ -1095,7 +1095,7 @@ static void cgroup_context_apply(
                         }
                 }
 
-                /* The bandwith limits are something that make sense to be applied to the host's root but not container
+                /* The bandwidth limits are something that make sense to be applied to the host's root but not container
                  * roots, as there we want the container manager to handle it */
                 if (is_host_root || !is_local_root) {
                         if (has_io) {
@@ -1259,7 +1259,7 @@ static void cgroup_context_apply(
                          * it also counts. But if the user never set a limit through us (i.e. we are the default of
                          * "unbounded") we leave things unmodified. For this we manage a global boolean that we turn on
                          * the first time we set a limit. Note that this boolean is flushed out on manager reload,
-                         * which is desirable so that there's an offical way to release control of the sysctl from
+                         * which is desirable so that there's an official way to release control of the sysctl from
                          * systemd: set the limit to unbounded and reload. */
 
                         if (c->tasks_max != CGROUP_LIMIT_MAX) {
diff --git a/src/core/cgroup.h b/src/core/cgroup.h
index 51e7c96d60..0179e2d588 100644
--- a/src/core/cgroup.h
+++ b/src/core/cgroup.h
@@ -25,7 +25,7 @@ typedef enum CGroupDevicePolicy {
         /* Everything forbidden, except built-in ones and listed ones. */
         CGROUP_CLOSED,
 
-        /* Everythings forbidden, except for the listed devices */
+        /* Everything forbidden, except for the listed devices */
         CGROUP_STRICT,
 
         _CGROUP_DEVICE_POLICY_MAX,
diff --git a/src/core/dbus-unit.c b/src/core/dbus-unit.c
index 6f1a74d6b5..69295e2cca 100644
--- a/src/core/dbus-unit.c
+++ b/src/core/dbus-unit.c
@@ -1867,7 +1867,7 @@ static int bus_unit_set_transient_property(
                  * transient units, but still). And "References" and "ReferencedBy" is already used as unit reference
                  * dependency type, hence let's not confuse things with that.
                  *
-                 * Note that we don't acually add the reference to the bus track. We do that only after the setup of
+                 * Note that we don't actually add the reference to the bus track. We do that only after the setup of
                  * the transient unit is complete, so that setting this property multiple times in the same transient
                  * unit creation call doesn't count as individual references. */
 
diff --git a/src/core/dbus.c b/src/core/dbus.c
index 8ae5d173f0..a8ce9ac447 100644
--- a/src/core/dbus.c
+++ b/src/core/dbus.c
@@ -1257,7 +1257,7 @@ uint64_t manager_bus_n_queued_write(Manager *m) {
         sd_bus *b;
         int r;
 
-        /* Returns the total number of messages queued for writing on all our direct and API busses. */
+        /* Returns the total number of messages queued for writing on all our direct and API buses. */
 
         SET_FOREACH(b, m->private_buses, i) {
                 uint64_t k;
diff --git a/src/core/device.c b/src/core/device.c
index 9f7caa49ec..f478393f1a 100644
--- a/src/core/device.c
+++ b/src/core/device.c
@@ -420,7 +420,7 @@ static int device_add_udev_wants(Unit *u, sd_device *dev) {
                 /* So here's a special hack, to compensate for the fact that the udev database's reload cycles are not
                  * synchronized with our own reload cycles: when we detect that the SYSTEMD_WANTS property of a device
                  * changes while the device unit is already up, let's manually trigger any new units listed in it not
-                 * seen before. This typically appens during the boot-time switch root transition, as udev devices
+                 * seen before. This typically happens during the boot-time switch root transition, as udev devices
                  * will generally already be up in the initrd, but SYSTEMD_WANTS properties get then added through udev
                  * rules only available on the host system, and thus only when the initial udev coldplug trigger runs.
                  *
@@ -525,7 +525,7 @@ static int device_setup_unit(Manager *m, sd_device *dev, const char *path, bool
 
                 delete = false;
 
-                /* Let's remove all dependencies generated due to udev properties. We'll readd whatever is configured
+                /* Let's remove all dependencies generated due to udev properties. We'll re-add whatever is configured
                  * now below. */
                 unit_remove_dependencies(u, UNIT_DEPENDENCY_UDEV);
         } else {
@@ -921,7 +921,7 @@ static int device_dispatch_io(sd_device_monitor *monitor, sd_device *dev, void *
 
         /* A change event can signal that a device is becoming ready, in particular if
          * the device is using the SYSTEMD_READY logic in udev
-         * so we need to reach the else block of the follwing if, even for change events */
+         * so we need to reach the else block of the following if, even for change events */
         if (action == DEVICE_ACTION_REMOVE) {
                 r = swap_process_device_remove(m, dev);
                 if (r < 0)
diff --git a/src/core/execute.c b/src/core/execute.c
index 5e1a74d0bc..a8b6c92873 100644
--- a/src/core/execute.c
+++ b/src/core/execute.c
@@ -2202,7 +2202,7 @@ static int setup_exec_directory(
                 }
 
                 /* Lock down the access mode (we use chmod_and_chown() to make this idempotent. We don't
-                 * specifiy UID/GID here, so that path_chown_recursive() can optimize things depending on the
+                 * specify UID/GID here, so that path_chown_recursive() can optimize things depending on the
                  * current UID/GID ownership.) */
                 r = chmod_and_chown(pp ?: p, context->directories[type].mode, UID_INVALID, GID_INVALID);
                 if (r < 0)
@@ -2487,7 +2487,7 @@ static int apply_mount_namespace(
         bind_mount_free_many(bind_mounts, n_bind_mounts);
 
         /* If we couldn't set up the namespace this is probably due to a missing capability. setup_namespace() reports
-         * that with a special, recognizable error ENOANO. In this case, silently proceeed, but only if exclusively
+         * that with a special, recognizable error ENOANO. In this case, silently proceed, but only if exclusively
          * sandboxing options were used, i.e. nothing such as RootDirectory= or BindMount= that would result in a
          * completely different execution environment. */
         if (r == -ENOANO) {
diff --git a/src/core/job.h b/src/core/job.h
index 1b9bcdd895..0f15cbf821 100644
--- a/src/core/job.h
+++ b/src/core/job.h
@@ -72,7 +72,7 @@ enum JobMode {
         JOB_REPLACE,             /* Replace an existing conflicting job */
         JOB_REPLACE_IRREVERSIBLY,/* Like JOB_REPLACE + produce irreversible jobs */
         JOB_ISOLATE,             /* Start a unit, and stop all others */
-        JOB_FLUSH,               /* Flush out all other queued jobs when queing this one */
+        JOB_FLUSH,               /* Flush out all other queued jobs when queueing this one */
         JOB_IGNORE_DEPENDENCIES, /* Ignore both requirement and ordering dependencies */
         JOB_IGNORE_REQUIREMENTS, /* Ignore requirement dependencies */
         _JOB_MODE_MAX,
diff --git a/src/core/main.c b/src/core/main.c
index 46db47126c..984382e7ac 100644
--- a/src/core/main.c
+++ b/src/core/main.c
@@ -1781,7 +1781,7 @@ static void do_reexecute(
         args[i++] = NULL;
         assert(i <= args_size);
 
-        /* Reenable any blocked signals, especially important if we switch from initial ramdisk to init=... */
+        /* Re-enable any blocked signals, especially important if we switch from initial ramdisk to init=... */
         (void) reset_all_signal_handlers();
         (void) reset_signal_mask();
         (void) rlimit_nofile_safe();
@@ -2020,7 +2020,7 @@ static int initialize_runtime(
                 return 0;
 
         if (arg_system) {
-                /* Make sure we leave a core dump without panicing the kernel. */
+                /* Make sure we leave a core dump without panicking the kernel. */
                 install_crash_handler();
 
                 if (!skip_setup) {
diff --git a/src/core/manager.c b/src/core/manager.c
index 12ae911a38..f1d6487cb8 100644
--- a/src/core/manager.c
+++ b/src/core/manager.c
@@ -90,7 +90,7 @@
 #define JOBS_IN_PROGRESS_PERIOD_USEC (USEC_PER_SEC / 3)
 #define JOBS_IN_PROGRESS_PERIOD_DIVISOR 3
 
-/* If there are more than 1K bus messages queue across our API and direct busses, then let's not add more on top until
+/* If there are more than 1K bus messages queue across our API and direct buses, then let's not add more on top until
  * the queue gets more empty. */
 #define MANAGER_BUS_BUSY_THRESHOLD 1024LU
 
@@ -1051,7 +1051,7 @@ static int manager_setup_user_lookup_fd(Manager *m) {
                  * resolutions */
                 r = sd_event_source_set_priority(m->user_lookup_event_source, SD_EVENT_PRIORITY_NORMAL-11);
                 if (r < 0)
-                        return log_error_errno(errno, "Failed to set priority ot user lookup event source: %m");
+                        return log_error_errno(errno, "Failed to set priority of user lookup event source: %m");
 
                 (void) sd_event_source_set_description(m->user_lookup_event_source, "user-lookup");
         }
@@ -1659,7 +1659,7 @@ int manager_startup(Manager *m, FILE *serialization, FDSet *fds) {
 
         r = lookup_paths_reduce(&m->lookup_paths);
         if (r < 0)
-                log_warning_errno(r, "Failed ot reduce unit file paths, ignoring: %m");
+                log_warning_errno(r, "Failed to reduce unit file paths, ignoring: %m");
 
         manager_build_unit_path_cache(m);
 
@@ -1709,7 +1709,7 @@ int manager_startup(Manager *m, FILE *serialization, FDSet *fds) {
                 /* Connect to the bus if we are good for it */
                 manager_setup_bus(m);
 
-                /* Now that we are connected to all possible busses, let's deserialize who is tracking us. */
+                /* Now that we are connected to all possible buses, let's deserialize who is tracking us. */
                 r = bus_track_coldplug(m, &m->subscribed, false, m->deserialized_subscribed);
                 if (r < 0)
                         log_warning_errno(r, "Failed to deserialized tracked clients, ignoring: %m");
@@ -2197,8 +2197,8 @@ static unsigned manager_dispatch_dbus_queue(Manager *m) {
                  * overly full before this call we shouldn't increase it in size too wildly in one step, and we
                  * shouldn't monopolize CPU time with generating these messages. Note the difference in counting of
                  * this "budget" and the "threshold" above: the "budget" is decreased only once per generated message,
-                 * regardless how many busses/direct connections it is enqueued on, while the "threshold" is applied to
-                 * each queued instance of bus message, i.e. if the same message is enqueued to five busses/direct
+                 * regardless how many buses/direct connections it is enqueued on, while the "threshold" is applied to
+                 * each queued instance of bus message, i.e. if the same message is enqueued to five buses/direct
                  * connections it will be counted five times. This difference in counting ("references"
                  * vs. "instances") is primarily a result of the fact that it's easier to implement it this way,
                  * however it also reflects the thinking that the "threshold" should put a limit on used queue memory,
@@ -2513,7 +2513,7 @@ static int manager_dispatch_sigchld(sd_event_source *source, void *userdata) {
                 if (array) {
                         size_t n = 0;
 
-                        /* Cound how many entries the array has */
+                        /* Count how many entries the array has */
                         while (array[n])
                                 n++;
 
@@ -3550,7 +3550,7 @@ int manager_reload(Manager *m) {
 
         r = lookup_paths_reduce(&m->lookup_paths);
         if (r < 0)
-                log_warning_errno(r, "Failed ot reduce unit file paths, ignoring: %m");
+                log_warning_errno(r, "Failed to reduce unit file paths, ignoring: %m");
 
         manager_build_unit_path_cache(m);
 
diff --git a/src/core/socket.c b/src/core/socket.c
index 836e513d49..b6a4290c3f 100644
--- a/src/core/socket.c
+++ b/src/core/socket.c
@@ -1868,7 +1868,7 @@ static int socket_coldplug(Unit *u) {
                    SOCKET_RUNNING)) {
 
                 /* Originally, we used to simply reopen all sockets here that we didn't have file descriptors
-                 * for. However, this is problematic, as we won't traverse throught the SOCKET_START_CHOWN state for
+                 * for. However, this is problematic, as we won't traverse through the SOCKET_START_CHOWN state for
                  * them, and thus the UID/GID wouldn't be right. Hence, instead simply check if we have all fds open,
                  * and if there's a mismatch, warn loudly. */
 
@@ -2873,7 +2873,7 @@ static int socket_accept_in_cgroup(Socket *s, SocketPort *p, int fd) {
         assert(p);
         assert(fd >= 0);
 
-        /* Similar to socket_address_listen_in_cgroup(), but for accept() rathern than socket(): make sure that any
+        /* Similar to socket_address_listen_in_cgroup(), but for accept() rather than socket(): make sure that any
          * connection socket is also properly associated with the cgroup. */
 
         if (!IN_SET(p->address.sockaddr.sa.sa_family, AF_INET, AF_INET6))
diff --git a/src/core/unit.c b/src/core/unit.c
index 2cde494a7e..6b4212f5e1 100644
--- a/src/core/unit.c
+++ b/src/core/unit.c
@@ -804,7 +804,7 @@ static void merge_dependencies(Unit *u, Unit *other, const char *other_id, UnitD
         assert(other);
         assert(d < _UNIT_DEPENDENCY_MAX);
 
-        /* Fix backwards pointers. Let's iterate through all dependendent units of the other unit. */
+        /* Fix backwards pointers. Let's iterate through all dependent units of the other unit. */
         HASHMAP_FOREACH_KEY(v, back, other->dependencies[d], i) {
                 UnitDependency k;
 
@@ -5020,7 +5020,7 @@ int unit_set_exec_params(Unit *u, ExecParameters *p) {
         p->prefix = u->manager->prefix;
         SET_FLAG(p->flags, EXEC_PASS_LOG_UNIT|EXEC_CHOWN_DIRECTORIES, MANAGER_IS_SYSTEM(u->manager));
 
-        /* Copy paramaters from unit */
+        /* Copy parameters from unit */
         p->cgroup_path = u->cgroup_path;
         SET_FLAG(p->flags, EXEC_CGROUP_DELEGATE, unit_cgroup_delegate(u));
 
diff --git a/src/core/unit.h b/src/core/unit.h
index 28878b5f4f..c2aa1e01bd 100644
--- a/src/core/unit.h
+++ b/src/core/unit.h
@@ -51,7 +51,7 @@ static inline bool UNIT_IS_INACTIVE_OR_FAILED(UnitActiveState t) {
  * use this so that we can selectively flush out parts of dependencies again. Note that the same dependency might be
  * created as a result of multiple "reasons", hence the bitmask. */
 typedef enum UnitDependencyMask {
-        /* Configured directly by the unit file, .wants/.requries symlink or drop-in, or as an immediate result of a
+        /* Configured directly by the unit file, .wants/.requires symlink or drop-in, or as an immediate result of a
          * non-dependency option configured that way.  */
         UNIT_DEPENDENCY_FILE               = 1 << 0,
 
@@ -250,7 +250,7 @@ typedef struct Unit {
         char *cgroup_path;
         CGroupMask cgroup_realized_mask;           /* In which hierarchies does this unit's cgroup exist? (only relevant on cgroup v1) */
         CGroupMask cgroup_enabled_mask;            /* Which controllers are enabled (or more correctly: enabled for the children) for this unit's cgroup? (only relevant on cgroup v2) */
-        CGroupMask cgroup_invalidated_mask;        /* A mask specifiying controllers which shall be considered invalidated, and require re-realization */
+        CGroupMask cgroup_invalidated_mask;        /* A mask specifying controllers which shall be considered invalidated, and require re-realization */
         CGroupMask cgroup_members_mask;            /* A cache for the controllers required by all children of this cgroup (only relevant for slice units) */
         int cgroup_inotify_wd;
 
diff --git a/src/coredump/coredump.c b/src/coredump/coredump.c
index 023701646b..716732001f 100644
--- a/src/coredump/coredump.c
+++ b/src/coredump/coredump.c
@@ -768,7 +768,7 @@ static int submit_coredump(
                 return log_error_errno(r, "Failed to drop privileges: %m");
 
 #if HAVE_ELFUTILS
-        /* Try to get a strack trace if we can */
+        /* Try to get a stack trace if we can */
         if (coredump_size <= arg_process_size_max) {
                 _cleanup_free_ char *stacktrace = NULL;
 
diff --git a/src/coredump/coredumpctl.c b/src/coredump/coredumpctl.c
index b239d81945..70507d284b 100644
--- a/src/coredump/coredumpctl.c
+++ b/src/coredump/coredumpctl.c
@@ -321,7 +321,7 @@ static int print_field(FILE* file, sd_journal *j) {
         assert(arg_field);
 
         /* A (user-specified) field may appear more than once for a given entry.
-         * We will print all of the occurences.
+         * We will print all of the occurrences.
          * This is different below for fields that systemd-coredump uses,
          * because they cannot meaningfully appear more than once.
          */
@@ -790,7 +790,7 @@ static int save_core(sd_journal *j, FILE *file, char **path, bool *unlink_temp)
                 /* If neither path or file are specified, we will write to stdout. Let's now check
                  * if stdout is connected to a tty. We checked that the file exists, or that the
                  * core might be stored in the journal. In this second case, if we found the entry,
-                 * in all likelyhood we will be able to access the COREDUMP= field.  In either case,
+                 * in all likelihood we will be able to access the COREDUMP= field.  In either case,
                  * we stop before doing any "real" work, i.e. before starting decompression or
                  * reading from the file or creating temporary files.
                  */
diff --git a/src/import/curl-util.c b/src/import/curl-util.c
index cd6822f8db..83671cf99b 100644
--- a/src/import/curl-util.c
+++ b/src/import/curl-util.c
@@ -367,7 +367,7 @@ int curl_header_strdup(const void *contents, size_t sz, const char *field, char
         if (memchr(p, 0, sz))
                 return 0;
 
-        /* Skip over preceeding whitespace */
+        /* Skip over preceding whitespace */
         while (sz > 0 && strchr(WHITESPACE, p[0])) {
                 p++;
                 sz--;
diff --git a/src/import/pull-common.c b/src/import/pull-common.c
index acfe380969..766b97cb0c 100644
--- a/src/import/pull-common.c
+++ b/src/import/pull-common.c
@@ -436,7 +436,7 @@ int pull_verify(PullJob *main_job,
         }
 
         if (!mkdtemp(gpg_home)) {
-                r = log_error_errno(errno, "Failed to create tempory home for gpg: %m");
+                r = log_error_errno(errno, "Failed to create temporary home for gpg: %m");
                 goto finish;
         }
 
diff --git a/src/journal-remote/microhttpd-util.h b/src/journal-remote/microhttpd-util.h
index ba51d847e4..d90c6bbd4f 100644
--- a/src/journal-remote/microhttpd-util.h
+++ b/src/journal-remote/microhttpd-util.h
@@ -33,7 +33,7 @@
 
 /* Both the old and new names are defines, check for the new one. */
 
-/* Compatiblity with libmicrohttpd < 0.9.38 */
+/* Compatibility with libmicrohttpd < 0.9.38 */
 #ifndef MHD_HTTP_NOT_ACCEPTABLE
 #  define MHD_HTTP_NOT_ACCEPTABLE MHD_HTTP_METHOD_NOT_ACCEPTABLE
 #endif
diff --git a/src/journal/cat.c b/src/journal/cat.c
index 9900bd2e86..d8d72690d7 100644
--- a/src/journal/cat.c
+++ b/src/journal/cat.c
@@ -146,7 +146,7 @@ static int run(int argc, char *argv[]) {
 
         saved_stderr = fcntl(STDERR_FILENO, F_DUPFD_CLOEXEC, 3);
 
-        r = rearrange_stdio(STDIN_FILENO, outfd, errfd < 0 ? outfd : errfd); /* Invalidates fd on succcess + error! */
+        r = rearrange_stdio(STDIN_FILENO, outfd, errfd < 0 ? outfd : errfd); /* Invalidates fd on success + error! */
         TAKE_FD(outfd);
         TAKE_FD(errfd);
         if (r < 0)
diff --git a/src/journal/journalctl.c b/src/journal/journalctl.c
index 00489098ee..62110495b3 100644
--- a/src/journal/journalctl.c
+++ b/src/journal/journalctl.c
@@ -1263,7 +1263,7 @@ static int get_boots(
                         goto finish;
                 }
 
-                /* At this point the read pointer is positioned at the oldest/newest occurence of the reference boot
+                /* At this point the read pointer is positioned at the oldest/newest occurrence of the reference boot
                  * ID. After flushing the matches, one more invocation of _previous()/_next() will hence place us at
                  * the following entry, which must then have an older/newer boot ID */
         } else {
@@ -2427,7 +2427,7 @@ int main(int argc, char *argv[]) {
         if (arg_follow) {
                 poll_fd = sd_journal_get_fd(j);
                 if (poll_fd == -EMFILE) {
-                        log_warning_errno(poll_fd, "Insufficent watch descriptors available. Reverting to -n.");
+                        log_warning_errno(poll_fd, "Insufficient watch descriptors available. Reverting to -n.");
                         arg_follow = false;
                 } else if (poll_fd == -EMEDIUMTYPE) {
                         log_error_errno(poll_fd, "The --follow switch is not supported in conjunction with reading from STDIN.");
diff --git a/src/journal/journald-audit.c b/src/journal/journald-audit.c
index accbad4180..71d9282ed5 100644
--- a/src/journal/journald-audit.c
+++ b/src/journal/journald-audit.c
@@ -445,7 +445,7 @@ void server_process_audit_message(
         if (IN_SET(nl->nlmsg_type, NLMSG_NOOP, NLMSG_ERROR))
                 return;
 
-        /* Except AUDIT_USER, all messsages below AUDIT_FIRST_USER_MSG are control messages, let's ignore those */
+        /* Except AUDIT_USER, all messages below AUDIT_FIRST_USER_MSG are control messages, let's ignore those */
         if (nl->nlmsg_type < AUDIT_FIRST_USER_MSG && nl->nlmsg_type != AUDIT_USER)
                 return;
 
diff --git a/src/journal/journald-context.c b/src/journal/journald-context.c
index 7c51f2f633..e6aeb03b77 100644
--- a/src/journal/journald-context.c
+++ b/src/journal/journald-context.c
@@ -48,7 +48,7 @@
  *    previously had trouble associating the log message with the service.
  *
  * NB: With and without the metadata cache: the implicitly added entry metadata in the journal (with the exception of
- *     UID/PID/GID and SELinux label) must be understood as possibly slightly out of sync (i.e. sometimes slighly older
+ *     UID/PID/GID and SELinux label) must be understood as possibly slightly out of sync (i.e. sometimes slightly older
  *     and sometimes slightly newer than what was current at the log event).
  */
 
diff --git a/src/journal/lookup3.c b/src/journal/lookup3.c
index 6c61f17c7d..102d2fee18 100644
--- a/src/journal/lookup3.c
+++ b/src/journal/lookup3.c
@@ -811,7 +811,7 @@ void driver2()
     {
       for (j=0; j<8; ++j)   /*------------------------ for each input bit, */
       {
-        for (m=1; m<8; ++m) /*------------ for serveral possible initvals, */
+        for (m=1; m<8; ++m) /*------------- for several possible initvals, */
         {
           for (l=0; l<HASHSTATE; ++l)
             e[l]=f[l]=g[l]=h[l]=x[l]=y[l]=~((uint32_t)0);
diff --git a/src/libsystemd-network/test-ndisc-ra.c b/src/libsystemd-network/test-ndisc-ra.c
index 7dc44e5674..7c6c4663f3 100644
--- a/src/libsystemd-network/test-ndisc-ra.c
+++ b/src/libsystemd-network/test-ndisc-ra.c
@@ -60,7 +60,7 @@ static struct {
         unsigned char prefixlen;
         uint32_t valid;
         uint32_t preferred;
-        bool succesful;
+        bool successful;
 } prefix[] = {
         { { { { 0x20, 0x01, 0x0d, 0xb8, 0xde, 0xad, 0xbe, 0xef,
                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } }, 64,
@@ -329,7 +329,7 @@ static void test_ra(void) {
                 if (prefix[i].preferred)
                         assert_se(sd_radv_prefix_set_preferred_lifetime(p, prefix[i].preferred) >= 0);
 
-                assert_se((sd_radv_add_prefix(ra, p, false) >= 0) == prefix[i].succesful);
+                assert_se((sd_radv_add_prefix(ra, p, false) >= 0) == prefix[i].successful);
                 assert_se(sd_radv_add_prefix(ra, p, false) < 0);
 
                 p = sd_radv_prefix_unref(p);
diff --git a/src/libsystemd/sd-bus/GVARIANT-SERIALIZATION b/src/libsystemd/sd-bus/GVARIANT-SERIALIZATION
index 3110d57913..973a063761 100644
--- a/src/libsystemd/sd-bus/GVARIANT-SERIALIZATION
+++ b/src/libsystemd/sd-bus/GVARIANT-SERIALIZATION
@@ -55,7 +55,7 @@ Regarding the framing of dbus2, also see:
 https://wiki.gnome.org/Projects/GLib/GDBus/Version2
 
 The first four bytes of the header are defined the same way for dbus1
-and dbus2. The first bytes contain the endianess field and the
+and dbus2. The first bytes contain the endianness field and the
 protocol version, so that the remainder of the message can be safely
 made sense of just by looking at the first 32bit.
 
diff --git a/src/libsystemd/sd-bus/bus-control.c b/src/libsystemd/sd-bus/bus-control.c
index 5f2502076e..f817cf0a85 100644
--- a/src/libsystemd/sd-bus/bus-control.c
+++ b/src/libsystemd/sd-bus/bus-control.c
@@ -532,7 +532,7 @@ _public_ int sd_bus_get_name_creds(
                                 if (!sd_bus_error_has_name(&error, SD_BUS_ERROR_UNKNOWN_METHOD))
                                         return r;
 
-                                /* If we got an unknown method error, fall back to the invidual calls... */
+                                /* If we got an unknown method error, fall back to the individual calls... */
                                 need_separate_calls = true;
                                 sd_bus_error_free(&error);
 
diff --git a/src/libsystemd/sd-bus/bus-internal.c b/src/libsystemd/sd-bus/bus-internal.c
index dff39cb13f..d5f8c6db64 100644
--- a/src/libsystemd/sd-bus/bus-internal.c
+++ b/src/libsystemd/sd-bus/bus-internal.c
@@ -180,7 +180,7 @@ bool member_name_is_valid(const char *p) {
  * Complex pattern match
  * This checks whether @a is a 'complex-prefix' of @b, or @b is a
  * 'complex-prefix' of @a, based on strings that consist of labels with @c as
- * spearator. This function returns true if:
+ * separator. This function returns true if:
  *   - both strings are equal
  *   - either is a prefix of the other and ends with @c
  * The second rule makes sure that either string needs to be fully included in
diff --git a/src/libsystemd/sd-bus/bus-message.c b/src/libsystemd/sd-bus/bus-message.c
index 427d42f296..1759e13ca1 100644
--- a/src/libsystemd/sd-bus/bus-message.c
+++ b/src/libsystemd/sd-bus/bus-message.c
@@ -924,7 +924,7 @@ _public_ sd_bus_message* sd_bus_message_unref(sd_bus_message *m) {
 
         /* Unset the bus field if neither the user has a reference nor this message is queued. We are careful
          * to reset the field only after the last reference to the bus is dropped, after all we might keep
-         * multiple references to the bus, once for each reference kept on outselves. */
+         * multiple references to the bus, once for each reference kept on ourselves. */
         m->bus = NULL;
 
         return message_free(m);
diff --git a/src/libsystemd/sd-bus/sd-bus.c b/src/libsystemd/sd-bus/sd-bus.c
index 3df7c86b89..1c25ba9dea 100644
--- a/src/libsystemd/sd-bus/sd-bus.c
+++ b/src/libsystemd/sd-bus/sd-bus.c
@@ -465,9 +465,9 @@ static int synthesize_connected_signal(sd_bus *bus) {
 
         /* If enabled, synthesizes a local "Connected" signal mirroring the local "Disconnected" signal. This is called
          * whenever we fully established a connection, i.e. after the authorization phase, and after receiving the
-         * Hello() reply. Or in other words, whenver we enter BUS_RUNNING state.
+         * Hello() reply. Or in other words, whenever we enter BUS_RUNNING state.
          *
-         * This is useful so that clients can start doing stuff whenver the connection is fully established in a way
+         * This is useful so that clients can start doing stuff whenever the connection is fully established in a way
          * that works independently from whether we connected to a full bus or just a direct connection. */
 
         if (!bus->connected_signal)
@@ -1204,7 +1204,7 @@ _public_ int sd_bus_open_with_description(sd_bus **ret, const char *description)
         assert_return(ret, -EINVAL);
 
         /* Let's connect to the starter bus if it is set, and
-         * otherwise to the bus that is appropropriate for the scope
+         * otherwise to the bus that is appropriate for the scope
          * we are running in */
 
         e = secure_getenv("DBUS_STARTER_BUS_TYPE");
@@ -3869,7 +3869,7 @@ _public_ int sd_bus_path_decode_many(const char *path, const char *path_template
          *     For each matched label, the *decoded* label is stored in the
          *     passed output argument, and the caller is responsible to free
          *     it. Note that the output arguments are only modified if the
-         *     actualy path matched the template. Otherwise, they're left
+         *     actually path matched the template. Otherwise, they're left
          *     untouched.
          *
          * This function returns <0 on error, 0 if the path does not match the
diff --git a/src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c b/src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c
index f6506fb93f..17598f3d63 100644
--- a/src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c
+++ b/src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c
@@ -24,7 +24,7 @@ static int test_ref_unref(void) {
         m = sd_bus_message_unref(m);
         bus = sd_bus_unref(bus);
 
-        /* We should have a memory leak now on <= v240. Let's do this again, but destory in the opposite
+        /* We should have a memory leak now on <= v240. Let's do this again, but destroy in the opposite
          * order. On v240 that too should be a leak. */
 
         r = sd_bus_open_system(&bus);
diff --git a/src/libsystemd/sd-event/sd-event.c b/src/libsystemd/sd-event/sd-event.c
index 1987f279eb..50017a9517 100644
--- a/src/libsystemd/sd-event/sd-event.c
+++ b/src/libsystemd/sd-event/sd-event.c
@@ -3022,7 +3022,7 @@ static void event_close_inode_data_fds(sd_event *e) {
 
         /* Close the fds pointing to the inodes to watch now. We need to close them as they might otherwise pin
          * filesystems. But we can't close them right-away as we need them as long as the user still wants to make
-         * adjustments to the even source, such as changing the priority (which requires us to remove and readd a watch
+         * adjustments to the even source, such as changing the priority (which requires us to remove and re-add a watch
          * for the inode). Hence, let's close them when entering the first iteration after they were added, as a
          * compromise. */
 
diff --git a/src/libudev/libudev-monitor.c b/src/libudev/libudev-monitor.c
index 70036f5136..5f780e0be9 100644
--- a/src/libudev/libudev-monitor.c
+++ b/src/libudev/libudev-monitor.c
@@ -49,7 +49,7 @@ static MonitorNetlinkGroup monitor_netlink_group_from_string(const char *name) {
  * source. Valid sources identifiers are "udev" and "kernel".
  *
  * Applications should usually not connect directly to the
- * "kernel" events, because the devices might not be useable
+ * "kernel" events, because the devices might not be usable
  * at that time, before udev has configured them, and created
  * device nodes. Accessing devices at the same time as udev,
  * might result in unpredictable behavior. The "udev" events
diff --git a/src/login/logind-dbus.c b/src/login/logind-dbus.c
index 2cebcce123..be767186ff 100644
--- a/src/login/logind-dbus.c
+++ b/src/login/logind-dbus.c
@@ -830,7 +830,7 @@ static int method_create_session(sd_bus_message *message, void *userdata, sd_bus
                 } while (hashmap_get(m->sessions, id));
         }
 
-        /* If we are not watching utmp aleady, try again */
+        /* If we are not watching utmp already, try again */
         manager_reconnect_utmp(m);
 
         r = manager_add_user_by_uid(m, uid, &user);
diff --git a/src/login/logind-session-device.c b/src/login/logind-session-device.c
index 7c79a4afdc..3e2ff6d5b8 100644
--- a/src/login/logind-session-device.c
+++ b/src/login/logind-session-device.c
@@ -156,7 +156,7 @@ static int session_device_open(SessionDevice *sd, bool active) {
 
         case DEVICE_TYPE_UNKNOWN:
         default:
-                /* fallback for devices wihout synchronizations */
+                /* fallback for devices without synchronizations */
                 break;
         }
 
diff --git a/src/login/logind-user.c b/src/login/logind-user.c
index 045b6f0e17..a17efc19fb 100644
--- a/src/login/logind-user.c
+++ b/src/login/logind-user.c
@@ -371,7 +371,7 @@ int user_start(User *u) {
                 return 0;
 
         /* If u->stopping is set, the user is marked for removal and service stop-jobs are queued. We have to clear
-         * that flag before queing the start-jobs again. If they succeed, the user object can be re-used just fine
+         * that flag before queueing the start-jobs again. If they succeed, the user object can be re-used just fine
          * (pid1 takes care of job-ordering and proper restart), but if they fail, we want to force another user_stop()
          * so possibly pending units are stopped. */
         u->stopping = false;
diff --git a/src/login/pam_systemd.c b/src/login/pam_systemd.c
index 2bf3b7987e..a26895e695 100644
--- a/src/login/pam_systemd.c
+++ b/src/login/pam_systemd.c
@@ -327,7 +327,7 @@ static const char* getenv_harder(pam_handle_t *handle, const char *key, const ch
         assert(handle);
         assert(key);
 
-        /* Looks for an environment variable, preferrably in the environment block associated with the
+        /* Looks for an environment variable, preferably in the environment block associated with the
          * specified PAM handle, falling back to the process' block instead. Why check both? Because we want
          * to permit configuration of session properties from unit files that invoke PAM services, so that
          * PAM services don't have to be reworked to set systemd-specific properties, but these properties
diff --git a/src/network/netdev/bridge.c b/src/network/netdev/bridge.c
index aadb3ab905..cbbf11220b 100644
--- a/src/network/netdev/bridge.c
+++ b/src/network/netdev/bridge.c
@@ -8,7 +8,7 @@
 #include "networkd-manager.h"
 #include "vlan-util.h"
 
-/* callback for brige netdev's parameter set */
+/* callback for bridge netdev's parameter set */
 static int netdev_bridge_set_handler(sd_netlink *rtnl, sd_netlink_message *m, NetDev *netdev) {
         int r;
 
diff --git a/src/network/networkd-dhcp4.c b/src/network/networkd-dhcp4.c
index 85685d6df7..9ea49b09de 100644
--- a/src/network/networkd-dhcp4.c
+++ b/src/network/networkd-dhcp4.c
@@ -471,7 +471,7 @@ static int dhcp_lease_acquired(sd_dhcp_client *client, Link *link) {
                         if (r < 0)
                                 log_link_warning_errno(link, r, "Unable to shorten overlong DHCP hostname '%s', ignoring: %m", dhcpname);
                         if (r == 1)
-                                log_link_notice(link, "Overlong DCHP hostname received, shortened from '%s' to '%s'", dhcpname, hostname);
+                                log_link_notice(link, "Overlong DHCP hostname received, shortened from '%s' to '%s'", dhcpname, hostname);
                 }
 
                 if (hostname) {
diff --git a/src/network/networkd-link.c b/src/network/networkd-link.c
index 08f4284ebe..aecf65ec04 100644
--- a/src/network/networkd-link.c
+++ b/src/network/networkd-link.c
@@ -3840,7 +3840,7 @@ int link_update(Link *link, sd_netlink_message *m) {
         assert(m);
 
         if (link->state == LINK_STATE_LINGER) {
-                log_link_info(link, "Link readded");
+                log_link_info(link, "Link re-added");
                 link_set_state(link, LINK_STATE_CONFIGURING);
 
                 r = link_new_carrier_maps(link);
diff --git a/src/network/networkd-network.c b/src/network/networkd-network.c
index ec6fe6da7a..c2095d66f4 100644
--- a/src/network/networkd-network.c
+++ b/src/network/networkd-network.c
@@ -346,7 +346,7 @@ int network_load_one(Manager *manager, const char *filename) {
                 .dhcp_use_dns = true,
                 .dhcp_use_hostname = true,
                 .dhcp_use_routes = true,
-                /* NOTE: this var might be overwriten by network_apply_anonymize_if_set */
+                /* NOTE: this var might be overwritten by network_apply_anonymize_if_set */
                 .dhcp_send_hostname = true,
                 /* To enable/disable RFC7844 Anonymity Profiles */
                 .dhcp_anonymize = false,
@@ -862,7 +862,7 @@ int config_parse_dhcp(
         if (s < 0) {
 
                 /* Previously, we had a slightly different enum here,
-                 * support its values for compatbility. */
+                 * support its values for compatibility. */
 
                 if (streq(rvalue, "none"))
                         s = ADDRESS_FAMILY_NO;
diff --git a/src/network/networkd-util.c b/src/network/networkd-util.c
index a392aadd4c..a088d25981 100644
--- a/src/network/networkd-util.c
+++ b/src/network/networkd-util.c
@@ -62,7 +62,7 @@ int config_parse_address_family_boolean_with_kernel(
 
         /* This function is mostly obsolete now. It simply redirects
          * "kernel" to "no". In older networkd versions we used to
-         * distuingish IPForward=off from IPForward=kernel, where the
+         * distinguish IPForward=off from IPForward=kernel, where the
          * former would explicitly turn off forwarding while the
          * latter would simply not touch the setting. But that logic
          * is gone, hence silently accept the old setting, but turn it
@@ -84,7 +84,7 @@ int config_parse_address_family_boolean_with_kernel(
 }
 
 /* Router lifetime can be set with netlink interface since kernel >= 4.5
- * so for the supported kernel we dont need to expire routes in userspace */
+ * so for the supported kernel we don't need to expire routes in userspace */
 int kernel_route_expiration_supported(void) {
         static int cached = -1;
         int r;
diff --git a/src/network/networkd-util.h b/src/network/networkd-util.h
index a49e289351..9c472cfd50 100644
--- a/src/network/networkd-util.h
+++ b/src/network/networkd-util.h
@@ -35,7 +35,7 @@ DEFINE_TRIVIAL_CLEANUP_FUNC(NetworkConfigSection*, network_config_section_free);
 extern const struct hash_ops network_config_hash_ops;
 
 static inline bool section_is_invalid(NetworkConfigSection *section) {
-        /* If this retuns false, then it does _not_ mean the section is valid. */
+        /* If this returns false, then it does _not_ mean the section is valid. */
 
         if (!section)
                 return false;
diff --git a/src/notify/notify.c b/src/notify/notify.c
index fff5233b0c..f50a322ea5 100644
--- a/src/notify/notify.c
+++ b/src/notify/notify.c
@@ -192,7 +192,7 @@ static int run(int argc, char* argv[]) {
         if (!n)
                 return log_oom();
 
-        /* If this is requested change to the requested UID/GID. Note thta we only change the real UID here, and leave
+        /* If this is requested change to the requested UID/GID. Note that we only change the real UID here, and leave
            the effective UID in effect (which is 0 for this to work). That's because we want the privileges to fake the
            ucred data, and sd_pid_notify() uses the real UID for filling in ucred. */
 
diff --git a/src/nspawn/nspawn-cgroup.c b/src/nspawn/nspawn-cgroup.c
index 168125d311..ec62b64b00 100644
--- a/src/nspawn/nspawn-cgroup.c
+++ b/src/nspawn/nspawn-cgroup.c
@@ -161,7 +161,7 @@ int create_subcgroup(pid_t pid, bool keep_unit, CGroupUnified unified_requested)
          * attributes. Hence, let's insert an intermediary cgroup to cover that case too.
          *
          * Note that we only bother with the main hierarchy here, not with any secondary ones. On the unified setup
-         * that's fine because there's only one hiearchy anyway and controllers are enabled directly on it. On the
+         * that's fine because there's only one hierarchy anyway and controllers are enabled directly on it. On the
          * legacy setup, this is fine too, since delegation of controllers is generally not safe there, hence we won't
          * do it. */
 
diff --git a/src/nspawn/nspawn-oci.c b/src/nspawn/nspawn-oci.c
index db8e4d3b78..9f196635f9 100644
--- a/src/nspawn/nspawn-oci.c
+++ b/src/nspawn/nspawn-oci.c
@@ -58,6 +58,7 @@
  * /bin/mount regarding NFS and FUSE required?
  * what does terminal=false mean?
  * sysctl inside or outside? whitelisting?
+ * swapiness typo -> swappiness
  *
  * Unsupported:
  *
diff --git a/src/nspawn/nspawn-patch-uid.c b/src/nspawn/nspawn-patch-uid.c
index c2b779c1d1..4885744cfc 100644
--- a/src/nspawn/nspawn-patch-uid.c
+++ b/src/nspawn/nspawn-patch-uid.c
@@ -103,7 +103,7 @@ static int shift_acl(acl_t acl, uid_t shift, acl_t *ret) {
 
                 if (IN_SET(tag, ACL_USER, ACL_GROUP)) {
 
-                        /* We don't distuingish here between uid_t and gid_t, let's make sure the compiler checks that
+                        /* We don't distinguish here between uid_t and gid_t, let's make sure the compiler checks that
                          * this is actually OK */
                         assert_cc(sizeof(uid_t) == sizeof(gid_t));
 
diff --git a/src/nspawn/nspawn.c b/src/nspawn/nspawn.c
index 0f64aa68f3..27829431ac 100644
--- a/src/nspawn/nspawn.c
+++ b/src/nspawn/nspawn.c
@@ -1495,7 +1495,7 @@ static int verify_arguments(void) {
 
         /* We don't support --private-users-chown together with any of the volatile modes since we couldn't
          * change the read-only part of the tree (i.e. /usr) anyway, or because it would trigger a massive
-         * copy-up (in case of overlay) making the entire excercise pointless. */
+         * copy-up (in case of overlay) making the entire exercise pointless. */
         if (arg_userns_chown && arg_volatile_mode != VOLATILE_NO)
                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "--volatile= and --private-users-chown may not be combined.");
 
@@ -3293,7 +3293,7 @@ static int outer_child(
 
         /* Mark everything as shared so our mounts get propagated down. This is
          * required to make new bind mounts available in systemd services
-         * inside the containter that create a new mount namespace.
+         * inside the container that create a new mount namespace.
          * See https://github.com/systemd/systemd/issues/3860
          * Further submounts (such as /dev) done after this will inherit the
          * shared propagation mode. */
@@ -3715,7 +3715,7 @@ static int merge_settings(Settings *settings, const char *path) {
                 /* Copy the full capabilities over too */
                 if (capability_quintet_is_set(&settings->full_capabilities)) {
                         if (!arg_settings_trusted)
-                                log_warning("Ignoring capabilitiy settings, file %s is not trusted.", path);
+                                log_warning("Ignoring capability settings, file %s is not trusted.", path);
                         else
                                 arg_full_capabilities = settings->full_capabilities;
                 }
diff --git a/src/nss-resolve/nss-resolve.c b/src/nss-resolve/nss-resolve.c
index ac5fff523b..95f80572bd 100644
--- a/src/nss-resolve/nss-resolve.c
+++ b/src/nss-resolve/nss-resolve.c
@@ -169,7 +169,7 @@ enum nss_status _nss_resolve_gethostbyname4_r(
                 /* Return NSS_STATUS_UNAVAIL when communication with systemd-resolved fails,
                    allowing falling back to other nss modules. Treat all other error conditions as
                    NOTFOUND. This includes DNSSEC errors and suchlike. (We don't use UNAVAIL in this
-                   case so that the nsswitch.conf configuration can distuingish such executed but
+                   case so that the nsswitch.conf configuration can distinguish such executed but
                    negative replies from complete failure to talk to resolved). */
                 goto fail;
         }
diff --git a/src/portable/portable.c b/src/portable/portable.c
index 9b6cc21d2c..475c10e318 100644
--- a/src/portable/portable.c
+++ b/src/portable/portable.c
@@ -436,7 +436,7 @@ static int portable_extract_by_path(
                         if (r < 0)
                                 return log_debug_errno(r, "Failed to receive item: %m");
 
-                        /* We can't really distuingish a zero-length datagram without any fds from EOF (both are signalled the
+                        /* We can't really distinguish a zero-length datagram without any fds from EOF (both are signalled the
                          * same way by recvmsg()). Hence, accept either as end notification. */
                         if (isempty(name) && fd < 0)
                                 break;
diff --git a/src/resolve/resolvconf-compat.c b/src/resolve/resolvconf-compat.c
index 383d0b819b..d1f65056d0 100644
--- a/src/resolve/resolvconf-compat.c
+++ b/src/resolve/resolvconf-compat.c
@@ -172,7 +172,7 @@ int resolvconf_parse_argv(int argc, char *argv[]) {
                         log_debug("Switch -%c ignored.", c);
                         break;
 
-                /* Everybody else can agree on the existance of -u but we don't support it. */
+                /* Everybody else can agree on the existence of -u but we don't support it. */
                 case 'u':
 
                 /* The following options are openresolv inventions we don't support. */
diff --git a/src/resolve/resolved-dns-dnssec.c b/src/resolve/resolved-dns-dnssec.c
index a5ded5ada2..6e0979f87f 100644
--- a/src/resolve/resolved-dns-dnssec.c
+++ b/src/resolve/resolved-dns-dnssec.c
@@ -1109,7 +1109,7 @@ int dnssec_has_rrsig(DnsAnswer *a, const DnsResourceKey *key) {
         DnsResourceRecord *rr;
         int r;
 
-        /* Checks whether there's at least one RRSIG in 'a' that proctects RRs of the specified key */
+        /* Checks whether there's at least one RRSIG in 'a' that protects RRs of the specified key */
 
         DNS_ANSWER_FOREACH(rr, a) {
                 r = dnssec_key_match_rrsig(key, rr);
@@ -1988,7 +1988,7 @@ int dnssec_nsec_test(DnsAnswer *answer, DnsResourceKey *key, DnssecNsecResult *r
         if (have_nsec3)
                 return dnssec_test_nsec3(answer, key, result, authenticated, ttl);
 
-        /* No approproate NSEC RR found, report this. */
+        /* No appropriate NSEC RR found, report this. */
         *result = DNSSEC_NSEC_NO_RR;
         return 0;
 }
diff --git a/src/resolve/resolved-dns-packet.c b/src/resolve/resolved-dns-packet.c
index a4959cd7c0..20ee8c9ca3 100644
--- a/src/resolve/resolved-dns-packet.c
+++ b/src/resolve/resolved-dns-packet.c
@@ -1949,7 +1949,7 @@ int dns_packet_read_rr(DnsPacket *p, DnsResourceRecord **ret, bool *ret_cache_fl
         case DNS_TYPE_NSEC: {
 
                 /*
-                 * RFC6762, section 18.14 explictly states mDNS should use name compression.
+                 * RFC6762, section 18.14 explicitly states mDNS should use name compression.
                  * This contradicts RFC3845, section 2.1.1
                  */
 
diff --git a/src/resolve/resolved-dns-question.c b/src/resolve/resolved-dns-question.c
index 60cd34bcfc..62833efa0e 100644
--- a/src/resolve/resolved-dns-question.c
+++ b/src/resolve/resolved-dns-question.c
@@ -289,7 +289,7 @@ int dns_question_new_address(DnsQuestion **ret, int family, const char *name, bo
                 else
                         /* We did not manage to create convert the idna name, or it's
                          * the same as the original name. We assume the caller already
-                         * created an uncoverted question, so let's not repeat work
+                         * created an unconverted question, so let's not repeat work
                          * unnecessarily. */
                         return -EALREADY;
         }
diff --git a/src/resolve/resolved-dns-scope.c b/src/resolve/resolved-dns-scope.c
index 66dd2b1b5a..d0abf9c5ff 100644
--- a/src/resolve/resolved-dns-scope.c
+++ b/src/resolve/resolved-dns-scope.c
@@ -452,7 +452,7 @@ int dns_scope_socket_udp(DnsScope *s, DnsServer *server, uint16_t port) {
 }
 
 int dns_scope_socket_tcp(DnsScope *s, int family, const union in_addr_union *address, DnsServer *server, uint16_t port, union sockaddr_union *ret_socket_address) {
-        /* If ret_socket_address is not NULL, the caller is responisble
+        /* If ret_socket_address is not NULL, the caller is responsible
          * for calling connect() or sendmsg(). This is required by TCP
          * Fast Open, to be able to send the initial SYN packet along
          * with the first data packet. */
diff --git a/src/resolve/resolved-dns-server.c b/src/resolve/resolved-dns-server.c
index b85eb75273..8b08e20453 100644
--- a/src/resolve/resolved-dns-server.c
+++ b/src/resolve/resolved-dns-server.c
@@ -239,7 +239,7 @@ static void dns_server_reset_counters(DnsServer *s) {
          *
          * This is particularly important to deal with certain Belkin routers which break OPT for certain lookups (A),
          * but pass traffic through for others (AAAA). If we detect the broken behaviour on one lookup we should not
-         * reenable it for another, because we cannot validate things anyway, given that the RRSIG/OPT data will be
+         * re-enable it for another, because we cannot validate things anyway, given that the RRSIG/OPT data will be
          * incomplete. */
 }
 
@@ -879,7 +879,7 @@ void dns_server_unref_stream(DnsServer *s) {
 
         /* Detaches the default stream of this server. Some special care needs to be taken here, as that stream and
          * this server reference each other. First, take the stream out of the server. It's destructor will check if it
-         * is registered with us, hence let's invalidate this separatly, so that it is already unregistered. */
+         * is registered with us, hence let's invalidate this separately, so that it is already unregistered. */
         ref = TAKE_PTR(s->stream);
 
         /* And then, unref it */
diff --git a/src/resolve/resolved-dns-stream.c b/src/resolve/resolved-dns-stream.c
index cb7b186fc9..04ba1d91bc 100644
--- a/src/resolve/resolved-dns-stream.c
+++ b/src/resolve/resolved-dns-stream.c
@@ -61,7 +61,7 @@ static int dns_stream_complete(DnsStream *s, int error) {
         assert(error >= 0);
 
         /* Error is > 0 when the connection failed for some reason in the network stack. It's == 0 if we sent
-         * and receieved exactly one packet each (in the LLMNR client case). */
+         * and received exactly one packet each (in the LLMNR client case). */
 
 #if ENABLE_DNS_OVER_TLS
         if (s->encrypted) {
diff --git a/src/resolve/resolved-dns-transaction.c b/src/resolve/resolved-dns-transaction.c
index 9cac91f536..85c33cf2ca 100644
--- a/src/resolve/resolved-dns-transaction.c
+++ b/src/resolve/resolved-dns-transaction.c
@@ -734,7 +734,7 @@ static int dns_transaction_dnssec_ready(DnsTransaction *t) {
                         }
 
                         /* Fall-through: NXDOMAIN/SERVFAIL is good enough for us. This is because some DNS servers
-                         * erronously return NXDOMAIN/SERVFAIL for empty non-terminals (Akamai...) or missing DS
+                         * erroneously return NXDOMAIN/SERVFAIL for empty non-terminals (Akamai...) or missing DS
                          * records (Facebook), and we need to handle that nicely, when asking for parent SOA or similar
                          * RRs to make unsigned proofs. */
 
@@ -1502,7 +1502,7 @@ static int dns_transaction_make_packet_mdns(DnsTransaction *t) {
         /*
          * For mDNS, we want to coalesce as many open queries in pending transactions into one single
          * query packet on the wire as possible. To achieve that, we iterate through all pending transactions
-         * in our current scope, and see whether their timing contraints allow them to be sent.
+         * in our current scope, and see whether their timing constraints allow them to be sent.
          */
 
         assert_se(sd_event_now(t->scope->manager->event, clock_boottime_or_monotonic(), &ts) >= 0);
@@ -2026,7 +2026,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
         if (t->answer_source != DNS_TRANSACTION_NETWORK)
                 return 0; /* We only need to validate stuff from the network */
         if (!dns_transaction_dnssec_supported(t))
-                return 0; /* If we can't do DNSSEC anyway there's no point in geting the auxiliary RRs */
+                return 0; /* If we can't do DNSSEC anyway there's no point in getting the auxiliary RRs */
 
         DNS_ANSWER_FOREACH(rr, t->answer) {
 
@@ -2066,7 +2066,7 @@ int dns_transaction_request_dnssec_keys(DnsTransaction *t) {
                          * RRs for stuff we didn't really ask for, and
                          * also to avoid request loops, where
                          * additional RRs from one transaction result
-                         * in another transaction whose additonal RRs
+                         * in another transaction whose additional RRs
                          * point back to the original transaction, and
                          * we deadlock. */
                         r = dns_name_endswith(dns_resource_key_name(t->key), rr->rrsig.signer);
diff --git a/src/resolve/resolved-dns-trust-anchor.c b/src/resolve/resolved-dns-trust-anchor.c
index d25b5f9d95..3e4cc331d9 100644
--- a/src/resolve/resolved-dns-trust-anchor.c
+++ b/src/resolve/resolved-dns-trust-anchor.c
@@ -222,7 +222,7 @@ static int dns_trust_anchor_load_positive(DnsTrustAnchor *d, const char *path, u
 
         r = dns_name_is_valid(domain);
         if (r < 0)
-                return log_warning_errno(r, "Failed to chack validity of domain name '%s', at line %s:%u, ignoring line: %m", domain, path, line);
+                return log_warning_errno(r, "Failed to check validity of domain name '%s', at line %s:%u, ignoring line: %m", domain, path, line);
         if (r == 0) {
                 log_warning("Domain name %s is invalid, at line %s:%u, ignoring line.", domain, path, line);
                 return -EINVAL;
@@ -392,7 +392,7 @@ static int dns_trust_anchor_load_negative(DnsTrustAnchor *d, const char *path, u
 
         r = dns_name_is_valid(domain);
         if (r < 0)
-                return log_warning_errno(r, "Failed to chack validity of domain name '%s', at line %s:%u, ignoring line: %m", domain, path, line);
+                return log_warning_errno(r, "Failed to check validity of domain name '%s', at line %s:%u, ignoring line: %m", domain, path, line);
         if (r == 0) {
                 log_warning("Domain name %s is invalid, at line %s:%u, ignoring line.", domain, path, line);
                 return -EINVAL;
diff --git a/src/resolve/resolved-dns-zone.c b/src/resolve/resolved-dns-zone.c
index c2d9f3d33d..d5cc2767d7 100644
--- a/src/resolve/resolved-dns-zone.c
+++ b/src/resolve/resolved-dns-zone.c
@@ -257,7 +257,7 @@ int dns_zone_put(DnsZone *z, DnsScope *s, DnsResourceRecord *rr, bool probe) {
 
                 /* Check if there's already an RR with the same name
                  * established. If so, it has been probed already, and
-                 * we don't ned to probe again. */
+                 * we don't need to probe again. */
 
                 LIST_FIND_HEAD(by_name, i, first);
                 LIST_FOREACH(by_name, j, first) {
diff --git a/src/resolve/resolved-dnstls-gnutls.c b/src/resolve/resolved-dnstls-gnutls.c
index ddf9758bb3..4da5121e62 100644
--- a/src/resolve/resolved-dnstls-gnutls.c
+++ b/src/resolve/resolved-dnstls-gnutls.c
@@ -120,7 +120,7 @@ int dnstls_stream_shutdown(DnsStream *stream, int error) {
         assert(stream->encrypted);
         assert(stream->dnstls_data.session);
 
-        /* Store TLS Ticket for faster succesive TLS handshakes */
+        /* Store TLS Ticket for faster successive TLS handshakes */
         if (stream->server && stream->server->dnstls_data.session_data.size == 0 && stream->dnstls_data.handshake == GNUTLS_E_SUCCESS)
                 gnutls_session_get_data2(stream->dnstls_data.session, &stream->server->dnstls_data.session_data);
 
diff --git a/src/shared/bootspec.c b/src/shared/bootspec.c
index 9a0dc29153..969ae7f028 100644
--- a/src/shared/bootspec.c
+++ b/src/shared/bootspec.c
@@ -1077,12 +1077,12 @@ static int verify_esp(
          *
          *  -ENOENT        â†’ if 'searching' is set, and the dir doesn't exist
          *  -EADDRNOTAVAIL â†’ if 'searching' is set, and the dir doesn't look like an ESP
-         *  -EACESS        â†’ if 'unprivileged_mode' is set, and we have trouble acessing the thing
+         *  -EACESS        â†’ if 'unprivileged_mode' is set, and we have trouble accessing the thing
          */
 
         relax_checks = getenv_bool("SYSTEMD_RELAX_ESP_CHECKS") > 0;
 
-        /* Non-root user can only check the status, so if an error occured in the following, it does not cause any
+        /* Non-root user can only check the status, so if an error occurred in the following, it does not cause any
          * issues. Let's also, silence the error messages. */
 
         if (!relax_checks) {
diff --git a/src/shared/dissect-image.c b/src/shared/dissect-image.c
index ce210bfd43..699a1616a4 100644
--- a/src/shared/dissect-image.c
+++ b/src/shared/dissect-image.c
@@ -47,7 +47,7 @@
 
 int probe_filesystem(const char *node, char **ret_fstype) {
         /* Try to find device content type and return it in *ret_fstype. If nothing is found,
-         * 0/NULL will be returned. -EUCLEAN will be returned for ambigous results, and an
+         * 0/NULL will be returned. -EUCLEAN will be returned for ambiguous results, and an
          * different error otherwise. */
 
 #if HAVE_BLKID
diff --git a/src/shared/dissect-image.h b/src/shared/dissect-image.h
index ded43f331a..40b8035ac7 100644
--- a/src/shared/dissect-image.h
+++ b/src/shared/dissect-image.h
@@ -57,7 +57,7 @@ typedef enum DissectImageFlags {
         DISSECT_IMAGE_REQUIRE_ROOT        = 1 << 5,  /* Don't accept disks without root partition */
         DISSECT_IMAGE_MOUNT_ROOT_ONLY     = 1 << 6,  /* Mount only the root partition */
         DISSECT_IMAGE_MOUNT_NON_ROOT_ONLY = 1 << 7,  /* Mount only non-root partitions */
-        DISSECT_IMAGE_VALIDATE_OS         = 1 << 8,  /* Refuse mounting images that aren't identifyable as OS images */
+        DISSECT_IMAGE_VALIDATE_OS         = 1 << 8,  /* Refuse mounting images that aren't identifiable as OS images */
         DISSECT_IMAGE_NO_UDEV             = 1 << 9,  /* Don't wait for udev initializing things */
 } DissectImageFlags;
 
diff --git a/src/shared/exec-util.c b/src/shared/exec-util.c
index 2867f08a7a..add7fe4c14 100644
--- a/src/shared/exec-util.c
+++ b/src/shared/exec-util.c
@@ -105,7 +105,7 @@ static int do_execute(
                         return log_oom();
         }
 
-        /* Abort execution of this process after the timout. We simply rely on SIGALRM as
+        /* Abort execution of this process after the timeout. We simply rely on SIGALRM as
          * default action terminating the process, and turn on alarm(). */
 
         if (timeout != USEC_INFINITY)
diff --git a/src/shared/format-table.c b/src/shared/format-table.c
index a5c0a99b08..cba325184d 100644
--- a/src/shared/format-table.c
+++ b/src/shared/format-table.c
@@ -846,7 +846,7 @@ static int cell_data_compare(TableData *a, size_t index_a, TableData *b, size_t
                 }
         }
 
-        /* Generic fallback using the orginal order in which the cells where added. */
+        /* Generic fallback using the original order in which the cells where added. */
         return CMP(index_a, index_b);
 }
 
diff --git a/src/shared/fstab-util.c b/src/shared/fstab-util.c
index 118d591c09..135b01f282 100644
--- a/src/shared/fstab-util.c
+++ b/src/shared/fstab-util.c
@@ -121,7 +121,7 @@ int fstab_filter_options(const char *opts, const char *names,
                         t++;
                         continue;
                 found:
-                        /* Keep the last occurence found */
+                        /* Keep the last occurrence found */
                         n = name;
                         if (value) {
                                 free(v);
diff --git a/src/shared/install.c b/src/shared/install.c
index ca52d17e4f..5391ac702b 100644
--- a/src/shared/install.c
+++ b/src/shared/install.c
@@ -888,7 +888,7 @@ static int find_symlinks_in_scope(
 
         /* As we iterate over the list of search paths in paths->search_path, we may encounter "same name"
          * symlinks. The ones which are "below" (i.e. have lower priority) than the unit file itself are
-         * efectively masked, so we should ignore them. */
+         * effectively masked, so we should ignore them. */
 
         STRV_FOREACH(p, paths->search_path)  {
                 bool same_name_link = false;
@@ -2946,7 +2946,7 @@ static int pattern_match_multiple_instances(
         int r;
 
         /* If no ret is needed or the rule itself does not have instances
-         * initalized, we return not matching */
+         * initialized, we return not matching */
         if (!ret || !rule.instances)
                 return 0;
 
diff --git a/src/shared/journal-util.c b/src/shared/journal-util.c
index 89b76af5b3..2f672c2935 100644
--- a/src/shared/journal-util.c
+++ b/src/shared/journal-util.c
@@ -50,7 +50,7 @@ static int access_check_var_log_journal(sd_journal *j, bool want_other_users) {
         if (!strv_isempty(g)) {
                 _cleanup_free_ char *s = NULL;
 
-                /* Thre are groups in the ACL, let's list them */
+                /* There are groups in the ACL, let's list them */
                 r = strv_extend(&g, "systemd-journal");
                 if (r < 0)
                         return log_oom();
diff --git a/src/shared/json.h b/src/shared/json.h
index e5532c506e..6790e0c1f5 100644
--- a/src/shared/json.h
+++ b/src/shared/json.h
@@ -12,7 +12,7 @@
 
 /*
   In case you wonder why we have our own JSON implementation, here are a couple of reasons why this implementation has
-  benefits over various other implementatins:
+  benefits over various other implementations:
 
   - We need support for 64bit signed and unsigned integers, i.e. the full 64,5bit range of -9223372036854775808â€¦18446744073709551615
   - All our variants are immutable after creation
@@ -209,7 +209,7 @@ int json_buildv(JsonVariant **ret, va_list ap);
 typedef enum JsonDispatchFlags {
         /* The following three may be set in JsonDispatch's .flags field or the json_dispatch() flags parameter  */
         JSON_PERMISSIVE = 1 << 0, /* Shall parsing errors be considered fatal for this property? */
-        JSON_MANDATORY  = 1 << 1, /* Should existance of this property be mandatory? */
+        JSON_MANDATORY  = 1 << 1, /* Should existence of this property be mandatory? */
         JSON_LOG        = 1 << 2, /* Should the parser log about errors? */
 
         /* The following two may be passed into log_json() in addition to the three above */
diff --git a/src/shared/main-func.h b/src/shared/main-func.h
index 1b77316d82..6c26cb9fb5 100644
--- a/src/shared/main-func.h
+++ b/src/shared/main-func.h
@@ -30,7 +30,7 @@
         _DEFINE_MAIN_FUNCTION(,impl(argc, argv), r < 0 ? EXIT_FAILURE : EXIT_SUCCESS)
 
 /* Zero is mapped to EXIT_SUCCESS, negative values are mapped to EXIT_FAILURE,
- * and postive values are propagated.
+ * and positive values are propagated.
  * Note: "true" means failure! */
 #define DEFINE_MAIN_FUNCTION_WITH_POSITIVE_FAILURE(impl)                \
         _DEFINE_MAIN_FUNCTION(,impl(argc, argv), r < 0 ? EXIT_FAILURE : r)
diff --git a/src/shared/mount-util.c b/src/shared/mount-util.c
index 9987b6f80c..68f9e66b2c 100644
--- a/src/shared/mount-util.c
+++ b/src/shared/mount-util.c
@@ -521,7 +521,7 @@ int mount_option_mangle(
          * See more examples in test-mount-utils.c.
          *
          * Note that if 'options' does not contain any non-mount-flag options,
-         * then '*ret_remaining_options' is set to NULL instread of empty string.
+         * then '*ret_remaining_options' is set to NULL instead of empty string.
          * Note that this does not check validity of options stored in
          * '*ret_remaining_options'.
          * Note that if 'options' is NULL, then this just copies 'mount_flags'
diff --git a/src/shared/nscd-flush.c b/src/shared/nscd-flush.c
index 5a04468d2c..33a06a010c 100644
--- a/src/shared/nscd-flush.c
+++ b/src/shared/nscd-flush.c
@@ -51,7 +51,7 @@ static int nscd_flush_cache_one(const char *database, usec_t end) {
         /* Note: connect() returns EINPROGRESS if O_NONBLOCK is set and establishing a connection takes time. The
          * kernel lets us know this way that the connection is now being established, and we should watch with poll()
          * to learn when it is fully established. That said, AF_UNIX on Linux never triggers this IRL (connect() is
-         * always instant on AF_UNIX), hence handling this is mostly just an excercise in defensive, protocol-agnostic
+         * always instant on AF_UNIX), hence handling this is mostly just an exercise in defensive, protocol-agnostic
          * programming.
          *
          * connect() returns EAGAIN if the socket's backlog limit has been reached. When we see this we give up right
@@ -113,7 +113,7 @@ static int nscd_flush_cache_one(const char *database, usec_t end) {
 
                 if (has_written >= req_size && has_read >= sizeof(resp)) { /* done? */
                         if (resp < 0)
-                                return log_debug_errno(SYNTHETIC_ERRNO(EBADMSG), "nscd sent us a negative error numer: %i", resp);
+                                return log_debug_errno(SYNTHETIC_ERRNO(EBADMSG), "nscd sent us a negative error number: %i", resp);
                         if (resp > 0)
                                 return log_debug_errno(resp, "nscd return failure code on invalidating '%s'.", database);
                         return 1;
diff --git a/src/shared/os-util.c b/src/shared/os-util.c
index b2d5ce32e7..2191a610ae 100644
--- a/src/shared/os-util.c
+++ b/src/shared/os-util.c
@@ -15,7 +15,7 @@ int path_is_os_tree(const char *path) {
         assert(path);
 
         /* Does the path exist at all? If not, generate an error immediately. This is useful so that a missing root dir
-         * always results in -ENOENT, and we can properly distuingish the case where the whole root doesn't exist from
+         * always results in -ENOENT, and we can properly distinguish the case where the whole root doesn't exist from
          * the case where just the os-release file is missing. */
         if (laccess(path, F_OK) < 0)
                 return -errno;
diff --git a/src/shutdown/shutdown.c b/src/shutdown/shutdown.c
index 842ba57f13..6e802ec3cc 100644
--- a/src/shutdown/shutdown.c
+++ b/src/shutdown/shutdown.c
@@ -218,7 +218,7 @@ static void sync_with_progress(void) {
 
         BLOCK_SIGNALS(SIGCHLD);
 
-        /* Due to the possiblity of the sync operation hanging, we fork a child process and monitor the progress. If
+        /* Due to the possibility of the sync operation hanging, we fork a child process and monitor the progress. If
          * the timeout lapses, the assumption is that that particular sync stalled. */
 
         r = asynchronous_sync(&pid);
diff --git a/src/shutdown/umount.c b/src/shutdown/umount.c
index 928bae6ab1..148cb1651d 100644
--- a/src/shutdown/umount.c
+++ b/src/shutdown/umount.c
@@ -390,7 +390,7 @@ static int remount_with_timeout(MountPoint *m, int umount_log_level) {
 
         assert(m);
 
-        /* Due to the possiblity of a remount operation hanging, we
+        /* Due to the possibility of a remount operation hanging, we
          * fork a child process and set a timeout. If the timeout
          * lapses, the assumption is that that particular remount
          * failed. */
@@ -428,7 +428,7 @@ static int umount_with_timeout(MountPoint *m, int umount_log_level) {
 
         assert(m);
 
-        /* Due to the possiblity of a umount operation hanging, we
+        /* Due to the possibility of a umount operation hanging, we
          * fork a child process and set a timeout. If the timeout
          * lapses, the assumption is that that particular umount
          * failed. */
@@ -486,7 +486,7 @@ static int mount_points_list_umount(MountPoint **head, bool *changed, int umount
                          * underlying mount. There's nothing we can do
                          * about it for the general case, but we can
                          * do something about it if it is aliased
-                         * somehwere else via a bind mount. If we
+                         * somewhere else via a bind mount. If we
                          * explicitly remount the super block of that
                          * alias read-only we hence should be
                          * relatively safe regarding keeping a dirty fs
diff --git a/src/systemctl/systemctl.c b/src/systemctl/systemctl.c
index 92bbcfd276..993d593c3b 100644
--- a/src/systemctl/systemctl.c
+++ b/src/systemctl/systemctl.c
@@ -180,7 +180,7 @@ typedef enum BusFocus {
         _BUS_FOCUS_MAX
 } BusFocus;
 
-static sd_bus *busses[_BUS_FOCUS_MAX] = {};
+static sd_bus *buses[_BUS_FOCUS_MAX] = {};
 
 static UnitFileFlags args_to_flags(void) {
         return (arg_runtime ? UNIT_FILE_RUNTIME : 0) |
@@ -200,22 +200,22 @@ static int acquire_bus(BusFocus focus, sd_bus **ret) {
         if (getenv_bool("SYSTEMCTL_FORCE_BUS") > 0)
                 focus = BUS_FULL;
 
-        if (!busses[focus]) {
+        if (!buses[focus]) {
                 bool user;
 
                 user = arg_scope != UNIT_FILE_SYSTEM;
 
                 if (focus == BUS_MANAGER)
-                        r = bus_connect_transport_systemd(arg_transport, arg_host, user, &busses[focus]);
+                        r = bus_connect_transport_systemd(arg_transport, arg_host, user, &buses[focus]);
                 else
-                        r = bus_connect_transport(arg_transport, arg_host, user, &busses[focus]);
+                        r = bus_connect_transport(arg_transport, arg_host, user, &buses[focus]);
                 if (r < 0)
                         return log_error_errno(r, "Failed to connect to bus: %m");
 
-                (void) sd_bus_set_allow_interactive_authorization(busses[focus], arg_ask_password);
+                (void) sd_bus_set_allow_interactive_authorization(buses[focus], arg_ask_password);
         }
 
-        *ret = busses[focus];
+        *ret = buses[focus];
         return 0;
 }
 
@@ -223,7 +223,7 @@ static void release_busses(void) {
         BusFocus w;
 
         for (w = 0; w < _BUS_FOCUS_MAX; w++)
-                busses[w] = sd_bus_flush_close_unref(busses[w]);
+                buses[w] = sd_bus_flush_close_unref(buses[w]);
 }
 
 static void ask_password_agent_open_if_enabled(void) {
@@ -8800,7 +8800,7 @@ static int systemctl_main(int argc, char *argv[]) {
                 { "restart",               2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },
                 { "try-restart",           2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },
                 { "reload-or-restart",     2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },
-                { "reload-or-try-restart", 2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatbility with old systemctl <= 228 */
+                { "reload-or-try-restart", 2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatibility with old systemctl <= 228 */
                 { "try-reload-or-restart", 2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           },
                 { "force-reload",          2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatibility with SysV */
                 { "condreload",            2,        VERB_ANY, VERB_ONLINE_ONLY, start_unit           }, /* For compatibility with ALTLinux */
diff --git a/src/systemd/sd-bus-vtable.h b/src/systemd/sd-bus-vtable.h
index e3804e203c..0f43554d82 100644
--- a/src/systemd/sd-bus-vtable.h
+++ b/src/systemd/sd-bus-vtable.h
@@ -54,11 +54,11 @@ enum {
 
 extern const unsigned sd_bus_object_vtable_format;
 
-/* Note: unused areas in the sd_bus_vtable[] array must be initalized to 0. The stucture contains an embedded
- * union, and the compiler is NOT required to initalize the unused areas of the union when the rest of the
- * structure is initalized. Normally the array is defined as read-only data, in which case the linker places
- * it in the BSS section, which is always fully initalized, so this is not a concern. But if the array is
- * created on the stack or on the heap, care must be taken to initalize the unused areas, for examply by
+/* Note: unused areas in the sd_bus_vtable[] array must be initialized to 0. The structure contains an embedded
+ * union, and the compiler is NOT required to initialize the unused areas of the union when the rest of the
+ * structure is initialized. Normally the array is defined as read-only data, in which case the linker places
+ * it in the BSS section, which is always fully initialized, so this is not a concern. But if the array is
+ * created on the stack or on the heap, care must be taken to initialize the unused areas, for examply by
  * first memsetting the whole region to zero before filling the data in. */
 
 struct sd_bus_vtable {
diff --git a/src/test/test-bpf.c b/src/test/test-bpf.c
index cd8d68f215..60811fe9eb 100644
--- a/src/test/test-bpf.c
+++ b/src/test/test-bpf.c
@@ -97,7 +97,7 @@ int main(int argc, char *argv[]) {
 
         p = bpf_program_unref(p);
 
-        /* The simple tests suceeded. Now let's try full unit-based use-case. */
+        /* The simple tests succeeded. Now let's try full unit-based use-case. */
 
         assert_se(manager_new(UNIT_FILE_USER, MANAGER_TEST_RUN_BASIC, &m) >= 0);
         assert_se(manager_startup(m, NULL, NULL) >= 0);
diff --git a/src/test/test-fileio.c b/src/test/test-fileio.c
index 2ff5b9a69d..86bfc80de0 100644
--- a/src/test/test-fileio.c
+++ b/src/test/test-fileio.c
@@ -717,7 +717,7 @@ static void test_read_line_one_file(FILE *f) {
         line = mfree(line);
 
         /* read_line() stopped when it hit the limit, that means when we continue reading we'll read at the first
-         * character after the previous limit. Let's make use of tha to continue our test. */
+         * character after the previous limit. Let's make use of that to continue our test. */
         assert_se(read_line(f, 1024, &line) == 62 && streq(line, "line that is supposed to be truncated, because it is so long"));
         line = mfree(line);
 
diff --git a/src/test/test-install-root.c b/src/test/test-install-root.c
index cfddfe19a7..323e1124ba 100644
--- a/src/test/test-install-root.c
+++ b/src/test/test-install-root.c
@@ -112,7 +112,7 @@ static void test_basic_mask_and_enable(const char *root) {
         assert_se(unit_file_get_state(UNIT_FILE_SYSTEM, root, "c.service", &state) >= 0 && state == UNIT_FILE_DISABLED);
         assert_se(unit_file_get_state(UNIT_FILE_SYSTEM, root, "d.service", &state) >= 0 && state == UNIT_FILE_DISABLED);
 
-        /* Disabling a disabled unit must suceed but be a NOP */
+        /* Disabling a disabled unit must succeed but be a NOP */
         assert_se(unit_file_disable(UNIT_FILE_SYSTEM, 0, root, STRV_MAKE("a.service"), &changes, &n_changes) >= 0);
         assert_se(n_changes == 0);
         unit_file_changes_free(changes, n_changes);
diff --git a/src/test/test-pretty-print.c b/src/test/test-pretty-print.c
index 3ad80d145d..9236eb1315 100644
--- a/src/test/test-pretty-print.c
+++ b/src/test/test-pretty-print.c
@@ -15,7 +15,7 @@ static void test_terminal_urlify(void) {
         _cleanup_free_ char *formatted = NULL;
 
         assert_se(terminal_urlify("https://www.freedesktop.org/wiki/Software/systemd/", "systemd homepage", &formatted) >= 0);
-        printf("Hey, considere visiting the %s right now! It is very good!\n", formatted);
+        printf("Hey, consider visiting the %s right now! It is very good!\n", formatted);
 
         formatted = mfree(formatted);
 
diff --git a/src/test/test-sleep.c b/src/test/test-sleep.c
index e0c513ad8c..7e949154b1 100644
--- a/src/test/test-sleep.c
+++ b/src/test/test-sleep.c
@@ -61,7 +61,7 @@ static void test_sleep(void) {
                 **reboot = strv_new("reboot"),
                 **platform = strv_new("platform"),
                 **shutdown = strv_new("shutdown"),
-                **freez = strv_new("freeze");
+                **freeze = strv_new("freeze");
         int r;
 
         log_info("/* %s */", __func__);
@@ -74,7 +74,7 @@ static void test_sleep(void) {
         log_info("Hibernate+Reboot configured: %s", yes_no(can_sleep_disk(reboot) > 0));
         log_info("Hibernate+Platform configured: %s", yes_no(can_sleep_disk(platform) > 0));
         log_info("Hibernate+Shutdown configured: %s", yes_no(can_sleep_disk(shutdown) > 0));
-        log_info("Freeze configured: %s", yes_no(can_sleep_state(freez) > 0));
+        log_info("Freeze configured: %s", yes_no(can_sleep_state(freeze) > 0));
 
         log_info("/= running system =/");
         r = can_sleep("suspend");
diff --git a/src/test/test-systemd-tmpfiles.py b/src/test/test-systemd-tmpfiles.py
index 83a66e8772..7f4af38940 100755
--- a/src/test/test-systemd-tmpfiles.py
+++ b/src/test/test-systemd-tmpfiles.py
@@ -52,8 +52,8 @@ def test_invalids(*, user):
     test_line('w /unresolved/argument/sandwich - - - - "%v%Y%v"', user=user)
     test_line('w /unresolved/filename/%Y - - - - "whatever"', user=user)
     test_line('w /unresolved/filename/sandwich/%v%Y%v - - - - "whatever"', user=user)
-    test_line('w - - - - - "no file specfied"', user=user)
-    test_line('C - - - - - "no file specfied"', user=user)
+    test_line('w - - - - - "no file specified"', user=user)
+    test_line('C - - - - - "no file specified"', user=user)
     test_line('C non/absolute/path - - - - -', user=user)
     test_line('b - - - - - -', user=user)
     test_line('b 1234 - - - - -', user=user)
diff --git a/src/time-wait-sync/time-wait-sync.c b/src/time-wait-sync/time-wait-sync.c
index d02633c9a8..f4d20af2d4 100644
--- a/src/time-wait-sync/time-wait-sync.c
+++ b/src/time-wait-sync/time-wait-sync.c
@@ -241,7 +241,7 @@ static int run(int argc, char * argv[]) {
         }
 
         if (state.has_watchfile)
-                log_debug("Exit enabled by: /run/systemd/timesync/synchonized");
+                log_debug("Exit enabled by: /run/systemd/timesync/synchronized");
 
         if (state.adjtime_state == TIME_ERROR)
                 log_info("Exit without adjtimex synchronized.");
diff --git a/src/timesync/timesyncd.c b/src/timesync/timesyncd.c
index 73d40c0948..e56e09ca8c 100644
--- a/src/timesync/timesyncd.c
+++ b/src/timesync/timesyncd.c
@@ -52,7 +52,7 @@ static int load_clock_timestamp(uid_t uid, gid_t gid) {
 
                 if (geteuid() == 0) {
                         /* Try to fix the access mode, so that we can still
-                           touch the file after dropping priviliges */
+                           touch the file after dropping privileges */
                         r = fchmod_and_chown(fd, 0644, uid, gid);
                         if (r < 0)
                                 log_warning_errno(r, "Failed to chmod or chown %s, ignoring: %m", CLOCK_FILE);
diff --git a/src/udev/cdrom_id/cdrom_id.c b/src/udev/cdrom_id/cdrom_id.c
index 3f882f557b..ddcdbdaa18 100644
--- a/src/udev/cdrom_id/cdrom_id.c
+++ b/src/udev/cdrom_id/cdrom_id.c
@@ -611,7 +611,7 @@ static int cd_media_info(int fd) {
         if (!cd_media_cd_rom)
                 cd_media_state = media_status[header[2] & 3];
 
-        /* fresh DVD-RW in restricted overwite mode reports itself as
+        /* fresh DVD-RW in restricted overwrite mode reports itself as
          * "appendable"; change it to "blank" to make it consistent with what
          * gets reported after blanking, and what userspace expects  */
         if (cd_media_dvd_rw_ro && (header[2] & 3) == 1)
diff --git a/src/udev/net/naming-scheme.h b/src/udev/net/naming-scheme.h
index 0b3d9bff1d..f04c3266f0 100644
--- a/src/udev/net/naming-scheme.h
+++ b/src/udev/net/naming-scheme.h
@@ -5,7 +5,7 @@
 
 #include "macro.h"
 
-/* So here's the deal: net_id is supposed to be an excercise in providing stable names for network devices. However, we
+/* So here's the deal: net_id is supposed to be an exercise in providing stable names for network devices. However, we
  * also want to keep updating the naming scheme used in future versions of net_id. These two goals of course are
  * contradictory: on one hand we want things to not change and on the other hand we want them to improve. Our way out
  * of this dilemma is to introduce the "naming scheme" concept: each time we improve the naming logic we define a new
diff --git a/src/vconsole/vconsole-setup.c b/src/vconsole/vconsole-setup.c
index 67dc2e49f9..976dd825bc 100644
--- a/src/vconsole/vconsole-setup.c
+++ b/src/vconsole/vconsole-setup.c
@@ -247,7 +247,7 @@ static void setup_remaining_vcs(int src_fd, unsigned src_idx, bool utf8) {
                         /*
                          * Console fonts supported by the kernel are limited in size to 32 x 32 and maximum 512
                          * characters. Thus with 1 bit per pixel it requires up to 65536 bytes. The height always
-                         * requries 32 per glyph, regardless of the actual height - see the comment above #define
+                         * requires 32 per glyph, regardless of the actual height - see the comment above #define
                          * max_font_size 65536 in drivers/tty/vt/vt.c for more details.
                          */
                         fontbuf = malloc_multiply((cfo.width + 7) / 8 * 32, cfo.charcount);
diff --git a/test/TEST-20-MAINPIDGAMES/testsuite.sh b/test/TEST-20-MAINPIDGAMES/testsuite.sh
index b183ec9a6b..27b8389889 100755
--- a/test/TEST-20-MAINPIDGAMES/testsuite.sh
+++ b/test/TEST-20-MAINPIDGAMES/testsuite.sh
@@ -44,11 +44,11 @@ test `systemctl show -p MainPID --value testsuite.service` -eq $$
 systemd-notify MAINPID=1073741824
 test `systemctl show -p MainPID --value testsuite.service` -eq $$
 
-# Change it again to the external PID, without priviliges this time. This should be ignored, because the PID is from outside of our cgroup and we lack privileges.
+# Change it again to the external PID, without privileges this time. This should be ignored, because the PID is from outside of our cgroup and we lack privileges.
 systemd-notify --uid=1000 MAINPID=$EXTERNALPID
 test `systemctl show -p MainPID --value testsuite.service` -eq $$
 
-# Change it again to the internal PID, without priviliges this time. This should work, as the process is on our cgroup, and that's enough even if we lack privileges.
+# Change it again to the internal PID, without privileges this time. This should work, as the process is on our cgroup, and that's enough even if we lack privileges.
 systemd-notify --uid=1000 MAINPID=$INTERNALPID
 test `systemctl show -p MainPID --value testsuite.service` -eq $INTERNALPID
 
diff --git a/test/TEST-21-SYSUSERS/unhappy-2.input b/test/TEST-21-SYSUSERS/unhappy-2.input
index 5be0e6d187..3266b2229b 100644
--- a/test/TEST-21-SYSUSERS/unhappy-2.input
+++ b/test/TEST-21-SYSUSERS/unhappy-2.input
@@ -1,4 +1,4 @@
-# Ensure it is not allowed to create groups implicitely in the uid:gid syntax
+# Ensure it is not allowed to create groups implicitly in the uid:gid syntax
 #
 #Type Name ID  GECOS HOMEDIR
 u u1 100:100 -
diff --git a/test/TEST-22-TMPFILES/test-03.sh b/test/TEST-22-TMPFILES/test-03.sh
index 39a4badc38..8d009fb5bb 100755
--- a/test/TEST-22-TMPFILES/test-03.sh
+++ b/test/TEST-22-TMPFILES/test-03.sh
@@ -212,7 +212,7 @@ EOF
 test -f /tmp/w/overwritten
 test "$(< /tmp/w/overwritten)" = "new content"
 
-### writing into an 'exotic' file sould be allowed.
+### writing into an 'exotic' file should be allowed.
 systemd-tmpfiles --create - <<EOF
 w     /dev/null    - - - - new content
 EOF
diff --git a/test/mkosi.default.networkd-test b/test/mkosi.default.networkd-test
index 9630d3ec42..58af352f6f 100644
--- a/test/mkosi.default.networkd-test
+++ b/test/mkosi.default.networkd-test
@@ -1,7 +1,7 @@
 # Puts together an nspawn container and runs networkd-test.py in it, inside a
 # network namespace and everything. Run this with "mkosi
 # --default=mkosi.default.networkd-test boot". This will start the test and
-# eventually exit with sucess in case the test succeeded.
+# eventually exit with success in case the test succeeded.
 
 [Distribution]
 Distribution=fedora
diff --git a/test/sysv-generator-test.py b/test/sysv-generator-test.py
index abb3116c97..3d9c1ddb87 100755
--- a/test/sysv-generator-test.py
+++ b/test/sysv-generator-test.py
@@ -48,7 +48,7 @@ class SysvGeneratorTest(unittest.TestCase):
         '''Run sysv-generator.
 
         Fail if stderr contains any "Fail", unless expect_error is True.
-        Return (stderr, filename -> ConfigParser) pair with ouput to stderr and
+        Return (stderr, filename -> ConfigParser) pair with output to stderr and
         parsed generated units.
         '''
         env = os.environ.copy()
diff --git a/test/test-network/systemd-networkd-tests.py b/test/test-network/systemd-networkd-tests.py
index b44cfe8d45..11a05784a2 100755
--- a/test/test-network/systemd-networkd-tests.py
+++ b/test/test-network/systemd-networkd-tests.py
@@ -2016,7 +2016,7 @@ class NetworkdNetworkDHCPClientTests(unittest.TestCase, Utilities):
         print(output)
         self.assertRegex(output, '192.168.5.*')
 
-        # Stoping dnsmasq as networkd won't be allowed to renew the DHCP lease.
+        # Stopping dnsmasq as networkd won't be allowed to renew the DHCP lease.
         self.stop_dnsmasq(dnsmasq_pid_file)
 
         # Sleep for 120 sec as the dnsmasq minimum lease time can only be set to 120
diff --git a/test/udev-test.pl b/test/udev-test.pl
index 122359e377..b37b2e975f 100755
--- a/test/udev-test.pl
+++ b/test/udev-test.pl
@@ -279,7 +279,7 @@ KERNEL=="ttyACM0", SYMLINK+="modem"
 EOF
         },
         {
-                desc            => "sustitution of sysfs value (%s{file})",
+                desc            => "substitution of sysfs value (%s{file})",
                 devpath         => "/devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda",
                 exp_name        => "disk-ATA-sda",
                 rules           => <<EOF
diff --git a/travis-ci/Dockerfile b/travis-ci/Dockerfile
index 71dd07afe8..daf0ea9c64 100644
--- a/travis-ci/Dockerfile
+++ b/travis-ci/Dockerfile
@@ -1,5 +1,5 @@
 ## Create Dockerfile that builds container suitable for systemd build
-## This container runs as non-root user by deafult
+## This container runs as non-root user by default
 
 FROM fedora:27
 
-- 
2.21.0

