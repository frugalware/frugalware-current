diff -Naur llvm-project-15.0.7.src/clang/docs/ReleaseNotes.rst llvm-project-15.0.7.src.new/clang/docs/ReleaseNotes.rst
--- llvm-project-15.0.7.src/clang/docs/ReleaseNotes.rst	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/docs/ReleaseNotes.rst	2023-06-05 20:12:47.576384602 +0200
@@ -562,6 +562,16 @@
   `GH54872 <https://github.com/llvm/llvm-project/issues/54872>`_,
   `GH54587 <https://github.com/llvm/llvm-project/issues/54587>`_.
 
+- Support capturing structured bindings in lambdas
+  (`P1091R3 <https://wg21.link/p1091r3>`_ and `P1381R1 <https://wg21.link/P1381R1>`).
+  This fixes issues `GH52720 <https://github.com/llvm/llvm-project/issues/52720>`_,
+  `GH54300 <https://github.com/llvm/llvm-project/issues/54300>`_,
+  `GH54301 <https://github.com/llvm/llvm-project/issues/54301>`_,
+  and `GH49430 <https://github.com/llvm/llvm-project/issues/49430>`_.
+
+
+
+
 C++2b Feature Support
 ^^^^^^^^^^^^^^^^^^^^^
 
diff -Naur llvm-project-15.0.7.src/clang/include/clang/AST/DeclCXX.h llvm-project-15.0.7.src.new/clang/include/clang/AST/DeclCXX.h
--- llvm-project-15.0.7.src/clang/include/clang/AST/DeclCXX.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/AST/DeclCXX.h	2023-06-05 20:12:47.578384620 +0200
@@ -1057,8 +1057,9 @@
   ///
   /// \note No entries will be added for init-captures, as they do not capture
   /// variables.
-  void getCaptureFields(llvm::DenseMap<const VarDecl *, FieldDecl *> &Captures,
-                        FieldDecl *&ThisCapture) const;
+  void
+  getCaptureFields(llvm::DenseMap<const ValueDecl *, FieldDecl *> &Captures,
+                   FieldDecl *&ThisCapture) const;
 
   using capture_const_iterator = const LambdaCapture *;
   using capture_const_range = llvm::iterator_range<capture_const_iterator>;
diff -Naur llvm-project-15.0.7.src/clang/include/clang/AST/Decl.h llvm-project-15.0.7.src.new/clang/include/clang/AST/Decl.h
--- llvm-project-15.0.7.src/clang/include/clang/AST/Decl.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/AST/Decl.h	2023-06-05 20:12:47.577384611 +0200
@@ -689,6 +689,11 @@
   ///        or declared with the weak or weak-ref attr.
   bool isWeak() const;
 
+  /// Whether this variable is the implicit variable for a lambda init-capture.
+  /// Only VarDecl can be init captures, but both VarDecl and BindingDecl
+  /// can be captured.
+  bool isInitCapture() const;
+
   // Implement isa/cast/dyncast/etc.
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classofKind(Kind K) { return K >= firstValue && K <= lastValue; }
diff -Naur llvm-project-15.0.7.src/clang/include/clang/AST/LambdaCapture.h llvm-project-15.0.7.src.new/clang/include/clang/AST/LambdaCapture.h
--- llvm-project-15.0.7.src/clang/include/clang/AST/LambdaCapture.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/AST/LambdaCapture.h	2023-06-05 20:12:47.579384629 +0200
@@ -71,7 +71,7 @@
   /// capture that is a pack expansion, or an invalid source
   /// location to indicate that this is not a pack expansion.
   LambdaCapture(SourceLocation Loc, bool Implicit, LambdaCaptureKind Kind,
-                VarDecl *Var = nullptr,
+                ValueDecl *Var = nullptr,
                 SourceLocation EllipsisLoc = SourceLocation());
 
   /// Determine the kind of capture.
@@ -86,7 +86,7 @@
 
   /// Determine whether this capture handles a variable.
   bool capturesVariable() const {
-    return isa_and_nonnull<VarDecl>(DeclAndBits.getPointer());
+    return isa_and_nonnull<ValueDecl>(DeclAndBits.getPointer());
   }
 
   /// Determine whether this captures a variable length array bound
@@ -101,9 +101,9 @@
   ///
   /// This operation is only valid if this capture is a variable capture
   /// (other than a capture of \c this).
-  VarDecl *getCapturedVar() const {
+  ValueDecl *getCapturedVar() const {
     assert(capturesVariable() && "No variable available for capture");
-    return static_cast<VarDecl *>(DeclAndBits.getPointer());
+    return static_cast<ValueDecl *>(DeclAndBits.getPointer());
   }
 
   /// Determine whether this was an implicit capture (not
diff -Naur llvm-project-15.0.7.src/clang/include/clang/AST/Stmt.h llvm-project-15.0.7.src.new/clang/include/clang/AST/Stmt.h
--- llvm-project-15.0.7.src/clang/include/clang/AST/Stmt.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/AST/Stmt.h	2023-06-05 20:12:47.579384629 +0200
@@ -59,6 +59,7 @@
 class SourceManager;
 class StringLiteral;
 class Token;
+class ValueDecl;
 class VarDecl;
 
 //===----------------------------------------------------------------------===//
diff -Naur llvm-project-15.0.7.src/clang/include/clang/ASTMatchers/ASTMatchers.h llvm-project-15.0.7.src.new/clang/include/clang/ASTMatchers/ASTMatchers.h
--- llvm-project-15.0.7.src/clang/include/clang/ASTMatchers/ASTMatchers.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/ASTMatchers/ASTMatchers.h	2023-06-05 20:12:47.581384646 +0200
@@ -4722,7 +4722,7 @@
 /// In the matcher
 /// lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName("x")))),
 /// capturesVar(hasName("x")) matches `x` and `x = 1`.
-AST_MATCHER_P(LambdaCapture, capturesVar, internal::Matcher<VarDecl>,
+AST_MATCHER_P(LambdaCapture, capturesVar, internal::Matcher<ValueDecl>,
               InnerMatcher) {
   auto *capturedVar = Node.getCapturedVar();
   return capturedVar && InnerMatcher.matches(*capturedVar, Finder, Builder);
diff -Naur llvm-project-15.0.7.src/clang/include/clang/Basic/DiagnosticSemaKinds.td llvm-project-15.0.7.src.new/clang/include/clang/Basic/DiagnosticSemaKinds.td
--- llvm-project-15.0.7.src/clang/include/clang/Basic/DiagnosticSemaKinds.td	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/Basic/DiagnosticSemaKinds.td	2023-06-05 20:12:47.628385063 +0200
@@ -9013,6 +9013,14 @@
 def err_reference_to_local_in_enclosing_context : Error<
   "reference to local %select{variable|binding}1 %0 declared in enclosing "
   "%select{%3|block literal|lambda expression|context}2">;
+def err_capture_binding_openmp : Error<
+  "capturing a structured binding is not yet supported in OpenMP">;
+def ext_capture_binding : ExtWarn<
+  "captured structured bindings are a C++20 extension">, InGroup<CXX20>;
+def warn_cxx17_compat_capture_binding : Warning<
+  "captured structured bindings are incompatible with "
+  "C++ standards before C++20">,
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 
 def err_static_data_member_not_allowed_in_local_class : Error<
   "static data member %0 not allowed in local %sub{select_tag_type_kind}2 %1">;
diff -Naur llvm-project-15.0.7.src/clang/include/clang/Sema/ScopeInfo.h llvm-project-15.0.7.src.new/clang/include/clang/Sema/ScopeInfo.h
--- llvm-project-15.0.7.src/clang/include/clang/Sema/ScopeInfo.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/Sema/ScopeInfo.h	2023-06-05 20:12:47.584384673 +0200
@@ -553,7 +553,7 @@
     const VariableArrayType *CapturedVLA;
 
     /// Otherwise, the captured variable (if any).
-    VarDecl *CapturedVar;
+    ValueDecl *CapturedVar;
   };
 
   /// The source location at which the first capture occurred.
@@ -589,12 +589,13 @@
   unsigned Invalid : 1;
 
 public:
-  Capture(VarDecl *Var, bool Block, bool ByRef, bool IsNested,
+  Capture(ValueDecl *Var, bool Block, bool ByRef, bool IsNested,
           SourceLocation Loc, SourceLocation EllipsisLoc, QualType CaptureType,
           bool Invalid)
       : CapturedVar(Var), Loc(Loc), EllipsisLoc(EllipsisLoc),
-        CaptureType(CaptureType),
-        Kind(Block ? Cap_Block : ByRef ? Cap_ByRef : Cap_ByCopy),
+        CaptureType(CaptureType), Kind(Block   ? Cap_Block
+                                       : ByRef ? Cap_ByRef
+                                               : Cap_ByCopy),
         Nested(IsNested), CapturesThis(false), ODRUsed(false),
         NonODRUsed(false), Invalid(Invalid) {}
 
@@ -639,7 +640,7 @@
       NonODRUsed = true;
   }
 
-  VarDecl *getVariable() const {
+  ValueDecl *getVariable() const {
     assert(isVariableCapture());
     return CapturedVar;
   }
@@ -678,7 +679,7 @@
       : FunctionScopeInfo(Diag), ImpCaptureStyle(Style) {}
 
   /// CaptureMap - A map of captured variables to (index+1) into Captures.
-  llvm::DenseMap<VarDecl*, unsigned> CaptureMap;
+  llvm::DenseMap<ValueDecl *, unsigned> CaptureMap;
 
   /// CXXThisCaptureIndex - The (index+1) of the capture of 'this';
   /// zero if 'this' is not captured.
@@ -695,7 +696,7 @@
   /// or null if unknown.
   QualType ReturnType;
 
-  void addCapture(VarDecl *Var, bool isBlock, bool isByref, bool isNested,
+  void addCapture(ValueDecl *Var, bool isBlock, bool isByref, bool isNested,
                   SourceLocation Loc, SourceLocation EllipsisLoc,
                   QualType CaptureType, bool Invalid) {
     Captures.push_back(Capture(Var, isBlock, isByref, isNested, Loc,
@@ -722,23 +723,21 @@
   }
 
   /// Determine whether the given variable has been captured.
-  bool isCaptured(VarDecl *Var) const {
-    return CaptureMap.count(Var);
-  }
+  bool isCaptured(ValueDecl *Var) const { return CaptureMap.count(Var); }
 
   /// Determine whether the given variable-array type has been captured.
   bool isVLATypeCaptured(const VariableArrayType *VAT) const;
 
   /// Retrieve the capture of the given variable, if it has been
   /// captured already.
-  Capture &getCapture(VarDecl *Var) {
+  Capture &getCapture(ValueDecl *Var) {
     assert(isCaptured(Var) && "Variable has not been captured");
     return Captures[CaptureMap[Var] - 1];
   }
 
-  const Capture &getCapture(VarDecl *Var) const {
-    llvm::DenseMap<VarDecl*, unsigned>::const_iterator Known
-      = CaptureMap.find(Var);
+  const Capture &getCapture(ValueDecl *Var) const {
+    llvm::DenseMap<ValueDecl *, unsigned>::const_iterator Known =
+        CaptureMap.find(Var);
     assert(Known != CaptureMap.end() && "Variable has not been captured");
     return Captures[Known->second - 1];
   }
diff -Naur llvm-project-15.0.7.src/clang/include/clang/Sema/Sema.h llvm-project-15.0.7.src.new/clang/include/clang/Sema/Sema.h
--- llvm-project-15.0.7.src/clang/include/clang/Sema/Sema.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/include/clang/Sema/Sema.h	2023-06-05 20:12:47.588384709 +0200
@@ -5328,23 +5328,23 @@
   ///
   /// \returns true if an error occurred (i.e., the variable cannot be
   /// captured) and false if the capture succeeded.
-  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc, TryCaptureKind Kind,
-                          SourceLocation EllipsisLoc, bool BuildAndDiagnose,
-                          QualType &CaptureType,
+  bool tryCaptureVariable(ValueDecl *Var, SourceLocation Loc,
+                          TryCaptureKind Kind, SourceLocation EllipsisLoc,
+                          bool BuildAndDiagnose, QualType &CaptureType,
                           QualType &DeclRefType,
                           const unsigned *const FunctionScopeIndexToStopAt);
 
   /// Try to capture the given variable.
-  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc,
+  bool tryCaptureVariable(ValueDecl *Var, SourceLocation Loc,
                           TryCaptureKind Kind = TryCapture_Implicit,
                           SourceLocation EllipsisLoc = SourceLocation());
 
   /// Checks if the variable must be captured.
-  bool NeedToCaptureVariable(VarDecl *Var, SourceLocation Loc);
+  bool NeedToCaptureVariable(ValueDecl *Var, SourceLocation Loc);
 
   /// Given a variable, determine the type that a reference to that
   /// variable will have in the given scope.
-  QualType getCapturedDeclRefType(VarDecl *Var, SourceLocation Loc);
+  QualType getCapturedDeclRefType(ValueDecl *Var, SourceLocation Loc);
 
   /// Mark all of the declarations referenced within a particular AST node as
   /// referenced. Used when template instantiation instantiates a non-dependent
diff -Naur llvm-project-15.0.7.src/clang/lib/Analysis/AnalysisDeclContext.cpp llvm-project-15.0.7.src.new/clang/lib/Analysis/AnalysisDeclContext.cpp
--- llvm-project-15.0.7.src/clang/lib/Analysis/AnalysisDeclContext.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Analysis/AnalysisDeclContext.cpp	2023-06-05 20:12:47.596384779 +0200
@@ -142,7 +142,7 @@
 
 /// Returns true if \param VD is an Objective-C implicit 'self' parameter.
 static bool isSelfDecl(const VarDecl *VD) {
-  return isa<ImplicitParamDecl>(VD) && VD->getName() == "self";
+  return isa_and_nonnull<ImplicitParamDecl>(VD) && VD->getName() == "self";
 }
 
 const ImplicitParamDecl *AnalysisDeclContext::getSelfDecl() const {
@@ -169,8 +169,8 @@
     if (!LC.capturesVariable())
       continue;
 
-    VarDecl *VD = LC.getCapturedVar();
-    if (isSelfDecl(VD))
+    ValueDecl *VD = LC.getCapturedVar();
+    if (isSelfDecl(dyn_cast<VarDecl>(VD)))
       return dyn_cast<ImplicitParamDecl>(VD);
   }
 
diff -Naur llvm-project-15.0.7.src/clang/lib/AST/ASTImporter.cpp llvm-project-15.0.7.src.new/clang/lib/AST/ASTImporter.cpp
--- llvm-project-15.0.7.src/clang/lib/AST/ASTImporter.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/AST/ASTImporter.cpp	2023-06-05 20:12:47.590384726 +0200
@@ -1006,7 +1006,7 @@
 
 template <>
 Expected<LambdaCapture> ASTNodeImporter::import(const LambdaCapture &From) {
-  VarDecl *Var = nullptr;
+  ValueDecl *Var = nullptr;
   if (From.capturesVariable()) {
     if (auto VarOrErr = import(From.getCapturedVar()))
       Var = *VarOrErr;
diff -Naur llvm-project-15.0.7.src/clang/lib/AST/Decl.cpp llvm-project-15.0.7.src.new/clang/lib/AST/Decl.cpp
--- llvm-project-15.0.7.src/clang/lib/AST/Decl.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/AST/Decl.cpp	2023-06-05 20:12:47.591384735 +0200
@@ -4968,6 +4968,12 @@
          MostRecent->hasAttr<WeakRefAttr>() || isWeakImported();
 }
 
+bool ValueDecl::isInitCapture() const {
+  if (auto *Var = llvm::dyn_cast<VarDecl>(this))
+    return Var->isInitCapture();
+  return false;
+}
+
 void ImplicitParamDecl::anchor() {}
 
 ImplicitParamDecl *ImplicitParamDecl::Create(ASTContext &C, DeclContext *DC,
diff -Naur llvm-project-15.0.7.src/clang/lib/AST/DeclCXX.cpp llvm-project-15.0.7.src.new/clang/lib/AST/DeclCXX.cpp
--- llvm-project-15.0.7.src/clang/lib/AST/DeclCXX.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/AST/DeclCXX.cpp	2023-06-05 20:12:47.592384744 +0200
@@ -1570,8 +1570,8 @@
 }
 
 void CXXRecordDecl::getCaptureFields(
-       llvm::DenseMap<const VarDecl *, FieldDecl *> &Captures,
-       FieldDecl *&ThisCapture) const {
+    llvm::DenseMap<const ValueDecl *, FieldDecl *> &Captures,
+    FieldDecl *&ThisCapture) const {
   Captures.clear();
   ThisCapture = nullptr;
 
diff -Naur llvm-project-15.0.7.src/clang/lib/AST/ExprConstant.cpp llvm-project-15.0.7.src.new/clang/lib/AST/ExprConstant.cpp
--- llvm-project-15.0.7.src/clang/lib/AST/ExprConstant.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/AST/ExprConstant.cpp	2023-06-05 20:12:47.595384771 +0200
@@ -578,7 +578,7 @@
 
     /// LambdaCaptureFields - Mapping from captured variables/this to
     /// corresponding data members in the closure class.
-    llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;
+    llvm::DenseMap<const ValueDecl *, FieldDecl *> LambdaCaptureFields;
     FieldDecl *LambdaThisCaptureField;
 
     CallStackFrame(EvalInfo &Info, SourceLocation CallLoc,
diff -Naur llvm-project-15.0.7.src/clang/lib/AST/ExprCXX.cpp llvm-project-15.0.7.src.new/clang/lib/AST/ExprCXX.cpp
--- llvm-project-15.0.7.src/clang/lib/AST/ExprCXX.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/AST/ExprCXX.cpp	2023-06-05 20:12:47.592384744 +0200
@@ -1087,7 +1087,7 @@
     : Expr(SC, Empty), NumArgs(NumArgs) {}
 
 LambdaCapture::LambdaCapture(SourceLocation Loc, bool Implicit,
-                             LambdaCaptureKind Kind, VarDecl *Var,
+                             LambdaCaptureKind Kind, ValueDecl *Var,
                              SourceLocation EllipsisLoc)
     : DeclAndBits(Var, 0), Loc(Loc), EllipsisLoc(EllipsisLoc) {
   unsigned Bits = 0;
@@ -1211,8 +1211,8 @@
 }
 
 bool LambdaExpr::isInitCapture(const LambdaCapture *C) const {
-  return (C->capturesVariable() && C->getCapturedVar()->isInitCapture() &&
-          (getCallOperator() == C->getCapturedVar()->getDeclContext()));
+  return C->capturesVariable() && C->getCapturedVar()->isInitCapture() &&
+         getCallOperator() == C->getCapturedVar()->getDeclContext();
 }
 
 LambdaExpr::capture_iterator LambdaExpr::capture_begin() const {
diff -Naur llvm-project-15.0.7.src/clang/lib/AST/StmtPrinter.cpp llvm-project-15.0.7.src.new/clang/lib/AST/StmtPrinter.cpp
--- llvm-project-15.0.7.src/clang/lib/AST/StmtPrinter.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/AST/StmtPrinter.cpp	2023-06-05 20:12:47.596384779 +0200
@@ -2164,7 +2164,8 @@
       OS << "...";
 
     if (Node->isInitCapture(C)) {
-      VarDecl *D = C->getCapturedVar();
+      // Init captures are always VarDecl.
+      auto *D = cast<VarDecl>(C->getCapturedVar());
 
       llvm::StringRef Pre;
       llvm::StringRef Post;
diff -Naur llvm-project-15.0.7.src/clang/lib/CodeGen/CGDebugInfo.cpp llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGDebugInfo.cpp
--- llvm-project-15.0.7.src/clang/lib/CodeGen/CGDebugInfo.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGDebugInfo.cpp	2023-06-05 20:12:47.597384788 +0200
@@ -1497,7 +1497,7 @@
     if (C.capturesVariable()) {
       SourceLocation Loc = C.getLocation();
       assert(!Field->isBitField() && "lambdas don't have bitfield members!");
-      VarDecl *V = C.getCapturedVar();
+      ValueDecl *V = C.getCapturedVar();
       StringRef VName = V->getName();
       llvm::DIFile *VUnit = getOrCreateFile(Loc);
       auto Align = getDeclAlignIfRequired(V, CGM.getContext());
diff -Naur llvm-project-15.0.7.src/clang/lib/CodeGen/CGExpr.cpp llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGExpr.cpp
--- llvm-project-15.0.7.src/clang/lib/CodeGen/CGExpr.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGExpr.cpp	2023-06-05 20:12:47.599384806 +0200
@@ -2940,8 +2940,13 @@
   // FIXME: While we're emitting a binding from an enclosing scope, all other
   // DeclRefExprs we see should be implicitly treated as if they also refer to
   // an enclosing scope.
-  if (const auto *BD = dyn_cast<BindingDecl>(ND))
+  if (const auto *BD = dyn_cast<BindingDecl>(ND)) {
+    if (E->refersToEnclosingVariableOrCapture()) {
+      auto *FD = LambdaCaptureFields.lookup(BD);
+      return EmitCapturedFieldLValue(*this, FD, CXXABIThisValue);
+    }
     return EmitLValue(BD->getBinding());
+  }
 
   // We can form DeclRefExprs naming GUID declarations when reconstituting
   // non-type template parameters into expressions.
diff -Naur llvm-project-15.0.7.src/clang/lib/CodeGen/CGOpenMPRuntime.cpp llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGOpenMPRuntime.cpp
--- llvm-project-15.0.7.src/clang/lib/CodeGen/CGOpenMPRuntime.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGOpenMPRuntime.cpp	2023-06-05 20:12:47.601384824 +0200
@@ -409,7 +409,7 @@
 /// RAII for emitting code of OpenMP constructs.
 class InlinedOpenMPRegionRAII {
   CodeGenFunction &CGF;
-  llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;
+  llvm::DenseMap<const ValueDecl *, FieldDecl *> LambdaCaptureFields;
   FieldDecl *LambdaThisCaptureField = nullptr;
   const CodeGen::CGBlockInfo *BlockInfo = nullptr;
   bool NoInheritance = false;
@@ -8947,7 +8947,7 @@
     Address VDAddr(Arg, CGF.ConvertTypeForMem(VDType),
                    CGF.getContext().getDeclAlign(VD));
     LValue VDLVal = CGF.MakeAddrLValue(VDAddr, VDType);
-    llvm::DenseMap<const VarDecl *, FieldDecl *> Captures;
+    llvm::DenseMap<const ValueDecl *, FieldDecl *> Captures;
     FieldDecl *ThisCapture = nullptr;
     RD->getCaptureFields(Captures, ThisCapture);
     if (ThisCapture) {
@@ -8969,7 +8969,7 @@
     for (const LambdaCapture &LC : RD->captures()) {
       if (!LC.capturesVariable())
         continue;
-      const VarDecl *VD = LC.getCapturedVar();
+      const VarDecl *VD = cast<VarDecl>(LC.getCapturedVar());
       if (LC.getCaptureKind() != LCK_ByRef && !VD->getType()->isPointerType())
         continue;
       auto It = Captures.find(VD);
diff -Naur llvm-project-15.0.7.src/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp
--- llvm-project-15.0.7.src/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp	2023-06-05 20:12:47.602384833 +0200
@@ -444,9 +444,8 @@
       markAsEscaped(VD);
     if (isa<OMPCapturedExprDecl>(VD))
       VisitValueDecl(VD);
-    else if (const auto *VarD = dyn_cast<VarDecl>(VD))
-      if (VarD->isInitCapture())
-        VisitValueDecl(VD);
+    else if (VD->isInitCapture())
+      VisitValueDecl(VD);
   }
   void VisitUnaryOperator(const UnaryOperator *E) {
     if (!E)
@@ -3810,7 +3809,7 @@
     else
       VDLVal = CGF.MakeAddrLValue(
           VDAddr, VD->getType().getCanonicalType().getNonReferenceType());
-    llvm::DenseMap<const VarDecl *, FieldDecl *> Captures;
+    llvm::DenseMap<const ValueDecl *, FieldDecl *> Captures;
     FieldDecl *ThisCapture = nullptr;
     RD->getCaptureFields(Captures, ThisCapture);
     if (ThisCapture && CGF.CapturedStmtInfo->isCXXThisExprCaptured()) {
@@ -3822,13 +3821,15 @@
     for (const LambdaCapture &LC : RD->captures()) {
       if (LC.getCaptureKind() != LCK_ByRef)
         continue;
-      const VarDecl *VD = LC.getCapturedVar();
-      if (!CS->capturesVariable(VD))
+      const ValueDecl *VD = LC.getCapturedVar();
+      // FIXME: For now VD is always a VarDecl because OpenMP does not support
+      //  capturing structured bindings in lambdas yet.
+      if (!CS->capturesVariable(cast<VarDecl>(VD)))
         continue;
       auto It = Captures.find(VD);
       assert(It != Captures.end() && "Found lambda capture without field.");
       LValue VarLVal = CGF.EmitLValueForFieldInitialization(VDLVal, It->second);
-      Address VDAddr = CGF.GetAddrOfLocalVar(VD);
+      Address VDAddr = CGF.GetAddrOfLocalVar(cast<VarDecl>(VD));
       if (VD->getType().getCanonicalType()->isReferenceType())
         VDAddr = CGF.EmitLoadOfReferenceLValue(VDAddr,
                                                VD->getType().getCanonicalType())
diff -Naur llvm-project-15.0.7.src/clang/lib/CodeGen/CodeGenFunction.h llvm-project-15.0.7.src.new/clang/lib/CodeGen/CodeGenFunction.h
--- llvm-project-15.0.7.src/clang/lib/CodeGen/CodeGenFunction.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/CodeGen/CodeGenFunction.h	2023-06-05 20:12:47.603384842 +0200
@@ -609,7 +609,7 @@
   const CodeGen::CGBlockInfo *BlockInfo = nullptr;
   llvm::Value *BlockPointer = nullptr;
 
-  llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;
+  llvm::DenseMap<const ValueDecl *, FieldDecl *> LambdaCaptureFields;
   FieldDecl *LambdaThisCaptureField = nullptr;
 
   /// A mapping from NRVO variables to the flags used to indicate
diff -Naur llvm-project-15.0.7.src/clang/lib/Sema/SemaDecl.cpp llvm-project-15.0.7.src.new/clang/lib/Sema/SemaDecl.cpp
--- llvm-project-15.0.7.src/clang/lib/Sema/SemaDecl.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Sema/SemaDecl.cpp	2023-06-05 20:12:47.607384877 +0200
@@ -14678,7 +14678,7 @@
   auto I = LambdaClass->field_begin();
   for (const auto &C : LambdaClass->captures()) {
     if (C.capturesVariable()) {
-      VarDecl *VD = C.getCapturedVar();
+      ValueDecl *VD = C.getCapturedVar();
       if (VD->isInitCapture())
         S.CurrentInstantiationScope->InstantiatedLocal(VD, VD);
       const bool ByRef = C.getCaptureKind() == LCK_ByRef;
diff -Naur llvm-project-15.0.7.src/clang/lib/Sema/SemaExpr.cpp llvm-project-15.0.7.src.new/clang/lib/Sema/SemaExpr.cpp
--- llvm-project-15.0.7.src/clang/lib/Sema/SemaExpr.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Sema/SemaExpr.cpp	2023-06-05 20:12:47.630385081 +0200
@@ -2082,9 +2082,8 @@
                        NestedNameSpecifierLoc NNS, NamedDecl *FoundD,
                        SourceLocation TemplateKWLoc,
                        const TemplateArgumentListInfo *TemplateArgs) {
-  bool RefersToCapturedVariable =
-      isa<VarDecl>(D) &&
-      NeedToCaptureVariable(cast<VarDecl>(D), NameInfo.getLoc());
+  bool RefersToCapturedVariable = isa<VarDecl, BindingDecl>(D) &&
+                                  NeedToCaptureVariable(D, NameInfo.getLoc());
 
   DeclRefExpr *E = DeclRefExpr::Create(
       Context, NNS, TemplateKWLoc, D, RefersToCapturedVariable, NameInfo, Ty,
@@ -3252,8 +3251,9 @@
   return ULE;
 }
 
-static void diagnoseUncapturableValueReference(Sema &S, SourceLocation loc,
-                                               ValueDecl *var);
+static void diagnoseUncapturableValueReferenceOrBinding(Sema &S,
+                                                        SourceLocation loc,
+                                                        ValueDecl *var);
 
 /// Complete semantic analysis for a reference to the given declaration.
 ExprResult Sema::BuildDeclarationNameExpr(
@@ -3411,20 +3411,11 @@
     break;
   }
 
-  case Decl::Binding: {
+  case Decl::Binding:
     // These are always lvalues.
     valueKind = VK_LValue;
     type = type.getNonReferenceType();
-    // FIXME: Support lambda-capture of BindingDecls, once CWG actually
-    // decides how that's supposed to work.
-    auto *BD = cast<BindingDecl>(VD);
-    if (BD->getDeclContext() != CurContext) {
-      auto *DD = dyn_cast_or_null<VarDecl>(BD->getDecomposedDecl());
-      if (DD && DD->hasLocalStorage())
-        diagnoseUncapturableValueReference(*this, Loc, BD);
-    }
     break;
-  }
 
   case Decl::Function: {
     if (unsigned BID = cast<FunctionDecl>(VD)->getBuiltinID()) {
@@ -16411,8 +16402,9 @@
   for (Capture &Cap : BSI->Captures) {
     if (Cap.isInvalid() || Cap.isThisCapture())
       continue;
-
-    VarDecl *Var = Cap.getVariable();
+    // Cap.getVariable() is always a VarDecl because
+    // blocks cannot capture structured bindings or other ValueDecl kinds.
+    auto *Var = cast<VarDecl>(Cap.getVariable());
     Expr *CopyExpr = nullptr;
     if (getLangOpts().CPlusPlus && Cap.isCopyCapture()) {
       if (const RecordType *Record =
@@ -18248,8 +18240,8 @@
   MarkVarDeclODRUsed(Capture, Loc, *this, &CapturingScopeIndex);
 }
 
-static void diagnoseUncapturableValueReference(Sema &S, SourceLocation loc,
-                                               ValueDecl *var) {
+void diagnoseUncapturableValueReferenceOrBinding(Sema &S, SourceLocation loc,
+                                                 ValueDecl *var) {
   DeclContext *VarDC = var->getDeclContext();
 
   //  If the parameter still belongs to the translation unit, then
@@ -18289,12 +18281,12 @@
   // capture.
 }
 
-
-static bool isVariableAlreadyCapturedInScopeInfo(CapturingScopeInfo *CSI, VarDecl *Var,
-                                      bool &SubCapturesAreNested,
-                                      QualType &CaptureType,
-                                      QualType &DeclRefType) {
-   // Check whether we've already captured it.
+static bool isVariableAlreadyCapturedInScopeInfo(CapturingScopeInfo *CSI,
+                                                 ValueDecl *Var,
+                                                 bool &SubCapturesAreNested,
+                                                 QualType &CaptureType,
+                                                 QualType &DeclRefType) {
+  // Check whether we've already captured it.
   if (CSI->CaptureMap.count(Var)) {
     // If we found a capture, any subcaptures are nested.
     SubCapturesAreNested = true;
@@ -18321,14 +18313,22 @@
 
 // Only block literals, captured statements, and lambda expressions can
 // capture; other scopes don't work.
-static DeclContext *getParentOfCapturingContextOrNull(DeclContext *DC, VarDecl *Var,
-                                 SourceLocation Loc,
-                                 const bool Diagnose, Sema &S) {
+static DeclContext *getParentOfCapturingContextOrNull(DeclContext *DC,
+                                                      ValueDecl *Var,
+                                                      SourceLocation Loc,
+                                                      const bool Diagnose,
+                                                      Sema &S) {
   if (isa<BlockDecl>(DC) || isa<CapturedDecl>(DC) || isLambdaCallOperator(DC))
     return getLambdaAwareParentOfDeclContext(DC);
-  else if (Var->hasLocalStorage()) {
-    if (Diagnose)
-       diagnoseUncapturableValueReference(S, Loc, Var);
+
+  ValueDecl *Underlying = Var;
+  auto *BD = dyn_cast_or_null<BindingDecl>(Var);
+  if (BD)
+    Underlying = BD->getDecomposedDecl();
+
+  if (auto *VD = dyn_cast<VarDecl>(Underlying)) {
+    if (VD->hasLocalStorage() && Diagnose)
+      diagnoseUncapturableValueReferenceOrBinding(S, Loc, Var);
   }
   return nullptr;
 }
@@ -18336,9 +18336,12 @@
 // Certain capturing entities (lambdas, blocks etc.) are not allowed to capture
 // certain types of variables (unnamed, variably modified types etc.)
 // so check for eligibility.
-static bool isVariableCapturable(CapturingScopeInfo *CSI, VarDecl *Var,
-                                 SourceLocation Loc,
-                                 const bool Diagnose, Sema &S) {
+static bool isVariableCapturable(CapturingScopeInfo *CSI, ValueDecl *Var,
+                                 SourceLocation Loc, const bool Diagnose,
+                                 Sema &S) {
+
+  assert((isa<VarDecl, BindingDecl>(Var)) &&
+         "Only variables and structured bindings can be captured");
 
   bool IsBlock = isa<BlockScopeInfo>(CSI);
   bool IsLambda = isa<LambdaScopeInfo>(CSI);
@@ -18395,17 +18398,28 @@
     return false;
   }
 
+  if (isa<BindingDecl>(Var)) {
+    if (!IsLambda || !S.getLangOpts().CPlusPlus) {
+      if (Diagnose)
+        diagnoseUncapturableValueReferenceOrBinding(S, Loc, Var);
+      return false;
+    } else if (Diagnose && S.getLangOpts().CPlusPlus) {
+      S.Diag(Loc, S.LangOpts.CPlusPlus20
+                      ? diag::warn_cxx17_compat_capture_binding
+                      : diag::ext_capture_binding)
+          << Var;
+      S.Diag(Var->getLocation(), diag::note_entity_declared_at) << Var;
+    }
+  }
+
   return true;
 }
 
 // Returns true if the capture by block was successful.
-static bool captureInBlock(BlockScopeInfo *BSI, VarDecl *Var,
-                                 SourceLocation Loc,
-                                 const bool BuildAndDiagnose,
-                                 QualType &CaptureType,
-                                 QualType &DeclRefType,
-                                 const bool Nested,
-                                 Sema &S, bool Invalid) {
+static bool captureInBlock(BlockScopeInfo *BSI, ValueDecl *Var,
+                           SourceLocation Loc, const bool BuildAndDiagnose,
+                           QualType &CaptureType, QualType &DeclRefType,
+                           const bool Nested, Sema &S, bool Invalid) {
   bool ByRef = false;
 
   // Blocks are not allowed to capture arrays, excepting OpenCL.
@@ -18469,10 +18483,9 @@
   return !Invalid;
 }
 
-
 /// Capture the given variable in the captured region.
 static bool captureInCapturedRegion(
-    CapturedRegionScopeInfo *RSI, VarDecl *Var, SourceLocation Loc,
+    CapturedRegionScopeInfo *RSI, ValueDecl *Var, SourceLocation Loc,
     const bool BuildAndDiagnose, QualType &CaptureType, QualType &DeclRefType,
     const bool RefersToCapturedVariable, Sema::TryCaptureKind Kind,
     bool IsTopScope, Sema &S, bool Invalid) {
@@ -18511,16 +18524,12 @@
 }
 
 /// Capture the given variable in the lambda.
-static bool captureInLambda(LambdaScopeInfo *LSI,
-                            VarDecl *Var,
-                            SourceLocation Loc,
-                            const bool BuildAndDiagnose,
-                            QualType &CaptureType,
-                            QualType &DeclRefType,
+static bool captureInLambda(LambdaScopeInfo *LSI, ValueDecl *Var,
+                            SourceLocation Loc, const bool BuildAndDiagnose,
+                            QualType &CaptureType, QualType &DeclRefType,
                             const bool RefersToCapturedVariable,
                             const Sema::TryCaptureKind Kind,
-                            SourceLocation EllipsisLoc,
-                            const bool IsTopScope,
+                            SourceLocation EllipsisLoc, const bool IsTopScope,
                             Sema &S, bool Invalid) {
   // Determine whether we are capturing by reference or by value.
   bool ByRef = false;
@@ -18530,6 +18539,16 @@
     ByRef = (LSI->ImpCaptureStyle == LambdaScopeInfo::ImpCap_LambdaByref);
   }
 
+  BindingDecl *BD = dyn_cast<BindingDecl>(Var);
+  // FIXME: We should support capturing structured bindings in OpenMP.
+  if (!Invalid && BD && S.LangOpts.OpenMP) {
+    if (BuildAndDiagnose) {
+      S.Diag(Loc, diag::err_capture_binding_openmp) << Var;
+      S.Diag(Var->getLocation(), diag::note_entity_declared_at) << Var;
+    }
+    Invalid = true;
+  }
+
   // Compute the type of the field that will capture this variable.
   if (ByRef) {
     // C++11 [expr.prim.lambda]p15:
@@ -18610,7 +18629,8 @@
   return !Invalid;
 }
 
-static bool canCaptureVariableByCopy(VarDecl *Var, const ASTContext &Context) {
+static bool canCaptureVariableByCopy(ValueDecl *Var,
+                                     const ASTContext &Context) {
   // Offer a Copy fix even if the type is dependent.
   if (Var->getType()->isDependentType())
     return true;
@@ -18636,7 +18656,7 @@
 /// standard, for example we can't emit a default copy capture fix-it if we
 /// already explicitly copy capture capture another variable.
 static void buildLambdaCaptureFixit(Sema &Sema, LambdaScopeInfo *LSI,
-                                    VarDecl *Var) {
+                                    ValueDecl *Var) {
   assert(LSI->ImpCaptureStyle == CapturingScopeInfo::ImpCap_None);
   // Don't offer Capture by copy of default capture by copy fixes if Var is
   // known not to be copy constructible.
@@ -18712,14 +18732,21 @@
 }
 
 bool Sema::tryCaptureVariable(
-    VarDecl *Var, SourceLocation ExprLoc, TryCaptureKind Kind,
+    ValueDecl *Var, SourceLocation ExprLoc, TryCaptureKind Kind,
     SourceLocation EllipsisLoc, bool BuildAndDiagnose, QualType &CaptureType,
     QualType &DeclRefType, const unsigned *const FunctionScopeIndexToStopAt) {
   // An init-capture is notionally from the context surrounding its
   // declaration, but its parent DC is the lambda class.
   DeclContext *VarDC = Var->getDeclContext();
-  if (Var->isInitCapture())
-    VarDC = VarDC->getParent();
+  const auto *VD = dyn_cast<VarDecl>(Var);
+  if (VD) {
+    if (VD->isInitCapture())
+      VarDC = VarDC->getParent();
+  } else {
+    VD = dyn_cast<DecompositionDecl>(
+        cast<BindingDecl>(Var)->getDecomposedDecl());
+  }
+  assert(VD && "Cannot capture a null variable");
 
   DeclContext *DC = CurContext;
   const unsigned MaxFunctionScopesIndex = FunctionScopeIndexToStopAt
@@ -18741,12 +18768,14 @@
 
   // Capture global variables if it is required to use private copy of this
   // variable.
-  bool IsGlobal = !Var->hasLocalStorage();
+  bool IsGlobal = !VD->hasLocalStorage();
   if (IsGlobal &&
       !(LangOpts.OpenMP && isOpenMPCapturedDecl(Var, /*CheckScopeInfo=*/true,
                                                 MaxFunctionScopesIndex)))
     return true;
-  Var = Var->getCanonicalDecl();
+
+  if (isa<VarDecl>(Var))
+    Var = cast<VarDecl>(Var->getCanonicalDecl());
 
   // Walk up the stack to determine whether we can capture the variable,
   // performing the "simple" checks that don't depend on type. We stop when
@@ -18802,7 +18831,7 @@
           Diag(LSI->Lambda->getBeginLoc(), diag::note_lambda_decl);
           buildLambdaCaptureFixit(*this, LSI, Var);
         } else
-          diagnoseUncapturableValueReference(*this, ExprLoc, Var);
+          diagnoseUncapturableValueReferenceOrBinding(*this, ExprLoc, Var);
       }
       return true;
     }
@@ -18950,7 +18979,7 @@
   return Invalid;
 }
 
-bool Sema::tryCaptureVariable(VarDecl *Var, SourceLocation Loc,
+bool Sema::tryCaptureVariable(ValueDecl *Var, SourceLocation Loc,
                               TryCaptureKind Kind, SourceLocation EllipsisLoc) {
   QualType CaptureType;
   QualType DeclRefType;
@@ -18959,7 +18988,7 @@
                             DeclRefType, nullptr);
 }
 
-bool Sema::NeedToCaptureVariable(VarDecl *Var, SourceLocation Loc) {
+bool Sema::NeedToCaptureVariable(ValueDecl *Var, SourceLocation Loc) {
   QualType CaptureType;
   QualType DeclRefType;
   return !tryCaptureVariable(Var, Loc, TryCapture_Implicit, SourceLocation(),
@@ -18967,7 +18996,7 @@
                              DeclRefType, nullptr);
 }
 
-QualType Sema::getCapturedDeclRefType(VarDecl *Var, SourceLocation Loc) {
+QualType Sema::getCapturedDeclRefType(ValueDecl *Var, SourceLocation Loc) {
   QualType CaptureType;
   QualType DeclRefType;
 
@@ -19563,6 +19592,24 @@
   }
 }
 
+static void DoMarkBindingDeclReferenced(Sema &SemaRef, SourceLocation Loc,
+                                        BindingDecl *BD) {
+  BD->setReferenced();
+
+  if (BD->isInvalidDecl())
+    return;
+
+  OdrUseContext OdrUse = isOdrUseContext(SemaRef);
+  if (OdrUse == OdrUseContext::Used) {
+    QualType CaptureType, DeclRefType;
+    SemaRef.tryCaptureVariable(BD, Loc, Sema::TryCapture_Implicit,
+                               /*EllipsisLoc*/ SourceLocation(),
+                               /*BuildAndDiagnose*/ true, CaptureType,
+                               DeclRefType,
+                               /*FunctionScopeIndexToStopAt*/ nullptr);
+  }
+}
+
 /// Mark a variable referenced, and check whether it is odr-used
 /// (C++ [basic.def.odr]p2, C99 6.9p3).  Note that this should not be
 /// used directly for normal expressions referring to VarDecl.
@@ -19582,6 +19629,11 @@
     return;
   }
 
+  if (BindingDecl *Decl = dyn_cast<BindingDecl>(D)) {
+    DoMarkBindingDeclReferenced(SemaRef, Loc, Decl);
+    return;
+  }
+
   SemaRef.MarkAnyDeclReferenced(Loc, D, MightBeOdrUse);
 
   // If this is a call to a method via a cast, also mark the method in the
diff -Naur llvm-project-15.0.7.src/clang/lib/Sema/SemaInit.cpp llvm-project-15.0.7.src.new/clang/lib/Sema/SemaInit.cpp
--- llvm-project-15.0.7.src/clang/lib/Sema/SemaInit.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Sema/SemaInit.cpp	2023-06-05 20:12:47.614384939 +0200
@@ -7846,7 +7846,7 @@
           break;
         // FIXME: We can't easily tell apart an init-capture from a nested
         // capture of an init-capture.
-        const VarDecl *VD = Elem.Capture->getCapturedVar();
+        const ValueDecl *VD = Elem.Capture->getCapturedVar();
         Diag(Elem.Capture->getLocation(), diag::note_lambda_capture_initializer)
             << VD << VD->isInitCapture() << Elem.Capture->isExplicit()
             << (Elem.Capture->getCaptureKind() == LCK_ByRef) << VD
diff -Naur llvm-project-15.0.7.src/clang/lib/Sema/SemaLambda.cpp llvm-project-15.0.7.src.new/clang/lib/Sema/SemaLambda.cpp
--- llvm-project-15.0.7.src/clang/lib/Sema/SemaLambda.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Sema/SemaLambda.cpp	2023-06-05 20:12:47.615384948 +0200
@@ -1088,7 +1088,7 @@
     if (C->Init.isInvalid())
       continue;
 
-    VarDecl *Var = nullptr;
+    ValueDecl *Var = nullptr;
     if (C->Init.isUsable()) {
       Diag(C->Loc, getLangOpts().CPlusPlus14
                        ? diag::warn_cxx11_compat_init_capture
@@ -1166,7 +1166,10 @@
           continue;
       }
 
-      Var = R.getAsSingle<VarDecl>();
+      if (auto *BD = R.getAsSingle<BindingDecl>())
+        Var = BD;
+      else
+        Var = R.getAsSingle<VarDecl>();
       if (Var && DiagnoseUseOfDecl(Var, C->Loc))
         continue;
     }
@@ -1200,7 +1203,13 @@
     if (Var->isInvalidDecl())
       continue;
 
-    if (!Var->hasLocalStorage()) {
+    VarDecl *Underlying;
+    if (auto *BD = dyn_cast<BindingDecl>(Var))
+      Underlying = dyn_cast<VarDecl>(BD->getDecomposedDecl());
+    else
+      Underlying = cast<VarDecl>(Var);
+
+    if (!Underlying->hasLocalStorage()) {
       Diag(C->Loc, diag::err_capture_non_automatic_variable) << C->Id;
       Diag(Var->getLocation(), diag::note_previous_decl) << C->Id;
       continue;
@@ -1224,7 +1233,7 @@
     }
 
     if (C->Init.isUsable()) {
-      addInitCapture(LSI, Var);
+      addInitCapture(LSI, cast<VarDecl>(Var));
     } else {
       TryCaptureKind Kind = C->Kind == LCK_ByRef ? TryCapture_ExplicitByRef :
                                                    TryCapture_ExplicitByVal;
@@ -1574,7 +1583,7 @@
 
   // An init-capture is initialized directly from its stored initializer.
   if (Cap.isInitCapture())
-    return Cap.getVariable()->getInit();
+    return cast<VarDecl>(Cap.getVariable())->getInit();
 
   // For anything else, build an initialization expression. For an implicit
   // capture, the capture notionally happens at the capture-default, so use
@@ -1605,7 +1614,7 @@
       Init = This;
   } else {
     assert(Cap.isVariableCapture() && "unknown kind of capture");
-    VarDecl *Var = Cap.getVariable();
+    ValueDecl *Var = Cap.getVariable();
     Name = Var->getIdentifier();
     Init = BuildDeclarationNameExpr(
       CXXScopeSpec(), DeclarationNameInfo(Var->getDeclName(), Loc), Var);
@@ -1654,7 +1663,7 @@
 
 bool Sema::CaptureHasSideEffects(const Capture &From) {
   if (From.isInitCapture()) {
-    Expr *Init = From.getVariable()->getInit();
+    Expr *Init = cast<VarDecl>(From.getVariable())->getInit();
     if (Init && Init->HasSideEffects(Context))
       return true;
   }
@@ -1704,9 +1713,9 @@
 
   TypeSourceInfo *TSI = nullptr;
   if (Capture.isVariableCapture()) {
-    auto *Var = Capture.getVariable();
-    if (Var->isInitCapture())
-      TSI = Capture.getVariable()->getTypeSourceInfo();
+    const auto *Var = dyn_cast_or_null<VarDecl>(Capture.getVariable());
+    if (Var && Var->isInitCapture())
+      TSI = Var->getTypeSourceInfo();
   }
 
   // FIXME: Should we really be doing this? A null TypeSourceInfo seems more
@@ -1854,7 +1863,7 @@
           return LambdaCapture(From.getLocation(), IsImplicit, LCK_VLAType);
         } else {
           assert(From.isVariableCapture() && "unknown kind of capture");
-          VarDecl *Var = From.getVariable();
+          ValueDecl *Var = From.getVariable();
           LambdaCaptureKind Kind =
               From.isCopyCapture() ? LCK_ByCopy : LCK_ByRef;
           return LambdaCapture(From.getLocation(), IsImplicit, Kind, Var,
diff -Naur llvm-project-15.0.7.src/clang/lib/Sema/SemaOpenMP.cpp llvm-project-15.0.7.src.new/clang/lib/Sema/SemaOpenMP.cpp
--- llvm-project-15.0.7.src/clang/lib/Sema/SemaOpenMP.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Sema/SemaOpenMP.cpp	2023-06-05 20:12:47.620384992 +0200
@@ -4677,12 +4677,12 @@
       DSAStack->setForceCaptureByReferenceInTargetExecutable(
           /*V=*/true);
       if (RD->isLambda()) {
-        llvm::DenseMap<const VarDecl *, FieldDecl *> Captures;
+        llvm::DenseMap<const ValueDecl *, FieldDecl *> Captures;
         FieldDecl *ThisCapture;
         RD->getCaptureFields(Captures, ThisCapture);
         for (const LambdaCapture &LC : RD->captures()) {
           if (LC.getCaptureKind() == LCK_ByRef) {
-            VarDecl *VD = LC.getCapturedVar();
+            VarDecl *VD = cast<VarDecl>(LC.getCapturedVar());
             DeclContext *VDC = VD->getDeclContext();
             if (!VDC->Encloses(CurContext))
               continue;
diff -Naur llvm-project-15.0.7.src/clang/lib/Sema/SemaStmt.cpp llvm-project-15.0.7.src.new/clang/lib/Sema/SemaStmt.cpp
--- llvm-project-15.0.7.src/clang/lib/Sema/SemaStmt.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Sema/SemaStmt.cpp	2023-06-05 20:12:47.621385001 +0200
@@ -4695,11 +4695,11 @@
       if (S.getLangOpts().OpenMP && RSI->CapRegionKind == CR_OpenMP)
         S.setOpenMPCaptureKind(Field, Cap.getVariable(), RSI->OpenMPLevel);
 
-      Captures.push_back(CapturedStmt::Capture(Cap.getLocation(),
-                                               Cap.isReferenceCapture()
-                                                   ? CapturedStmt::VCK_ByRef
-                                                   : CapturedStmt::VCK_ByCopy,
-                                               Cap.getVariable()));
+      Captures.push_back(CapturedStmt::Capture(
+          Cap.getLocation(),
+          Cap.isReferenceCapture() ? CapturedStmt::VCK_ByRef
+                                   : CapturedStmt::VCK_ByCopy,
+          cast<VarDecl>(Cap.getVariable())));
     }
     CaptureInits.push_back(Init.get());
   }
diff -Naur llvm-project-15.0.7.src/clang/lib/Sema/TreeTransform.h llvm-project-15.0.7.src.new/clang/lib/Sema/TreeTransform.h
--- llvm-project-15.0.7.src/clang/lib/Sema/TreeTransform.h	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Sema/TreeTransform.h	2023-06-05 20:12:47.623385019 +0200
@@ -12990,7 +12990,7 @@
       continue;
 
     TransformedInitCapture &Result = InitCaptures[C - E->capture_begin()];
-    VarDecl *OldVD = C->getCapturedVar();
+    auto *OldVD = cast<VarDecl>(C->getCapturedVar());
 
     auto SubstInitCapture = [&](SourceLocation EllipsisLoc,
                                 Optional<unsigned> NumExpansions) {
@@ -13007,7 +13007,8 @@
           getSema().buildLambdaInitCaptureInitialization(
               C->getLocation(), OldVD->getType()->isReferenceType(),
               EllipsisLoc, NumExpansions, OldVD->getIdentifier(),
-              C->getCapturedVar()->getInitStyle() != VarDecl::CInit,
+              cast<VarDecl>(C->getCapturedVar())->getInitStyle() !=
+                  VarDecl::CInit,
               NewExprInit);
       Result.Expansions.push_back(
           InitCaptureInfoTy(NewExprInit, NewInitCaptureType));
@@ -13174,7 +13175,7 @@
     if (E->isInitCapture(C)) {
       TransformedInitCapture &NewC = InitCaptures[C - E->capture_begin()];
 
-      VarDecl *OldVD = C->getCapturedVar();
+      auto *OldVD = cast<VarDecl>(C->getCapturedVar());
       llvm::SmallVector<Decl*, 4> NewVDs;
 
       for (InitCaptureInfoTy &Info : NewC.Expansions) {
@@ -13229,7 +13230,7 @@
         // The transform has determined that we should perform an expansion;
         // transform and capture each of the arguments.
         // expansion of the pattern. Do so.
-        VarDecl *Pack = C->getCapturedVar();
+        auto *Pack = cast<VarDecl>(C->getCapturedVar());
         for (unsigned I = 0; I != *NumExpansions; ++I) {
           Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(getSema(), I);
           VarDecl *CapturedVar
diff -Naur llvm-project-15.0.7.src/clang/lib/Serialization/ASTWriter.cpp llvm-project-15.0.7.src.new/clang/lib/Serialization/ASTWriter.cpp
--- llvm-project-15.0.7.src/clang/lib/Serialization/ASTWriter.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/Serialization/ASTWriter.cpp	2023-06-05 20:12:47.623385019 +0200
@@ -5786,7 +5786,7 @@
         break;
       case LCK_ByCopy:
       case LCK_ByRef:
-        VarDecl *Var =
+        ValueDecl *Var =
             Capture.capturesVariable() ? Capture.getCapturedVar() : nullptr;
         AddDeclRef(Var);
         AddSourceLocation(Capture.isPackExpansion() ? Capture.getEllipsisLoc()
diff -Naur llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp
--- llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Checkers/DeadStoresChecker.cpp	2023-06-05 20:12:47.623385019 +0200
@@ -504,7 +504,7 @@
   // Treat local variables captured by reference in C++ lambdas as escaped.
   void findLambdaReferenceCaptures(const LambdaExpr *LE)  {
     const CXXRecordDecl *LambdaClass = LE->getLambdaClass();
-    llvm::DenseMap<const VarDecl *, FieldDecl *> CaptureFields;
+    llvm::DenseMap<const ValueDecl *, FieldDecl *> CaptureFields;
     FieldDecl *ThisCaptureField;
     LambdaClass->getCaptureFields(CaptureFields, ThisCaptureField);
 
@@ -512,14 +512,14 @@
       if (!C.capturesVariable())
         continue;
 
-      VarDecl *VD = C.getCapturedVar();
+      ValueDecl *VD = C.getCapturedVar();
       const FieldDecl *FD = CaptureFields[VD];
-      if (!FD)
+      if (!FD || !isa<VarDecl>(VD))
         continue;
 
       // If the capture field is a reference type, it is capture-by-reference.
       if (FD->getType()->isReferenceType())
-        Escaped.insert(VD);
+        Escaped.insert(cast<VarDecl>(VD));
     }
   }
 };
diff -Naur llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLambdaCapturesChecker.cpp llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLambdaCapturesChecker.cpp
--- llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLambdaCapturesChecker.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLambdaCapturesChecker.cpp	2023-06-05 20:12:47.624385028 +0200
@@ -57,7 +57,7 @@
   void visitLambdaExpr(LambdaExpr *L) const {
     for (const LambdaCapture &C : L->captures()) {
       if (C.capturesVariable()) {
-        VarDecl *CapturedVar = C.getCapturedVar();
+        ValueDecl *CapturedVar = C.getCapturedVar();
         if (auto *CapturedVarType = CapturedVar->getType().getTypePtrOrNull()) {
           Optional<bool> IsUncountedPtr = isUncountedPtr(CapturedVarType);
           if (IsUncountedPtr && *IsUncountedPtr) {
@@ -68,7 +68,7 @@
     }
   }
 
-  void reportBug(const LambdaCapture &Capture, VarDecl *CapturedVar,
+  void reportBug(const LambdaCapture &Capture, ValueDecl *CapturedVar,
                  const Type *T) const {
     assert(CapturedVar);
 
diff -Naur llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp
--- llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp	2023-06-05 20:12:47.624385028 +0200
@@ -2732,7 +2732,7 @@
         MD->getParent()->isLambda()) {
       // Lookup the field of the lambda.
       const CXXRecordDecl *CXXRec = MD->getParent();
-      llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;
+      llvm::DenseMap<const ValueDecl *, FieldDecl *> LambdaCaptureFields;
       FieldDecl *LambdaThisCaptureField;
       CXXRec->getCaptureFields(LambdaCaptureFields, LambdaThisCaptureField);
 
diff -Naur llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp
--- llvm-project-15.0.7.src/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp	2023-06-05 20:12:47.624385028 +0200
@@ -175,7 +175,7 @@
   const CXXRecordDecl *LambdaCXXRec = MD->getParent();
 
   // Lookup the fields of the lambda
-  llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;
+  llvm::DenseMap<const ValueDecl *, FieldDecl *> LambdaCaptureFields;
   FieldDecl *LambdaThisCaptureField;
   LambdaCXXRec->getCaptureFields(LambdaCaptureFields, LambdaThisCaptureField);
 
diff -Naur llvm-project-15.0.7.src/clang/test/CodeGenCXX/cxx20-decomposition.cpp llvm-project-15.0.7.src.new/clang/test/CodeGenCXX/cxx20-decomposition.cpp
--- llvm-project-15.0.7.src/clang/test/CodeGenCXX/cxx20-decomposition.cpp	1970-01-01 01:00:00.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/test/CodeGenCXX/cxx20-decomposition.cpp	2023-06-05 20:12:47.624385028 +0200
@@ -0,0 +1,48 @@
+// RUN: %clang_cc1 -std=c++20 -triple x86_64-linux-gnu -emit-llvm %s -o - | FileCheck %s
+
+struct S {
+  int i;
+  int j;
+};
+
+int f() {
+  auto [i, j] = S{1, 42};
+  return [&i, j] {
+    return i + j;
+  }();
+}
+
+// Ensures the representation of the lambda, the order of the
+// 1st 2nd don't matter except for ABI-esque things, but make sure
+// that the ref-capture is a ptr, and 'j' is captured by value.
+// CHECK: %[[LAMBDA_TY:.+]] = type <{ ptr, i32, [4 x i8] }>
+
+// Check the captures themselves.
+// CHECK: define{{.*}} i32 @_Z1fv()
+// CHECK: %[[BINDING:.+]] = alloca %struct.S
+// CHECK: %[[LAMBDA:.+]] = alloca %[[LAMBDA_TY]]
+
+// Copy a pointer to the binding, for reference capture.
+// CHECK: %[[LAMBDA_CAP_PTR:.+]] = getelementptr inbounds %[[LAMBDA_TY]], ptr %[[LAMBDA]], i32 0, i32 0
+// CHECK: %[[BINDING_PTR:.+]] = getelementptr inbounds %struct.S, ptr %[[BINDING]], i32 0, i32 0
+// CHECK: store ptr %[[BINDING_PTR]], ptr %[[LAMBDA_CAP_PTR]]
+
+// Copy the integer from the binding, for copy capture.
+// CHECK: %[[LAMBDA_CAP_INT:.+]] = getelementptr inbounds %[[LAMBDA_TY]], ptr %[[LAMBDA]], i32 0, i32 1
+// CHECK: %[[PTR_TO_J:.+]] = getelementptr inbounds %struct.S, ptr %[[BINDING]], i32 0, i32 1
+// CHECK: %[[J_COPY:.+]] = load i32, ptr %[[PTR_TO_J]]
+// CHECK: store i32 %[[J_COPY]], ptr %[[LAMBDA_CAP_INT]]
+
+// Ensure the captures are properly extracted in operator().
+// CHECK: define{{.*}} i32 @"_ZZ1fvENK3$_0clEv"
+// CHECK: %[[THIS_ADDR:.+]] = alloca ptr
+// CHECK: %[[THIS_PTR:.+]] = load ptr, ptr %[[THIS_ADDR]]
+
+// Load 'i', passed by reference.
+// CHECK: %[[LAMBDA_GEP_TO_PTR:.+]] = getelementptr inbounds %[[LAMBDA_TY]], ptr %[[THIS_PTR]], i32 0, i32 0
+// CHECK: %[[I_PTR:.+]] = load ptr, ptr %[[LAMBDA_GEP_TO_PTR]]
+// CHECK: %[[I_VALUE:.+]] = load i32, ptr %[[I_PTR]]
+
+// Load the 'j', passed by value.
+// CHECK: %[[LAMBDA_GEP_TO_INT:.+]] = getelementptr inbounds %[[LAMBDA_TY]], ptr %[[THIS_PTR]], i32 0, i32 1
+// CHECK: %[[J_VALUE:.+]] = load i32, ptr %[[LAMBDA_GEP_TO_INT]]
diff -Naur llvm-project-15.0.7.src/clang/test/SemaCXX/cxx1z-decomposition.cpp llvm-project-15.0.7.src.new/clang/test/SemaCXX/cxx1z-decomposition.cpp
--- llvm-project-15.0.7.src/clang/test/SemaCXX/cxx1z-decomposition.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/test/SemaCXX/cxx1z-decomposition.cpp	2023-06-05 20:12:47.631385090 +0200
@@ -1,4 +1,5 @@
-// RUN: %clang_cc1 -std=c++17 -verify %s
+// RUN: %clang_cc1 -std=c++17 -Wc++20-extensions -verify=expected %s
+// RUN: %clang_cc1 -std=c++20 -Wpre-c++20-compat -verify=expected %s
 
 void use_from_own_init() {
   auto [a] = a; // expected-error {{binding 'a' cannot appear in the initializer of its own decomposition declaration}}
@@ -46,25 +47,58 @@
 }
 static_assert(f({1, 2}) == 12);
 
-constexpr bool g(S &&s) { 
+constexpr bool g(S &&s) {
   auto &[a, b] = s;
   return &a == &s.a && &b == &s.b && &a != &b;
 }
 static_assert(g({1, 2}));
 
-auto [outer1, outer2] = S{1, 2};
+struct S1 {
+  int a, b;
+};
+struct S2 {
+  int a : 1; // expected-note 2{{bit-field is declared here}}
+  int b;
+};
+
+auto [outer1, outer2] = S1{1, 2};
+auto [outerbit1, outerbit2] = S1{1, 2}; // expected-note {{declared here}}
+
 void enclosing() {
   struct S { int a = outer1; };
-  auto [n] = S(); // expected-note 2{{'n' declared here}}
+  auto [n] = S(); // expected-note 3{{'n' declared here}}
+
+  struct Q {
+    int f() { return n; } // expected-error {{reference to local binding 'n' declared in enclosing function 'enclosing'}}
+  };
+
+  (void)[&] { return n; }; // expected-warning {{C++20}}
+  (void)[n] { return n; }; // expected-warning {{C++20}}
 
-  struct Q { int f() { return n; } }; // expected-error {{reference to local binding 'n' declared in enclosing function}}
-  (void) [&] { return n; }; // expected-error {{reference to local binding 'n' declared in enclosing function}}
-  (void) [n] {}; // expected-error {{'n' in capture list does not name a variable}}
+  static auto [m] = S(); // expected-note {{'m' declared here}} \
+                         // expected-warning {{C++20}}
 
-  static auto [m] = S(); // expected-warning {{extension}}
   struct R { int f() { return m; } };
   (void) [&] { return m; };
-  (void) [m] {}; // expected-error {{'m' in capture list does not name a variable}}
+  (void)[m]{}; // expected-error {{'m' cannot be captured because it does not have automatic storage duration}}
+
+  (void)[outerbit1]{}; // expected-error {{'outerbit1' cannot be captured because it does not have automatic storage duration}}
+
+  auto [bit, var] = S2{1, 1}; // expected-note 2{{'bit' declared here}}
+
+  (void)[&bit] { // expected-error {{non-const reference cannot bind to bit-field 'a'}} \
+                    // expected-warning {{C++20}}
+    return bit;
+  };
+
+  union { // expected-note {{declared here}}
+    int u;
+  };
+
+  (void)[&] { return bit + u; } // expected-error {{unnamed variable cannot be implicitly captured in a lambda expression}} \
+                                // expected-error {{non-const reference cannot bind to bit-field 'a'}} \
+                                // expected-warning {{C++20}}
+  ();
 }
 
 void bitfield() {
@@ -98,7 +132,7 @@
 
 struct PR37352 {
   int n;
-  void f() { static auto [a] = *this; } // expected-warning {{C++20 extension}}
+  void f() { static auto [a] = *this; } // expected-warning {{C++20}}
 };
 
 namespace instantiate_template {
diff -Naur llvm-project-15.0.7.src/clang/test/SemaCXX/cxx20-decomposition.cpp llvm-project-15.0.7.src.new/clang/test/SemaCXX/cxx20-decomposition.cpp
--- llvm-project-15.0.7.src/clang/test/SemaCXX/cxx20-decomposition.cpp	1970-01-01 01:00:00.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/test/SemaCXX/cxx20-decomposition.cpp	2023-06-05 20:12:47.624385028 +0200
@@ -0,0 +1,141 @@
+// RUN: %clang_cc1 -fsyntax-only -std=c++20 -verify %s
+// expected-no-diagnostics
+
+template <typename, typename>
+constexpr bool is_same = false;
+template <typename T>
+constexpr bool is_same<T, T> = true;
+
+struct S {
+  int i;
+  int &j;
+};
+
+void check_category() {
+  int a = 42;
+  {
+    auto [v, r] = S{1, a};
+    (void)[ v, r ] {
+      static_assert(is_same<decltype(v), int>);
+      static_assert(is_same<decltype(r), int &>);
+    };
+  }
+  {
+    auto [v, r] = S{1, a};
+    (void)[&v, &r ] {
+      static_assert(is_same<decltype(v), int>);
+      static_assert(is_same<decltype(r), int &>);
+    };
+  }
+  {
+    S s{1, a};
+    const auto &[v, r] = s;
+    (void)[ v, r ] {
+      static_assert(is_same<decltype(v), const int>);
+      static_assert(is_same<decltype(r), int &>);
+    };
+  }
+  {
+    S s{1, a};
+    const auto &[v, r] = s;
+    (void)[&v, &r ] {
+      static_assert(is_same<decltype(v), const int>);
+      static_assert(is_same<decltype(r), int &>);
+    };
+  }
+}
+
+void check_array() {
+  int arr[2] = {42, 42};
+  auto &[a, b] = arr;
+  (void)[ a, &b ] {
+    static_assert(is_same<decltype(a), int>);
+    static_assert(is_same<decltype(b), int>);
+  };
+}
+
+struct tuple {
+  template <unsigned long I>
+  decltype(auto) get() {
+    if constexpr (I == 0) {
+      return a;
+    } else {
+      return b;
+    }
+  }
+
+  template <unsigned long I>
+  decltype(auto) get() const {
+    if constexpr (I == 0) {
+      return a;
+    } else {
+      return b;
+    }
+  }
+
+  int a = 0;
+  int &b = a;
+};
+
+namespace std {
+
+template <typename T>
+struct tuple_size {
+  static constexpr unsigned long value = 2;
+};
+
+template <unsigned long, typename T>
+struct tuple_element;
+
+template <>
+struct tuple_element<0, tuple> {
+  using type = int;
+};
+
+template <>
+struct tuple_element<1, tuple> {
+  using type = int &;
+};
+
+template <>
+struct tuple_element<0, const tuple> {
+  using type = int;
+};
+
+template <>
+struct tuple_element<1, const tuple> {
+  using type = const int &;
+};
+} // namespace std
+
+void check_tuple_like() {
+  tuple t;
+  {
+    auto [v, r] = t;
+    (void)[ v, r ] {
+      static_assert(is_same<decltype(v), int>);
+      static_assert(is_same<decltype(r), int &>);
+    };
+  }
+  {
+    auto &[v, r] = t;
+    (void)[&v, &r ] {
+      static_assert(is_same<decltype(v), int>);
+      static_assert(is_same<decltype(r), int &>);
+    };
+  }
+  {
+    const auto &[v, r] = t;
+    (void)[ v, r ] {
+      static_assert(is_same<decltype(v), int>);
+      static_assert(is_same<decltype(r), const int &>);
+    };
+  }
+  {
+    const auto &[v, r] = t;
+    (void)[&v, &r ] {
+      static_assert(is_same<decltype(v), int>);
+      static_assert(is_same<decltype(r), const int &>);
+    };
+  }
+}
diff -Naur llvm-project-15.0.7.src/clang/test/SemaCXX/decomposition-blocks.cpp llvm-project-15.0.7.src.new/clang/test/SemaCXX/decomposition-blocks.cpp
--- llvm-project-15.0.7.src/clang/test/SemaCXX/decomposition-blocks.cpp	1970-01-01 01:00:00.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/test/SemaCXX/decomposition-blocks.cpp	2023-06-05 20:12:47.624385028 +0200
@@ -0,0 +1,14 @@
+// RUN: %clang_cc1 -std=c++17 -fsyntax-only -verify %s -fblocks
+
+struct S {
+  int i : 1;
+  int j;
+};
+
+void run(void (^)());
+void test() {
+  auto [i, j] = S{1, 42}; // expected-note {{'i' declared here}}
+  run(^{
+    (void)i; // expected-error {{reference to local binding 'i' declared in enclosing function 'test'}}
+  });
+}
diff -Naur llvm-project-15.0.7.src/clang/test/SemaCXX/decomposition-openmp.cpp llvm-project-15.0.7.src.new/clang/test/SemaCXX/decomposition-openmp.cpp
--- llvm-project-15.0.7.src/clang/test/SemaCXX/decomposition-openmp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/test/SemaCXX/decomposition-openmp.cpp	2023-06-05 20:12:47.625385037 +0200
@@ -0,0 +1,13 @@
+
+// RUN: %clang_cc1 -fsyntax-only -verify -std=c++20 -fopenmp %s
+
+// FIXME: OpenMP should support capturing structured bindings
+auto f() {
+  int i[2] = {};
+  auto [a, b] = i; // expected-note 2{{declared here}}
+  return [=, &a] {
+    // expected-error@-1 {{capturing a structured binding is not yet supported in OpenMP}}
+    return a + b;
+    // expected-error@-1 {{capturing a structured binding is not yet supported in OpenMP}}
+  };
+}
diff -Naur llvm-project-15.0.7.src/clang/tools/libclang/CIndex.cpp llvm-project-15.0.7.src.new/clang/tools/libclang/CIndex.cpp
--- llvm-project-15.0.7.src/clang/tools/libclang/CIndex.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/tools/libclang/CIndex.cpp	2023-06-05 20:12:47.625385037 +0200
@@ -3482,9 +3482,11 @@
            C != CEnd; ++C) {
         if (!C->capturesVariable())
           continue;
-
-        if (Visit(MakeCursorVariableRef(C->getCapturedVar(), C->getLocation(),
-                                        TU)))
+        // TODO: handle structured bindings here ?
+        if (!isa<VarDecl>(C->getCapturedVar()))
+          continue;
+        if (Visit(MakeCursorVariableRef(cast<VarDecl>(C->getCapturedVar()),
+                                        C->getLocation(), TU)))
           return true;
       }
       // Visit init captures
diff -Naur llvm-project-15.0.7.src/clang/www/cxx_status.html llvm-project-15.0.7.src.new/clang/www/cxx_status.html
--- llvm-project-15.0.7.src/clang/www/cxx_status.html	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang/www/cxx_status.html	2023-06-05 20:12:47.626385046 +0200
@@ -1140,7 +1140,7 @@
     <tr>
       <td rowspan="2">Structured binding extensions</td>
       <td><a href="https://wg21.link/p1091r3">P1091R3</a></td>
-      <td rowspan="2" class="partial" align="center">Partial</td>
+      <td rowspan="2" class="unreleased" align="center">Clang 16</td>
     </tr>
       <tr>
         <td><a href="https://wg21.link/p1381r1">P1381R1</a></td>
diff -Naur llvm-project-15.0.7.src/clang-tools-extra/clang-tidy/modernize/LoopConvertUtils.cpp llvm-project-15.0.7.src.new/clang-tools-extra/clang-tidy/modernize/LoopConvertUtils.cpp
--- llvm-project-15.0.7.src/clang-tools-extra/clang-tidy/modernize/LoopConvertUtils.cpp	2023-01-12 08:12:30.000000000 +0100
+++ llvm-project-15.0.7.src.new/clang-tools-extra/clang-tidy/modernize/LoopConvertUtils.cpp	2023-06-05 20:12:47.576384602 +0200
@@ -785,8 +785,8 @@
                                                    const LambdaCapture *C,
                                                    Expr *Init) {
   if (C->capturesVariable()) {
-    const VarDecl *VDecl = C->getCapturedVar();
-    if (areSameVariable(IndexVar, cast<ValueDecl>(VDecl))) {
+    const ValueDecl *VDecl = C->getCapturedVar();
+    if (areSameVariable(IndexVar, VDecl)) {
       // FIXME: if the index is captured, it will count as an usage and the
       // alias (if any) won't work, because it is only used in case of having
       // exactly one usage.
