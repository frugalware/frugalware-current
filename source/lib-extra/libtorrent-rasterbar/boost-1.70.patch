diff -Naur libtorrent-rasterbar-1.2.0/include/libtorrent/io_service_fwd.hpp libtorrent-rasterbar-1.2.0.new/include/libtorrent/io_service_fwd.hpp
--- libtorrent-rasterbar-1.2.0/include/libtorrent/io_service_fwd.hpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/include/libtorrent/io_service_fwd.hpp	2019-04-25 15:22:53.192301025 +0200
@@ -55,10 +55,19 @@
 namespace libtorrent {
 
 #if defined TORRENT_BUILD_SIMULATOR
-	typedef sim::asio::io_service io_service;
+	using io_service = sim::asio::io_service;
 #else
-	typedef boost::asio::io_service io_service;
+	using io_service = boost::asio::io_service;
 #endif
+
+#if BOOST_VERSION >= 107000
+template <typename T>
+io_service& get_io_service(T& o) { return static_cast<io_service&>(o.get_executor().context()); }
+#else
+template <typename T>
+io_service& get_io_service(T& o) { return o.get_io_service(); }
+#endif
+
 }
 
 #endif
diff -Naur libtorrent-rasterbar-1.2.0/include/libtorrent/io_service.hpp libtorrent-rasterbar-1.2.0.new/include/libtorrent/io_service.hpp
--- libtorrent-rasterbar-1.2.0/include/libtorrent/io_service.hpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/include/libtorrent/io_service.hpp	2019-04-25 15:22:53.192301025 +0200
@@ -38,9 +38,12 @@
 #else
 #include "libtorrent/aux_/disable_warnings_push.hpp"
 #include <boost/asio/io_service.hpp>
+#include <boost/version.hpp>
 #include "libtorrent/aux_/disable_warnings_pop.hpp"
 #endif // SIMULATOR
 
+#include "libtorrent/io_service_fwd.hpp"
+
 namespace libtorrent {
 
 #if defined TORRENT_BUILD_SIMULATOR
diff -Naur libtorrent-rasterbar-1.2.0/include/libtorrent/proxy_base.hpp libtorrent-rasterbar-1.2.0.new/include/libtorrent/proxy_base.hpp
--- libtorrent-rasterbar-1.2.0/include/libtorrent/proxy_base.hpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/include/libtorrent/proxy_base.hpp	2019-04-25 15:22:53.193301025 +0200
@@ -246,7 +246,7 @@
 
 	io_service& get_io_service()
 	{
-		return m_sock.get_io_service();
+		return lt::get_io_service(m_sock);
 	}
 
 	lowest_layer_type& lowest_layer()
diff -Naur libtorrent-rasterbar-1.2.0/include/libtorrent/tracker_manager.hpp libtorrent-rasterbar-1.2.0.new/include/libtorrent/tracker_manager.hpp
--- libtorrent-rasterbar-1.2.0/include/libtorrent/tracker_manager.hpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/include/libtorrent/tracker_manager.hpp	2019-04-25 15:22:53.193301025 +0200
@@ -259,7 +259,7 @@
 		virtual void on_timeout(error_code const& ec) = 0;
 		virtual ~timeout_handler();
 
-		io_service& get_io_service() { return m_timeout.get_io_service(); }
+		io_service& get_io_service() { return lt::get_io_service(m_timeout); }
 
 	private:
 
diff -Naur libtorrent-rasterbar-1.2.0/include/libtorrent/udp_socket.hpp libtorrent-rasterbar-1.2.0.new/include/libtorrent/udp_socket.hpp
--- libtorrent-rasterbar-1.2.0/include/libtorrent/udp_socket.hpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/include/libtorrent/udp_socket.hpp	2019-04-25 15:22:53.193301025 +0200
@@ -61,7 +61,7 @@
 		static constexpr udp_send_flags_t dont_fragment = 3_bit;
 
 		bool is_open() const { return m_abort == false; }
-		io_service& get_io_service() { return m_socket.get_io_service(); }
+		io_service& get_io_service() { return lt::get_io_service(m_socket); }
 
 		template <typename Handler>
 		void async_read(Handler&& h)
diff -Naur libtorrent-rasterbar-1.2.0/src/disk_io_thread_pool.cpp libtorrent-rasterbar-1.2.0.new/src/disk_io_thread_pool.cpp
--- libtorrent-rasterbar-1.2.0/src/disk_io_thread_pool.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/disk_io_thread_pool.cpp	2019-04-25 15:22:53.193301025 +0200
@@ -174,7 +174,7 @@
 			// buffer pool won't exist anymore, and crash. This prevents that.
 			m_threads.emplace_back(&pool_thread_interface::thread_fun
 				, &m_thread_iface, std::ref(*this)
-				, io_service::work(m_idle_timer.get_io_service()));
+				, io_service::work(get_io_service(m_idle_timer)));
 		}
 	}
 
diff -Naur libtorrent-rasterbar-1.2.0/src/disk_io_thread_pool.cpp.orig libtorrent-rasterbar-1.2.0.new/src/disk_io_thread_pool.cpp.orig
--- libtorrent-rasterbar-1.2.0/src/disk_io_thread_pool.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/disk_io_thread_pool.cpp.orig	2019-04-25 15:22:41.636301400 +0200
@@ -0,0 +1,205 @@
+/*
+
+Copyright (c) 2005-2016, Arvid Norberg, Steven Siloti
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+* Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the distribution.
+* Neither the name of the author nor the names of its
+contributors may be used to endorse or promote products derived
+from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include "libtorrent/disk_io_thread_pool.hpp"
+#include "libtorrent/assert.hpp"
+
+#include <algorithm>
+
+namespace {
+
+	constexpr std::chrono::seconds reap_idle_threads_interval(60);
+}
+
+namespace libtorrent {
+
+	disk_io_thread_pool::disk_io_thread_pool(pool_thread_interface& thread_iface
+		, io_service& ios)
+		: m_thread_iface(thread_iface)
+		, m_max_threads(0)
+		, m_threads_to_exit(0)
+		, m_abort(false)
+		, m_num_idle_threads(0)
+		, m_min_idle_threads(0)
+		, m_idle_timer(ios)
+	{}
+
+	disk_io_thread_pool::~disk_io_thread_pool()
+	{
+		abort(true);
+	}
+
+	void disk_io_thread_pool::set_max_threads(int const i)
+	{
+		std::lock_guard<std::mutex> l(m_mutex);
+		if (i == m_max_threads) return;
+		m_max_threads = i;
+		if (int(m_threads.size()) < i) return;
+		stop_threads(int(m_threads.size()) - i);
+	}
+
+	void disk_io_thread_pool::abort(bool wait)
+	{
+		std::unique_lock<std::mutex> l(m_mutex);
+		if (m_abort) return;
+		m_max_threads = 0;
+		m_abort = true;
+		m_idle_timer.cancel();
+		stop_threads(int(m_threads.size()));
+		for (auto& t : m_threads)
+		{
+			if (wait)
+			{
+				// must release m_mutex to avoid a deadlock if the thread
+				// tries to acquire it
+				l.unlock();
+				t.join();
+				l.lock();
+			}
+			else
+				t.detach();
+		}
+		m_threads.clear();
+	}
+
+	void disk_io_thread_pool::thread_active()
+	{
+		int const num_idle_threads = --m_num_idle_threads;
+		TORRENT_ASSERT(num_idle_threads >= 0);
+
+		int current_min = m_min_idle_threads;
+		while (num_idle_threads < current_min
+			&& !m_min_idle_threads.compare_exchange_weak(current_min, num_idle_threads));
+	}
+
+	bool disk_io_thread_pool::try_thread_exit(std::thread::id id)
+	{
+		int to_exit = m_threads_to_exit;
+		while (to_exit > 0 &&
+			!m_threads_to_exit.compare_exchange_weak(to_exit, to_exit - 1));
+		if (to_exit > 0)
+		{
+			std::unique_lock<std::mutex> l(m_mutex);
+			if (!m_abort)
+			{
+				auto new_end = std::remove_if(m_threads.begin(), m_threads.end()
+					, [id](std::thread& t)
+				{
+					if (t.get_id() == id)
+					{
+						t.detach();
+						return true;
+					}
+					return false;
+				});
+				TORRENT_ASSERT(new_end != m_threads.end());
+				m_threads.erase(new_end, m_threads.end());
+				if (m_threads.empty()) m_idle_timer.cancel();
+			}
+		}
+		return to_exit > 0;
+	}
+
+	std::thread::id disk_io_thread_pool::first_thread_id()
+	{
+		std::lock_guard<std::mutex> l(m_mutex);
+		if (m_threads.empty()) return {};
+		return m_threads.front().get_id();
+	}
+
+	void disk_io_thread_pool::job_queued(int const queue_size)
+	{
+		// this check is not strictly necessary
+		// but do it to avoid acquiring the mutex in the trivial case
+		if (m_num_idle_threads >= queue_size) return;
+		std::lock_guard<std::mutex> l(m_mutex);
+		if (m_abort) return;
+
+		// reduce the number of threads requested to stop if we're going to need
+		// them for these new jobs
+		int to_exit = m_threads_to_exit;
+		while (to_exit > std::max(0, m_num_idle_threads - queue_size) &&
+			!m_threads_to_exit.compare_exchange_weak(to_exit
+				, std::max(0, m_num_idle_threads - queue_size)));
+
+		// now start threads until we either have enough to service
+		// all queued jobs without blocking or hit the max
+		for (int i = m_num_idle_threads
+			; i < queue_size && int(m_threads.size()) < m_max_threads
+			; ++i)
+		{
+			// if this is the first thread started, start the reaper timer
+			if (m_threads.empty())
+			{
+				m_idle_timer.expires_from_now(reap_idle_threads_interval);
+				m_idle_timer.async_wait([this](error_code const& ec) { reap_idle_threads(ec); });
+			}
+
+			// work keeps the io_service::run() call blocked from returning.
+			// When shutting down, it's possible that the event queue is drained
+			// before the disk_io_thread has posted its last callback. When this
+			// happens, the io_service will have a pending callback from the
+			// disk_io_thread, but the event loop is not running. this means
+			// that the event is destructed after the disk_io_thread. If the
+			// event refers to a disk buffer it will try to free it, but the
+			// buffer pool won't exist anymore, and crash. This prevents that.
+			m_threads.emplace_back(&pool_thread_interface::thread_fun
+				, &m_thread_iface, std::ref(*this)
+				, io_service::work(m_idle_timer.get_io_service()));
+		}
+	}
+
+	void disk_io_thread_pool::reap_idle_threads(error_code const& ec)
+	{
+		// take the minimum number of idle threads during the last
+		// sample period and request that many threads to exit
+		if (ec) return;
+		std::lock_guard<std::mutex> l(m_mutex);
+		if (m_abort) return;
+		if (m_threads.empty()) return;
+		m_idle_timer.expires_from_now(reap_idle_threads_interval);
+		m_idle_timer.async_wait([this](error_code const& e) { reap_idle_threads(e); });
+		int const min_idle = m_min_idle_threads.exchange(m_num_idle_threads);
+		if (min_idle <= 0) return;
+		// stop either the minimum number of idle threads or the number of threads
+		// which must be stopped to get below the max, whichever is larger
+		int const to_stop = std::max(min_idle, int(m_threads.size()) - m_max_threads);
+		stop_threads(to_stop);
+	}
+
+	void disk_io_thread_pool::stop_threads(int num_to_stop)
+	{
+		m_threads_to_exit = num_to_stop;
+		m_thread_iface.notify_all();
+	}
+
+} // namespace libtorrent
diff -Naur libtorrent-rasterbar-1.2.0/src/http_connection.cpp libtorrent-rasterbar-1.2.0.new/src/http_connection.cpp
--- libtorrent-rasterbar-1.2.0/src/http_connection.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/http_connection.cpp	2019-04-25 15:22:53.194301025 +0200
@@ -148,7 +148,7 @@
 
 	if (ec)
 	{
-		m_timer.get_io_service().post(std::bind(&http_connection::callback
+		lt::get_io_service(m_timer).post(std::bind(&http_connection::callback
 			, me, ec, span<char>{}));
 		return;
 	}
@@ -160,7 +160,7 @@
 		)
 	{
 		error_code err(errors::unsupported_url_protocol);
-		m_timer.get_io_service().post(std::bind(&http_connection::callback
+		lt::get_io_service(m_timer).post(std::bind(&http_connection::callback
 			, me, err, span<char>{}));
 		return;
 	}
@@ -258,7 +258,7 @@
 
 	if (ec)
 	{
-		m_timer.get_io_service().post(std::bind(&http_connection::callback
+		lt::get_io_service(m_timer).post(std::bind(&http_connection::callback
 			, me, ec, span<char>{}));
 		return;
 	}
@@ -297,7 +297,7 @@
 #if TORRENT_USE_I2P
 			if (i2p_conn->proxy().type != settings_pack::i2p_proxy)
 			{
-				m_timer.get_io_service().post(std::bind(&http_connection::callback
+				lt::get_io_service(m_timer).post(std::bind(&http_connection::callback
 					, me, error_code(errors::no_i2p_router), span<char>{}));
 				return;
 			}
@@ -332,8 +332,8 @@
 					m_ssl_ctx->set_verify_mode(ssl::context::verify_none, ec);
 					if (ec)
 					{
-						m_timer.get_io_service().post(std::bind(&http_connection::callback
-								, me, ec, span<char>{}));
+						lt::get_io_service(m_timer).post(std::bind(&http_connection::callback
+							, me, ec, span<char>{}));
 						return;
 					}
 				}
@@ -344,7 +344,7 @@
 		// assume this is not a tracker connection. Tracker connections that
 		// shouldn't be subject to the proxy should pass in nullptr as the proxy
 		// pointer.
-		instantiate_connection(m_timer.get_io_service()
+		instantiate_connection(lt::get_io_service(m_timer)
 			, proxy ? *proxy : null_proxy, m_sock, userdata, nullptr, false, false);
 
 		if (m_bind_addr)
@@ -353,7 +353,7 @@
 			m_sock.bind(tcp::endpoint(*m_bind_addr, 0), ec);
 			if (ec)
 			{
-				m_timer.get_io_service().post(std::bind(&http_connection::callback
+				lt::get_io_service(m_timer).post(std::bind(&http_connection::callback
 					, me, ec, span<char>{}));
 				return;
 			}
@@ -362,7 +362,7 @@
 		setup_ssl_hostname(m_sock, hostname, ec);
 		if (ec)
 		{
-			m_timer.get_io_service().post(std::bind(&http_connection::callback
+			lt::get_io_service(m_timer).post(std::bind(&http_connection::callback
 				, me, ec, span<char>{}));
 			return;
 		}
diff -Naur libtorrent-rasterbar-1.2.0/src/kademlia/dht_tracker.cpp libtorrent-rasterbar-1.2.0.new/src/kademlia/dht_tracker.cpp
--- libtorrent-rasterbar-1.2.0/src/kademlia/dht_tracker.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/kademlia/dht_tracker.cpp	2019-04-25 15:22:53.194301025 +0200
@@ -130,7 +130,7 @@
 		// must use piecewise construction because tracker_node::connection_timer
 		// is neither copyable nor movable
 		auto n = m_nodes.emplace(std::piecewise_construct_t(), std::forward_as_tuple(s)
-			, std::forward_as_tuple(m_key_refresh_timer.get_io_service()
+			, std::forward_as_tuple(get_io_service(m_key_refresh_timer)
 			, s, this, m_settings, nid, m_log, m_counters
 			, std::bind(&dht_tracker::get_node, this, _1, _2)
 			, m_storage));
diff -Naur libtorrent-rasterbar-1.2.0/src/lsd.cpp libtorrent-rasterbar-1.2.0.new/src/lsd.cpp
--- libtorrent-rasterbar-1.2.0/src/lsd.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/lsd.cpp	2019-04-25 15:22:53.194301025 +0200
@@ -100,11 +100,11 @@
 void lsd::start(error_code& ec)
 {
 	m_socket.open(std::bind(&lsd::on_announce, self(), _1, _2)
-		, m_broadcast_timer.get_io_service(), ec);
+		, lt::get_io_service(m_broadcast_timer), ec);
 	if (ec) return;
 
 	m_socket6.open(std::bind(&lsd::on_announce, self(), _1, _2)
-		, m_broadcast_timer.get_io_service(), ec);
+		, lt::get_io_service(m_broadcast_timer), ec);
 }
 
 lsd::~lsd() = default;
diff -Naur libtorrent-rasterbar-1.2.0/src/natpmp.cpp libtorrent-rasterbar-1.2.0.new/src/natpmp.cpp
--- libtorrent-rasterbar-1.2.0/src/natpmp.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/natpmp.cpp	2019-04-25 15:22:53.195301025 +0200
@@ -160,13 +160,13 @@
 	// try to find one even if the listen socket isn't bound to a device
 	if (device.empty())
 	{
-		device = device_for_address(local_address, m_socket.get_io_service(), ec);
+		device = device_for_address(local_address, get_io_service(m_socket), ec);
 		// if this fails fall back to using the first default gateway in the
 		// routing table
 		ec.clear();
 	}
 
-	auto const route = get_default_route(m_socket.get_io_service()
+	auto const route = get_default_route(get_io_service(m_socket)
 		, device, local_address.is_v6(), ec);
 
 	if (!route)
@@ -194,7 +194,7 @@
 	if (local_address.is_unspecified())
 	{
 		std::vector<ip_interface> const net = enum_net_interfaces(
-			m_socket.get_io_service(), ec);
+			get_io_service(m_socket), ec);
 
 		auto const it = std::find_if(net.begin(), net.end(), [&](ip_interface const& i)
 		{
diff -Naur libtorrent-rasterbar-1.2.0/src/udp_socket.cpp libtorrent-rasterbar-1.2.0.new/src/udp_socket.cpp
--- libtorrent-rasterbar-1.2.0/src/udp_socket.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/udp_socket.cpp	2019-04-25 15:22:53.195301025 +0200
@@ -492,7 +492,7 @@
 	{
 		// connect to socks5 server and open up the UDP tunnel
 
-		m_socks5_connection = std::make_shared<socks5>(m_socket.get_io_service());
+		m_socks5_connection = std::make_shared<socks5>(lt::get_io_service(m_socket));
 		m_socks5_connection->start(ps);
 	}
 }
diff -Naur libtorrent-rasterbar-1.2.0/src/upnp.cpp libtorrent-rasterbar-1.2.0.new/src/upnp.cpp
--- libtorrent-rasterbar-1.2.0/src/upnp.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/src/upnp.cpp	2019-04-25 15:22:53.196301025 +0200
@@ -121,7 +121,7 @@
 
 	error_code ec;
 	m_socket.open(std::bind(&upnp::on_reply, self(), _1, _2)
-		, m_refresh_timer.get_io_service(), ec);
+		, lt::get_io_service(m_refresh_timer), ec);
 
 	m_mappings.reserve(10);
 }
diff -Naur libtorrent-rasterbar-1.2.0/test/test_fast_extension.cpp libtorrent-rasterbar-1.2.0.new/test/test_fast_extension.cpp
--- libtorrent-rasterbar-1.2.0/test/test_fast_extension.cpp	2019-01-12 16:01:06.000000000 +0100
+++ libtorrent-rasterbar-1.2.0.new/test/test_fast_extension.cpp	2019-04-25 15:22:53.196301025 +0200
@@ -462,7 +462,7 @@
 	}
 	else
 	{
-		tcp::acceptor l(s.get_io_service());
+		tcp::acceptor l(lt::get_io_service(s));
 		l.open(tcp::v4());
 		l.bind(tcp::endpoint(address_v4::from_string("127.0.0.1"), 0));
 		l.listen();
