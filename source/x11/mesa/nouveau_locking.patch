diff -Naur mesa-18.1.0/src/gallium/auxiliary/os/os_thread.h mesa-18.1.0.new/src/gallium/auxiliary/os/os_thread.h
--- mesa-18.1.0/src/gallium/auxiliary/os/os_thread.h	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/auxiliary/os/os_thread.h	2018-05-22 11:17:46.306742617 +0200
@@ -42,6 +42,25 @@
 #include "util/u_thread.h"
 
 
+/* pipe_mutex
+ */
+typedef mtx_t pipe_mutex;
+
+#define pipe_static_mutex(mutex) \
+   static pipe_mutex mutex = _MTX_INITIALIZER_NP
+
+#define pipe_mutex_init(mutex) \
+   (void) mtx_init(&(mutex), mtx_plain)
+
+#define pipe_mutex_destroy(mutex) \
+   mtx_destroy(&(mutex))
+
+#define pipe_mutex_lock(mutex) \
+   (void) mtx_lock(&(mutex))
+
+#define pipe_mutex_unlock(mutex) \
+   (void) mtx_unlock(&(mutex))
+
 #define pipe_mutex_assert_locked(mutex) \
    __pipe_mutex_assert_locked(&(mutex))
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_buffer.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_buffer.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_buffer.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_buffer.c	2018-05-22 11:17:46.306742617 +0200
@@ -80,6 +80,8 @@
 inline void
 nouveau_buffer_release_gpu_storage(struct nv04_resource *buf)
 {
+   if (buf->fence)
+      pipe_mutex_lock(buf->fence->screen->push_mutex);
    if (buf->fence && buf->fence->state < NOUVEAU_FENCE_STATE_FLUSHED) {
       nouveau_fence_work(buf->fence, nouveau_fence_unref_bo, buf->bo);
       buf->bo = NULL;
@@ -89,6 +91,8 @@
 
    if (buf->mm)
       release_allocation(&buf->mm, buf->fence);
+   if (buf->fence)
+      pipe_mutex_unlock(buf->fence->screen->push_mutex);
 
    if (buf->domain == NOUVEAU_BO_VRAM)
       NOUVEAU_DRV_STAT_RES(buf, buf_obj_current_bytes_vid, -(uint64_t)buf->base.width0);
@@ -380,6 +384,7 @@
                             struct pipe_transfer **ptransfer)
 {
    struct nouveau_context *nv = nouveau_context(pipe);
+   struct nouveau_screen *screen = nv->screen;
    struct nv04_resource *buf = nv04_resource(resource);
    struct nouveau_transfer *tx = MALLOC_STRUCT(nouveau_transfer);
    uint8_t *map;
@@ -424,14 +429,19 @@
                buf->data = NULL;
             }
             nouveau_transfer_staging(nv, tx, false);
+            pipe_mutex_lock(screen->push_mutex);
             nouveau_transfer_read(nv, tx);
+            pipe_mutex_unlock(screen->push_mutex);
          } else {
             /* The buffer is currently idle. Create a staging area for writes,
              * and make sure that the cached data is up-to-date. */
             if (usage & PIPE_TRANSFER_WRITE)
                nouveau_transfer_staging(nv, tx, true);
-            if (!buf->data)
+            if (!buf->data) {
+               pipe_mutex_lock(screen->push_mutex);
                nouveau_buffer_cache(nv, buf);
+               pipe_mutex_unlock(screen->push_mutex);
+            }
          }
       }
       return buf->data ? (buf->data + box->x) : tx->map;
@@ -477,7 +487,9 @@
                             PIPE_TRANSFER_PERSISTENT))) {
          /* Discarding was not possible, must sync because
           * subsequent transfers might use UNSYNCHRONIZED. */
+         pipe_mutex_lock(screen->push_mutex);
          nouveau_buffer_sync(nv, buf, usage & PIPE_TRANSFER_READ_WRITE);
+         pipe_mutex_unlock(screen->push_mutex);
       } else
       if (usage & PIPE_TRANSFER_DISCARD_RANGE) {
          /* The whole range is being discarded, so it doesn't matter what was
@@ -486,10 +498,13 @@
          map = tx->map;
       } else
       if (nouveau_buffer_busy(buf, PIPE_TRANSFER_READ)) {
-         if (usage & PIPE_TRANSFER_DONTBLOCK)
+         if (usage & PIPE_TRANSFER_DONTBLOCK) {
             map = NULL;
-         else
+         } else {
+            pipe_mutex_lock(screen->push_mutex);
             nouveau_buffer_sync(nv, buf, usage & PIPE_TRANSFER_READ_WRITE);
+            pipe_mutex_unlock(screen->push_mutex);
+         }
       } else {
          /* It is expected that the returned buffer be a representation of the
           * data in question, so we must copy it over from the buffer. */
@@ -513,9 +528,13 @@
 {
    struct nouveau_transfer *tx = nouveau_transfer(transfer);
    struct nv04_resource *buf = nv04_resource(transfer->resource);
+   struct nouveau_screen *screen = nouveau_context(pipe)->screen;
 
-   if (tx->map)
+   if (tx->map) {
+      pipe_mutex_lock(screen->push_mutex);
       nouveau_transfer_write(nouveau_context(pipe), tx, box->x, box->width);
+      pipe_mutex_unlock(screen->push_mutex);
+   }
 
    util_range_add(&buf->valid_buffer_range,
                   tx->base.box.x + box->x,
@@ -535,11 +554,15 @@
    struct nouveau_context *nv = nouveau_context(pipe);
    struct nouveau_transfer *tx = nouveau_transfer(transfer);
    struct nv04_resource *buf = nv04_resource(transfer->resource);
+   struct nouveau_screen *screen = nouveau_context(pipe)->screen;
 
    if (tx->base.usage & PIPE_TRANSFER_WRITE) {
       if (!(tx->base.usage & PIPE_TRANSFER_FLUSH_EXPLICIT)) {
-         if (tx->map)
+         if (tx->map) {
+            pipe_mutex_lock(screen->push_mutex);
             nouveau_transfer_write(nv, tx, 0, tx->base.box.width);
+            pipe_mutex_unlock(screen->push_mutex);
+         }
 
          util_range_add(&buf->valid_buffer_range,
                         tx->base.box.x, tx->base.box.x + tx->base.box.width);
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_fence.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_fence.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_fence.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_fence.c	2018-05-22 11:17:46.306742617 +0200
@@ -67,12 +67,14 @@
 
    ++fence->ref;
 
+   pipe_mutex_lock(screen->fence.list_mutex);
    if (screen->fence.tail)
       screen->fence.tail->next = fence;
    else
       screen->fence.head = fence;
 
    screen->fence.tail = fence;
+   pipe_mutex_unlock(screen->fence.list_mutex);
 
    screen->fence.emit(&screen->base, &fence->sequence);
 
@@ -86,6 +88,9 @@
    struct nouveau_fence *it;
    struct nouveau_screen *screen = fence->screen;
 
+   /* XXX This can race against fence_update. But fence_update can also call
+    * into this, so ... be have to be careful.
+    */
    if (fence->state == NOUVEAU_FENCE_STATE_EMITTED ||
        fence->state == NOUVEAU_FENCE_STATE_FLUSHED) {
       if (fence == screen->fence.head) {
@@ -119,6 +124,7 @@
       return;
    screen->fence.sequence_ack = sequence;
 
+   pipe_mutex_lock(screen->fence.list_mutex);
    for (fence = screen->fence.head; fence; fence = next) {
       next = fence->next;
       sequence = fence->sequence;
@@ -140,6 +146,7 @@
          if (fence->state == NOUVEAU_FENCE_STATE_EMITTED)
             fence->state = NOUVEAU_FENCE_STATE_FLUSHED;
    }
+   pipe_mutex_unlock(screen->fence.list_mutex);
 }
 
 #define NOUVEAU_FENCE_MAX_SPINS (1 << 31)
@@ -194,18 +201,27 @@
    uint32_t spins = 0;
    int64_t start = 0;
 
+   /* Fast-path for the case where the fence is already signaled to avoid
+    * messing around with mutexes and timing.
+    */
+   if (fence->state == NOUVEAU_FENCE_STATE_SIGNALLED)
+      return true;
+
    if (debug && debug->debug_message)
       start = os_time_get_nano();
 
    if (!nouveau_fence_kick(fence))
       return false;
 
+   pipe_mutex_unlock(screen->push_mutex);
+
    do {
       if (fence->state == NOUVEAU_FENCE_STATE_SIGNALLED) {
          if (debug && debug->debug_message)
             pipe_debug_message(debug, PERF_INFO,
                                "stalled %.3f ms waiting for fence",
                                (os_time_get_nano() - start) / 1000000.f);
+         pipe_mutex_lock(screen->push_mutex);
          return true;
       }
       if (!spins)
@@ -223,6 +239,8 @@
                 fence->sequence,
                 screen->fence.sequence_ack, screen->fence.sequence);
 
+   pipe_mutex_lock(screen->push_mutex);
+
    return false;
 }
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_fence.h mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_fence.h
--- mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_fence.h	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_fence.h	2018-05-22 11:17:46.306742617 +0200
@@ -2,6 +2,7 @@
 #ifndef __NOUVEAU_FENCE_H__
 #define __NOUVEAU_FENCE_H__
 
+#include "util/u_atomic.h"
 #include "util/u_inlines.h"
 #include "util/list.h"
 
@@ -46,10 +47,10 @@
 nouveau_fence_ref(struct nouveau_fence *fence, struct nouveau_fence **ref)
 {
    if (fence)
-      ++fence->ref;
+      p_atomic_inc(&fence->ref);
 
    if (*ref) {
-      if (--(*ref)->ref == 0)
+      if (p_atomic_dec_zero(&(*ref)->ref))
          nouveau_fence_del(*ref);
    }
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_screen.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_screen.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_screen.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_screen.c	2018-05-22 11:17:46.306742617 +0200
@@ -80,10 +80,14 @@
                             struct pipe_fence_handle *pfence,
                             uint64_t timeout)
 {
+   bool ret;
    if (!timeout)
       return nouveau_fence_signalled(nouveau_fence(pfence));
 
-   return nouveau_fence_wait(nouveau_fence(pfence), NULL);
+   pipe_mutex_lock(nouveau_screen(screen)->push_mutex);
+   ret = nouveau_fence_wait(nouveau_fence(pfence), NULL);
+   pipe_mutex_unlock(nouveau_screen(screen)->push_mutex);
+   return ret;
 }
 
 
@@ -179,6 +183,9 @@
    if (nv_dbg)
       nouveau_mesa_debug = atoi(nv_dbg);
 
+   pipe_mutex_init(screen->push_mutex);
+   pipe_mutex_init(screen->fence.list_mutex);
+
    /* These must be set before any failure is possible, as the cleanup
     * paths assume they're responsible for deleting them.
     */
@@ -281,6 +288,9 @@
    nouveau_drm_del(&screen->drm);
    close(fd);
 
+   pipe_mutex_destroy(screen->push_mutex);
+   pipe_mutex_destroy(screen->fence.list_mutex);
+
    disk_cache_destroy(screen->disk_shader_cache);
 }
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_screen.h mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_screen.h
--- mesa-18.1.0/src/gallium/drivers/nouveau/nouveau_screen.h	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nouveau_screen.h	2018-05-22 11:17:46.307742617 +0200
@@ -4,6 +4,7 @@
 #include "pipe/p_screen.h"
 #include "util/disk_cache.h"
 #include "util/u_memory.h"
+#include "os/os_thread.h"
 
 #ifdef DEBUG
 # define NOUVEAU_ENABLE_DRIVER_STATISTICS
@@ -23,6 +24,7 @@
    struct nouveau_object *channel;
    struct nouveau_client *client;
    struct nouveau_pushbuf *pushbuf;
+   pipe_mutex push_mutex;
 
    int refcount;
 
@@ -40,6 +42,7 @@
       struct nouveau_fence *head;
       struct nouveau_fence *tail;
       struct nouveau_fence *current;
+      pipe_mutex list_mutex;
       u32 sequence;
       u32 sequence_ack;
       void (*emit)(struct pipe_screen *, u32 *sequence);
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_clear.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_clear.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_clear.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_clear.c	2018-05-22 11:17:46.307742617 +0200
@@ -58,8 +58,11 @@
    struct pipe_framebuffer_state *fb = &nv30->framebuffer;
    uint32_t colr = 0, zeta = 0, mode = 0;
 
-   if (!nv30_state_validate(nv30, NV30_NEW_FRAMEBUFFER | NV30_NEW_SCISSOR, true))
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
+   if (!nv30_state_validate(nv30, NV30_NEW_FRAMEBUFFER | NV30_NEW_SCISSOR, true)) {
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
+   }
 
    if (buffers & PIPE_CLEAR_COLOR && fb->nr_cbufs) {
       colr  = pack_rgba(fb->cbufs[0]->format, color->f);
@@ -96,6 +99,7 @@
    PUSH_DATA (push, mode);
 
    nv30_state_release(nv30);
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
 }
 
 static void
@@ -126,11 +130,15 @@
       rt_format |= NV30_3D_RT_FORMAT_TYPE_LINEAR;
    }
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
+
    refn.bo = mt->base.bo;
    refn.flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_WR;
    if (nouveau_pushbuf_space(push, 32, 1, 0) ||
-       nouveau_pushbuf_refn (push, &refn, 1))
+       nouveau_pushbuf_refn (push, &refn, 1)) {
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
+   }
 
    BEGIN_NV04(push, NV30_3D(RT_ENABLE), 1);
    PUSH_DATA (push, NV30_3D_RT_ENABLE_COLOR0);
@@ -155,6 +163,8 @@
                     NV30_3D_CLEAR_BUFFERS_COLOR_B |
                     NV30_3D_CLEAR_BUFFERS_COLOR_A);
 
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
+
    nv30->dirty |= NV30_NEW_FRAMEBUFFER | NV30_NEW_SCISSOR;
 }
 
@@ -191,11 +201,15 @@
    if (buffers & PIPE_CLEAR_STENCIL)
       mode |= NV30_3D_CLEAR_BUFFERS_STENCIL;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
+
    refn.bo = mt->base.bo;
    refn.flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_WR;
    if (nouveau_pushbuf_space(push, 32, 1, 0) ||
-       nouveau_pushbuf_refn (push, &refn, 1))
+       nouveau_pushbuf_refn (push, &refn, 1)) {
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
+   }
 
    BEGIN_NV04(push, NV30_3D(RT_ENABLE), 1);
    PUSH_DATA (push, 0);
@@ -221,6 +235,8 @@
    BEGIN_NV04(push, NV30_3D(CLEAR_BUFFERS), 1);
    PUSH_DATA (push, mode);
 
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
+
    nv30->dirty |= NV30_NEW_FRAMEBUFFER | NV30_NEW_SCISSOR;
 }
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_context.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_context.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_context.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_context.c	2018-05-22 11:17:46.307742617 +0200
@@ -198,6 +198,8 @@
    if (!nv30)
       return NULL;
 
+   pipe_mutex_lock(screen->base.push_mutex);
+
    nv30->screen = screen;
    nv30->base.screen = &screen->base;
    nv30->base.copy_data = nv30_transfer_copy_data;
@@ -230,6 +232,7 @@
    ret = nouveau_bufctx_new(nv30->base.client, 64, &nv30->bufctx);
    if (ret) {
       nv30_context_destroy(pipe);
+      pipe_mutex_unlock(screen->base.push_mutex);
       return NULL;
    }
 
@@ -263,10 +266,13 @@
    nv30->blitter = util_blitter_create(pipe);
    if (!nv30->blitter) {
       nv30_context_destroy(pipe);
+      pipe_mutex_unlock(screen->base.push_mutex);
       return NULL;
    }
 
    nouveau_context_init_vdec(&nv30->base);
 
+   pipe_mutex_unlock(screen->base.push_mutex);
+
    return pipe;
 }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_draw.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_draw.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_draw.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_draw.c	2018-05-22 11:17:46.307742617 +0200
@@ -127,6 +127,8 @@
    struct nouveau_pushbuf *push = nv30->screen->base.pushbuf;
    unsigned i;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
+
    BEGIN_NV04(push, NV30_3D(VTXBUF(0)), r->vertex_info.num_attribs);
    for (i = 0; i < r->vertex_info.num_attribs; i++) {
       PUSH_RESRC(push, NV30_3D(VTXBUF(i)), BUFCTX_VTXTMP,
@@ -134,8 +136,10 @@
                        NOUVEAU_BO_LOW | NOUVEAU_BO_RD, 0, NV30_3D_VTXBUF_DMA1);
    }
 
-   if (!nv30_state_validate(nv30, ~0, false))
+   if (!nv30_state_validate(nv30, ~0, false)) {
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
+   }
 
    BEGIN_NV04(push, NV30_3D(VERTEX_BEGIN_END), 1);
    PUSH_DATA (push, r->prim);
@@ -160,6 +164,8 @@
    BEGIN_NV04(push, NV30_3D(VERTEX_BEGIN_END), 1);
    PUSH_DATA (push, NV30_3D_VERTEX_BEGIN_END_STOP);
    PUSH_RESET(push, BUFCTX_VTXTMP);
+
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
 }
 
 static void
@@ -172,6 +178,8 @@
    unsigned ps = fn + (pn ? 1 : 0);
    unsigned i;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
+
    BEGIN_NV04(push, NV30_3D(VTXBUF(0)), r->vertex_info.num_attribs);
    for (i = 0; i < r->vertex_info.num_attribs; i++) {
       PUSH_RESRC(push, NV30_3D(VTXBUF(i)), BUFCTX_VTXTMP,
@@ -179,8 +187,10 @@
                        NOUVEAU_BO_LOW | NOUVEAU_BO_RD, 0, NV30_3D_VTXBUF_DMA1);
    }
 
-   if (!nv30_state_validate(nv30, ~0, false))
+   if (!nv30_state_validate(nv30, ~0, false)) {
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
+   }
 
    BEGIN_NV04(push, NV30_3D(VERTEX_BEGIN_END), 1);
    PUSH_DATA (push, r->prim);
@@ -197,6 +207,8 @@
    BEGIN_NV04(push, NV30_3D(VERTEX_BEGIN_END), 1);
    PUSH_DATA (push, NV30_3D_VERTEX_BEGIN_END_STOP);
    PUSH_RESET(push, BUFCTX_VTXTMP);
+
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
 }
 
 static void
@@ -386,6 +398,8 @@
 
    nv30_render_validate(nv30);
 
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
+
    if (nv30->draw_dirty & NV30_NEW_VIEWPORT)
       draw_set_viewport_states(draw, 0, 1, &nv30->viewport);
    if (nv30->draw_dirty & NV30_NEW_RASTERIZER)
@@ -452,6 +466,8 @@
       if (transfer[i])
          pipe_buffer_unmap(pipe, transfer[i]);
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
+
    nv30->draw_dirty = 0;
    nv30_state_release(nv30);
 }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_fragprog.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_fragprog.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_fragprog.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_fragprog.c	2018-05-22 11:17:46.307742617 +0200
@@ -38,6 +38,8 @@
    struct nv30_fragprog *fp = nv30->fragprog.program;
    struct pipe_context *pipe = &nv30->base.pipe;
 
+   pipe_mutex_unlock(nv->screen->push_mutex);
+
    if (unlikely(!fp->buffer))
       fp->buffer = pipe_buffer_create(pipe->screen, 0, 0, fp->insn_len * 4);
 
@@ -60,6 +62,8 @@
 
    if (nv04_resource(fp->buffer)->domain != NOUVEAU_BO_VRAM)
       nouveau_buffer_migrate(nv, nv04_resource(fp->buffer), NOUVEAU_BO_VRAM);
+
+   pipe_mutex_lock(nv->screen->push_mutex);
 }
 
 void
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_miptree.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_miptree.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_miptree.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_miptree.c	2018-05-22 11:17:46.307742617 +0200
@@ -130,10 +130,12 @@
    struct nv30_context *nv30 = nv30_context(pipe);
    struct nv30_rect src, dst;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
    if (dstres->target == PIPE_BUFFER && srcres->target == PIPE_BUFFER) {
       nouveau_copy_buffer(&nv30->base,
                           nv04_resource(dstres), dstx,
                           nv04_resource(srcres), src_box->x, src_box->width);
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
    }
 
@@ -143,6 +145,7 @@
                        src_box->width, src_box->height, &dst);
 
    nv30_transfer_rect(nv30, NEAREST, &src, &dst);
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
 }
 
 static void
@@ -163,6 +166,7 @@
    y1 = src.y1;
 
    /* On nv3x we must use sifm which is restricted to 1024x1024 tiles */
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
    for (y = src.y0; y < y1; y += h) {
       h = y1 - y;
       if (h > 1024)
@@ -193,6 +197,7 @@
          nv30_transfer_rect(nv30, BILINEAR, &src, &dst);
       }
    }
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
 }
 
 void
@@ -308,8 +313,12 @@
    tx->tmp.y1     = tx->tmp.h;
    tx->tmp.z      = 0;
 
-   if (usage & PIPE_TRANSFER_READ)
+   if (usage & PIPE_TRANSFER_READ) {
+      pipe_mutex_lock(nv30->screen->base.push_mutex);
       nv30_transfer_rect(nv30, NEAREST, &tx->img, &tx->tmp);
+      PUSH_KICK(nv30->base.pushbuf);
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
+   }
 
    if (tx->tmp.bo->map) {
       *ptransfer = &tx->base;
@@ -340,11 +349,13 @@
    struct nv30_transfer *tx = nv30_transfer(ptx);
 
    if (ptx->usage & PIPE_TRANSFER_WRITE) {
+      pipe_mutex_lock(nv30->screen->base.push_mutex);
       nv30_transfer_rect(nv30, NEAREST, &tx->tmp, &tx->img);
 
       /* Allow the copies above to finish executing before freeing the source */
       nouveau_fence_work(nv30->screen->base.fence.current,
                          nouveau_fence_unref_bo, tx->tmp.bo);
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
    } else {
       nouveau_bo_ref(NULL, &tx->tmp.bo);
    }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_query.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_query.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_query.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_query.c	2018-05-22 11:17:46.307742617 +0200
@@ -153,6 +153,7 @@
    struct nv30_query *q = nv30_query(pq);
    struct nouveau_pushbuf *push = nv30->base.pushbuf;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
    switch (q->type) {
    case PIPE_QUERY_TIME_ELAPSED:
       q->qo[0] = nv30_query_object_new(nv30->screen);
@@ -162,7 +163,7 @@
       }
       break;
    case PIPE_QUERY_TIMESTAMP:
-      return true;
+      break;
    default:
       BEGIN_NV04(push, NV30_3D(QUERY_RESET), 1);
       PUSH_DATA (push, q->report);
@@ -173,6 +174,7 @@
       BEGIN_NV04(push, SUBC_3D(q->enable), 1);
       PUSH_DATA (push, 1);
    }
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
    return true;
 }
 
@@ -184,6 +186,7 @@
    struct nv30_query *q = nv30_query(pq);
    struct nouveau_pushbuf *push = nv30->base.pushbuf;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
    q->qo[1] = nv30_query_object_new(screen);
    if (q->qo[1]) {
       BEGIN_NV04(push, NV30_3D(QUERY_GET), 1);
@@ -195,6 +198,7 @@
       PUSH_DATA (push, 0);
    }
    PUSH_KICK (push);
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
    return true;
 }
 
@@ -250,9 +254,11 @@
    nv30->render_cond_mode = mode;
    nv30->render_cond_cond = condition;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
    if (!pq) {
       BEGIN_NV04(push, SUBC_3D(0x1e98), 1);
       PUSH_DATA (push, 0x01000000);
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
    }
 
@@ -264,6 +270,7 @@
 
    BEGIN_NV04(push, SUBC_3D(0x1e98), 1);
    PUSH_DATA (push, 0x02000000 | q->qo[1]->hw->start);
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
 }
 
 static void
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_vbo.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_vbo.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv30/nv30_vbo.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv30/nv30_vbo.c	2018-05-22 11:17:46.307742617 +0200
@@ -569,6 +569,8 @@
    if (nv30->vbo_push_hint != !!nv30->vbo_fifo)
       nv30->dirty |= NV30_NEW_ARRAYS;
 
+   pipe_mutex_lock(nv30->screen->base.push_mutex);
+
    push->user_priv = &nv30->bufctx;
    if (nv30->vbo_user && !(nv30->dirty & (NV30_NEW_VERTEX | NV30_NEW_ARRAYS)))
       nv30_update_user_vbufs(nv30);
@@ -576,10 +578,12 @@
    nv30_state_validate(nv30, ~0, true);
    if (nv30->draw_flags) {
       nv30_render_vbo(pipe, info);
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
    } else
    if (nv30->vbo_fifo) {
       nv30_push_vbo(nv30, info);
+      pipe_mutex_unlock(nv30->screen->base.push_mutex);
       return;
    }
 
@@ -636,6 +640,7 @@
 
    nv30_state_release(nv30);
    nv30_release_user_vbufs(nv30);
+   pipe_mutex_unlock(nv30->screen->base.push_mutex);
 }
 
 void
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_compute.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_compute.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_compute.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_compute.c	2018-05-22 11:17:46.307742617 +0200
@@ -249,9 +249,11 @@
    struct nv50_program *cp = nv50->compprog;
    bool ret;
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
    ret = !nv50_state_validate_cp(nv50, ~0);
    if (ret) {
       NOUVEAU_ERR("Failed to launch grid !\n");
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       return;
    }
 
@@ -284,6 +286,8 @@
    BEGIN_NV04(push, SUBC_CP(NV50_GRAPH_SERIALIZE), 1);
    PUSH_DATA (push, 0);
 
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
+
    /* bind a compute shader clobbers fragment shader state */
    nv50->dirty_3d |= NV50_NEW_3D_FRAGPROG;
 }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_context.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_context.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_context.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_context.c	2018-05-22 11:17:46.307742617 +0200
@@ -38,7 +38,9 @@
    if (fence)
       nouveau_fence_ref(screen->fence.current, (struct nouveau_fence **)fence);
 
+   pipe_mutex_lock(screen->push_mutex);
    PUSH_KICK(screen->pushbuf);
+   pipe_mutex_unlock(screen->push_mutex);
 
    nouveau_context_update_frame_stats(nouveau_context(pipe));
 }
@@ -48,10 +50,12 @@
 {
    struct nouveau_pushbuf *push = nv50_context(pipe)->base.pushbuf;
 
+   pipe_mutex_lock(nouveau_context(pipe)->screen->push_mutex);
    BEGIN_NV04(push, SUBC_3D(NV50_GRAPH_SERIALIZE), 1);
    PUSH_DATA (push, 0);
    BEGIN_NV04(push, NV50_3D(TEX_CACHE_CTL), 1);
    PUSH_DATA (push, 0x20);
+   pipe_mutex_unlock(nouveau_context(pipe)->screen->push_mutex);
 }
 
 static void
@@ -104,6 +108,7 @@
       data_words = string_words;
    else
       data_words = string_words + !!(len & 3);
+   pipe_mutex_lock(nouveau_context(pipe)->screen->push_mutex);
    BEGIN_NI04(push, SUBC_3D(NV04_GRAPH_NOP), data_words);
    if (string_words)
       PUSH_DATAp(push, str, string_words);
@@ -112,6 +117,7 @@
       memcpy(&data, &str[string_words * 4], len & 3);
       PUSH_DATA (push, data);
    }
+   pipe_mutex_unlock(nouveau_context(pipe)->screen->push_mutex);
 }
 
 void
@@ -282,6 +288,8 @@
       return NULL;
    pipe = &nv50->base.pipe;
 
+   pipe_mutex_lock(screen->base.push_mutex);
+
    if (!nv50_blitctx_create(nv50))
       goto out_err;
 
@@ -379,11 +387,14 @@
 
    util_dynarray_init(&nv50->global_residents, NULL);
 
+   pipe_mutex_unlock(screen->base.push_mutex);
+
    return pipe;
 
 out_err:
    if (pipe->stream_uploader)
       u_upload_destroy(pipe->stream_uploader);
+   pipe_mutex_unlock(screen->base.push_mutex);
    if (nv50->bufctx_3d)
       nouveau_bufctx_del(&nv50->bufctx_3d);
    if (nv50->bufctx_cp)
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_context.h mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_context.h
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_context.h	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_context.h	2018-05-22 11:17:46.307742617 +0200
@@ -221,6 +221,11 @@
 /* nv50_draw.c */
 extern struct draw_stage *nv50_draw_render_stage(struct nv50_context *);
 
+/* nv50_query.c */
+void nv50_render_condition(struct pipe_context *pipe,
+                           struct pipe_query *pq,
+                           boolean condition, uint mode);
+
 /* nv50_shader_state.c */
 void nv50_vertprog_validate(struct nv50_context *);
 void nv50_gmtyprog_validate(struct nv50_context *);
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_miptree.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_miptree.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_miptree.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_miptree.c	2018-05-22 11:17:46.307742617 +0200
@@ -163,10 +163,13 @@
 {
    struct nv50_miptree *mt = nv50_miptree(pt);
 
-   if (mt->base.fence && mt->base.fence->state < NOUVEAU_FENCE_STATE_FLUSHED)
+   if (mt->base.fence && mt->base.fence->state < NOUVEAU_FENCE_STATE_FLUSHED) {
+      pipe_mutex_lock(nouveau_screen(pscreen)->push_mutex);
       nouveau_fence_work(mt->base.fence, nouveau_fence_unref_bo, mt->base.bo);
-   else
+      pipe_mutex_unlock(nouveau_screen(pscreen)->push_mutex);
+   } else {
       nouveau_bo_ref(NULL, &mt->base.bo);
+   }
 
    nouveau_fence_ref(NULL, &mt->base.fence);
    nouveau_fence_ref(NULL, &mt->base.fence_wr);
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_query.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_query.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_query.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_query.c	2018-05-22 11:17:46.307742617 +0200
@@ -70,7 +70,7 @@
    return q->funcs->get_query_result(nv50_context(pipe), q, wait, result);
 }
 
-static void
+void
 nv50_render_condition(struct pipe_context *pipe,
                       struct pipe_query *pq,
                       boolean condition, enum pipe_render_cond_flag mode)
@@ -146,6 +146,16 @@
 }
 
 static void
+nv50_render_condition_locked(struct pipe_context *pipe,
+                             struct pipe_query *pq,
+                             boolean condition, uint mode)
+{
+   pipe_mutex_lock(nouveau_context(pipe)->screen->push_mutex);
+   nv50_render_condition(pipe, pq, condition, mode);
+   pipe_mutex_unlock(nouveau_context(pipe)->screen->push_mutex);
+}
+
+static void
 nv50_set_active_query_state(struct pipe_context *pipe, boolean enable)
 {
 }
@@ -161,7 +171,7 @@
    pipe->end_query = nv50_end_query;
    pipe->get_query_result = nv50_get_query_result;
    pipe->set_active_query_state = nv50_set_active_query_state;
-   pipe->render_condition = nv50_render_condition;
+   pipe->render_condition = nv50_render_condition_locked;
    nv50->cond_condmode = NV50_3D_COND_MODE_ALWAYS;
 }
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_query_hw.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_query_hw.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_query_hw.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_query_hw.c	2018-05-22 11:17:46.307742617 +0200
@@ -56,9 +56,12 @@
       if (hq->mm) {
          if (hq->state == NV50_HW_QUERY_STATE_READY)
             nouveau_mm_free(hq->mm);
-         else
+         else {
+            pipe_mutex_lock(screen->base.push_mutex);
             nouveau_fence_work(screen->base.fence.current,
                                nouveau_mm_free_work, hq->mm);
+            pipe_mutex_unlock(screen->base.push_mutex);
+         }
       }
    }
    if (size) {
@@ -129,6 +132,7 @@
 {
    struct nouveau_pushbuf *push = nv50->base.pushbuf;
    struct nv50_hw_query *hq = nv50_hw_query(q);
+   bool ret = true;
 
    if (hq->funcs && hq->funcs->begin_query)
       return hq->funcs->begin_query(nv50, hq);
@@ -154,6 +158,7 @@
    if (!hq->is64bit)
       hq->data[0] = hq->sequence++; /* the previously used one */
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
    switch (q->type) {
    case PIPE_QUERY_OCCLUSION_COUNTER:
    case PIPE_QUERY_OCCLUSION_PREDICATE:
@@ -194,10 +199,13 @@
       break;
    default:
       assert(0);
-      return false;
+      ret = false;
+      break;
    }
-   hq->state = NV50_HW_QUERY_STATE_ACTIVE;
-   return true;
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
+   if (ret)
+      hq->state = NV50_HW_QUERY_STATE_ACTIVE;
+   return ret;
 }
 
 static void
@@ -213,6 +221,7 @@
 
    hq->state = NV50_HW_QUERY_STATE_ENDED;
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
    switch (q->type) {
    case PIPE_QUERY_OCCLUSION_COUNTER:
    case PIPE_QUERY_OCCLUSION_PREDICATE:
@@ -266,6 +275,7 @@
       assert(0);
       break;
    }
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
    if (hq->is64bit)
       nouveau_fence_ref(nv50->screen->base.fence.current, &hq->fence);
 }
@@ -288,16 +298,21 @@
       nv50_hw_query_update(q);
 
    if (hq->state != NV50_HW_QUERY_STATE_READY) {
+      pipe_mutex_lock(nv50->screen->base.push_mutex);
       if (!wait) {
          /* for broken apps that spin on GL_QUERY_RESULT_AVAILABLE */
          if (hq->state != NV50_HW_QUERY_STATE_FLUSHED) {
             hq->state = NV50_HW_QUERY_STATE_FLUSHED;
             PUSH_KICK(nv50->base.pushbuf);
          }
+         pipe_mutex_unlock(nv50->screen->base.push_mutex);
          return false;
       }
-      if (nouveau_bo_wait(hq->bo, NOUVEAU_BO_RD, nv50->screen->base.client))
+      if (nouveau_bo_wait(hq->bo, NOUVEAU_BO_RD, nv50->screen->base.client)) {
+         pipe_mutex_unlock(nv50->screen->base.push_mutex);
          return false;
+      }
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
    }
    hq->state = NV50_HW_QUERY_STATE_READY;
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_query_hw_sm.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_query_hw_sm.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_query_hw_sm.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_query_hw_sm.c	2018-05-22 11:17:46.307742617 +0200
@@ -176,6 +176,7 @@
       return false;
    }
 
+   pipe_mutex_lock(screen->base.push_mutex);
    assert(cfg->num_counters <= 4);
    PUSH_SPACE(push, 4 * 4);
 
@@ -208,6 +209,7 @@
       BEGIN_NV04(push, NV50_CP(MP_PM_SET(c)), 1);
       PUSH_DATA (push, 0);
    }
+   pipe_mutex_unlock(screen->base.push_mutex);
    return true;
 }
 
@@ -237,6 +239,7 @@
       screen->pm.prog = prog;
    }
 
+   pipe_mutex_lock(screen->base.push_mutex);
    /* disable all counting */
    PUSH_SPACE(push, 8);
    for (c = 0; c < 4; c++) {
@@ -260,6 +263,7 @@
    PUSH_SPACE(push, 2);
    BEGIN_NV04(push, SUBC_CP(NV50_GRAPH_SERIALIZE), 1);
    PUSH_DATA (push, 0);
+   pipe_mutex_unlock(screen->base.push_mutex);
 
    pipe->bind_compute_state(pipe, screen->pm.prog);
    input[0] = hq->bo->offset + hq->base_offset;
@@ -276,6 +280,7 @@
 
    nouveau_bufctx_reset(nv50->bufctx_cp, NV50_BIND_CP_QUERY);
 
+   pipe_mutex_lock(screen->base.push_mutex);
    /* re-active other counters */
    PUSH_SPACE(push, 8);
    mask = 0;
@@ -302,6 +307,7 @@
                     | cfg->ctr[i].unit | cfg->ctr[i].mode);
       }
    }
+   pipe_mutex_unlock(screen->base.push_mutex);
 }
 
 static inline bool
@@ -343,7 +349,9 @@
 
    cfg = nv50_hw_sm_query_get_cfg(nv50, hq);
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
    ret = nv50_hw_sm_query_read_data(count, nv50, wait, hq, cfg, mp_count);
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
    if (!ret)
       return false;
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_surface.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_surface.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_surface.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_surface.c	2018-05-22 11:17:46.308742617 +0200
@@ -204,10 +204,13 @@
    bool m2mf;
    unsigned dst_layer = dstz, src_layer = src_box->z;
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
+
    if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
       nouveau_copy_buffer(&nv50->base,
                           nv04_resource(dst), dstx,
                           nv04_resource(src), src_box->x, src_box->width);
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       return;
    }
 
@@ -247,6 +250,7 @@
          else
             srect.base += src_mt->layer_stride;
       }
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       return;
    }
 
@@ -270,6 +274,7 @@
          break;
    }
    nouveau_bufctx_reset(nv50->bufctx, NV50_BIND_2D);
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
 }
 
 static void
@@ -289,14 +294,18 @@
 
    assert(dst->texture->target != PIPE_BUFFER);
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
+
    BEGIN_NV04(push, NV50_3D(CLEAR_COLOR(0)), 4);
    PUSH_DATAf(push, color->f[0]);
    PUSH_DATAf(push, color->f[1]);
    PUSH_DATAf(push, color->f[2]);
    PUSH_DATAf(push, color->f[3]);
 
-   if (nouveau_pushbuf_space(push, 64 + sf->depth, 1, 0))
+   if (nouveau_pushbuf_space(push, 64 + sf->depth, 1, 0)) {
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       return;
+   }
 
    PUSH_REFN(push, bo, mt->base.domain | NOUVEAU_BO_WR);
 
@@ -358,6 +367,8 @@
       PUSH_DATA (push, nv50->cond_condmode);
    }
 
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
+
    nv50->dirty_3d |= NV50_NEW_3D_FRAMEBUFFER | NV50_NEW_3D_SCISSOR;
 }
 
@@ -382,6 +393,8 @@
    assert(dst->texture->target != PIPE_BUFFER);
    assert(nouveau_bo_memtype(bo)); /* ZETA cannot be linear */
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
+
    if (clear_flags & PIPE_CLEAR_DEPTH) {
       BEGIN_NV04(push, NV50_3D(CLEAR_DEPTH), 1);
       PUSH_DATAf(push, depth);
@@ -394,8 +407,10 @@
       mode |= NV50_3D_CLEAR_BUFFERS_S;
    }
 
-   if (nouveau_pushbuf_space(push, 64 + sf->depth, 1, 0))
+   if (nouveau_pushbuf_space(push, 64 + sf->depth, 1, 0)) {
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       return;
+   }
 
    PUSH_REFN(push, bo, mt->base.domain | NOUVEAU_BO_WR);
 
@@ -446,6 +461,8 @@
       PUSH_DATA (push, nv50->cond_condmode);
    }
 
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
+
    nv50->dirty_3d |= NV50_NEW_3D_FRAMEBUFFER | NV50_NEW_3D_SCISSOR;
 }
 
@@ -534,9 +551,12 @@
    unsigned i, j, k;
    uint32_t mode = 0;
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
    /* don't need NEW_BLEND, COLOR_MASK doesn't affect CLEAR_BUFFERS */
-   if (!nv50_state_validate_3d(nv50, NV50_NEW_3D_FRAMEBUFFER))
+   if (!nv50_state_validate_3d(nv50, NV50_NEW_3D_FRAMEBUFFER)) {
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       return;
+   }
 
    /* We have to clear ALL of the layers, not up to the min number of layers
     * of any attachment. */
@@ -602,6 +622,7 @@
    /* restore the array mode */
    BEGIN_NV04(push, NV50_3D(RT_ARRAY_MODE), 1);
    PUSH_DATA (push, nv50->rt_array_mode);
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
 }
 
 static void
@@ -728,14 +749,18 @@
 
    assert(size % data_size == 0);
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
+
    if (offset & 0xff) {
       unsigned fixup_size = MIN2(size, align(offset, 0x100) - offset);
       assert(fixup_size % data_size == 0);
       nv50_clear_buffer_push(pipe, res, offset, fixup_size, data, data_size);
       offset += fixup_size;
       size -= fixup_size;
-      if (!size)
+      if (!size) {
+         pipe_mutex_unlock(nv50->screen->base.push_mutex);
          return;
+      }
    }
 
    elements = size / data_size;
@@ -751,8 +776,10 @@
    PUSH_DATA (push, color.ui[2]);
    PUSH_DATA (push, color.ui[3]);
 
-   if (nouveau_pushbuf_space(push, 64, 1, 0))
+   if (nouveau_pushbuf_space(push, 64, 1, 0)) {
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       return;
+   }
 
    PUSH_REFN(push, buf->bo, buf->domain | NOUVEAU_BO_WR);
 
@@ -804,6 +831,8 @@
                              data, data_size);
    }
 
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
+
    nv50->dirty_3d |= NV50_NEW_3D_FRAMEBUFFER | NV50_NEW_3D_SCISSOR;
 }
 
@@ -1720,6 +1749,8 @@
         info->src.box.height != -info->dst.box.height))
       eng3d = true;
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
+
    if (nv50->screen->num_occlusion_queries_active) {
       BEGIN_NV04(push, NV50_3D(SAMPLECNT_ENABLE), 1);
       PUSH_DATA (push, 0);
@@ -1734,6 +1765,8 @@
       BEGIN_NV04(push, NV50_3D(SAMPLECNT_ENABLE), 1);
       PUSH_DATA (push, 1);
    }
+
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
 }
 
 static void
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_transfer.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_transfer.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_transfer.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_transfer.c	2018-05-22 11:17:46.308742617 +0200
@@ -304,6 +304,7 @@
       unsigned base = tx->rect[0].base;
       unsigned z = tx->rect[0].z;
       unsigned i;
+      pipe_mutex_lock(nv50->screen->base.push_mutex);
       for (i = 0; i < box->depth; ++i) {
          nv50_m2mf_transfer_rect(nv50, &tx->rect[1], &tx->rect[0],
                                  tx->nblocksx, tx->nblocksy);
@@ -313,6 +314,9 @@
             tx->rect[0].base += mt->layer_stride;
          tx->rect[1].base += size;
       }
+      /* Kick these reads out so we don't have to reacquire a lock below */
+      PUSH_KICK(nv50->base.pushbuf);
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
       tx->rect[0].z = z;
       tx->rect[0].base = base;
       tx->rect[1].base = 0;
@@ -349,6 +353,7 @@
    unsigned i;
 
    if (tx->base.usage & PIPE_TRANSFER_WRITE) {
+      pipe_mutex_lock(nv50->screen->base.push_mutex);
       for (i = 0; i < tx->base.box.depth; ++i) {
          nv50_m2mf_transfer_rect(nv50, &tx->rect[0], &tx->rect[1],
                                  tx->nblocksx, tx->nblocksy);
@@ -362,6 +367,7 @@
       /* Allow the copies above to finish executing before freeing the source */
       nouveau_fence_work(nv50->screen->base.fence.current,
                          nouveau_fence_unref_bo, tx->rect[1].bo);
+      pipe_mutex_unlock(nv50->screen->base.push_mutex);
    } else {
       nouveau_bo_ref(NULL, &tx->rect[1].bo);
    }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_vbo.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_vbo.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nv50/nv50_vbo.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nv50/nv50_vbo.c	2018-05-22 11:17:46.308742617 +0200
@@ -770,6 +770,8 @@
    bool tex_dirty = false;
    int s;
 
+   pipe_mutex_lock(nv50->screen->base.push_mutex);
+
    if (info->index_size && !info->has_user_indices)
       BCTX_REFN(nv50->bufctx_3d, 3D_INDEX, nv04_resource(info->index.resource), RD);
 
@@ -900,4 +902,5 @@
    nouveau_pushbuf_bufctx(push, NULL);
 
    nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_3D_INDEX);
+   pipe_mutex_unlock(nv50->screen->base.push_mutex);
 }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_compute.c	2018-05-22 11:17:46.308742617 +0200
@@ -424,13 +424,17 @@
 nvc0_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
 {
    struct nvc0_context *nvc0 = nvc0_context(pipe);
+   struct nvc0_screen *screen = nvc0->screen;
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    struct nvc0_program *cp = nvc0->compprog;
    int ret;
 
+   pipe_mutex_lock(screen->base.push_mutex);
+
    ret = !nvc0_state_validate_cp(nvc0, ~0);
    if (ret) {
       NOUVEAU_ERR("Failed to launch grid !\n");
+      pipe_mutex_unlock(screen->base.push_mutex);
       return;
    }
 
@@ -498,4 +502,6 @@
    nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_SUF);
    nvc0->dirty_cp |= NVC0_NEW_CP_SURFACES;
    nvc0->images_dirty[5] |= nvc0->images_valid[5];
+
+   pipe_mutex_unlock(screen->base.push_mutex);
 }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_context.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_context.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_context.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_context.c	2018-05-22 11:17:46.308742617 +0200
@@ -39,7 +39,9 @@
    if (fence)
       nouveau_fence_ref(screen->fence.current, (struct nouveau_fence **)fence);
 
+   pipe_mutex_lock(screen->push_mutex);
    PUSH_KICK(nvc0->base.pushbuf); /* fencing handled in kick_notify */
+   pipe_mutex_unlock(screen->push_mutex);
 
    nouveau_context_update_frame_stats(&nvc0->base);
 }
@@ -49,8 +51,10 @@
 {
    struct nouveau_pushbuf *push = nvc0_context(pipe)->base.pushbuf;
 
+   pipe_mutex_lock(nvc0_context(pipe)->screen->base.push_mutex);
    IMMED_NVC0(push, NVC0_3D(SERIALIZE), 0);
    IMMED_NVC0(push, NVC0_3D(TEX_CACHE_CTL), 0);
+   pipe_mutex_unlock(nvc0_context(pipe)->screen->base.push_mutex);
 }
 
 static void
@@ -60,6 +64,8 @@
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    int i, s;
 
+   pipe_mutex_lock(nvc0_context(pipe)->screen->base.push_mutex);
+
    if (flags & PIPE_BARRIER_MAPPED_BUFFER) {
       for (i = 0; i < nvc0->num_vtxbufs; ++i) {
          if (!nvc0->vtxbuf[i].buffer.resource && !nvc0->vtxbuf[i].is_user_buffer)
@@ -105,6 +111,8 @@
       nvc0->cb_dirty = true;
    if (flags & (PIPE_BARRIER_VERTEX_BUFFER | PIPE_BARRIER_INDEX_BUFFER))
       nvc0->base.vbo_dirty = true;
+
+   pipe_mutex_unlock(nvc0_context(pipe)->screen->base.push_mutex);
 }
 
 static void
@@ -121,6 +129,7 @@
       data_words = string_words;
    else
       data_words = string_words + !!(len & 3);
+   pipe_mutex_lock(nvc0_context(pipe)->screen->base.push_mutex);
    BEGIN_NIC0(push, SUBC_3D(NV04_GRAPH_NOP), data_words);
    if (string_words)
       PUSH_DATAp(push, str, string_words);
@@ -129,6 +138,7 @@
       memcpy(&data, &str[string_words * 4], len & 3);
       PUSH_DATA (push, data);
    }
+   pipe_mutex_unlock(nvc0_context(pipe)->screen->base.push_mutex);
 }
 
 static void
@@ -366,6 +376,8 @@
       return NULL;
    pipe = &nvc0->base.pipe;
 
+   pipe_mutex_lock(screen->base.push_mutex);
+
    if (!nvc0_blitctx_create(nvc0))
       goto out_err;
 
@@ -478,12 +490,15 @@
 
    util_dynarray_init(&nvc0->global_residents, NULL);
 
+   pipe_mutex_unlock(screen->base.push_mutex);
+
    return pipe;
 
 out_err:
    if (nvc0) {
       if (pipe->stream_uploader)
          u_upload_destroy(pipe->stream_uploader);
+      pipe_mutex_unlock(screen->base.push_mutex);
       if (nvc0->bufctx_3d)
          nouveau_bufctx_del(&nvc0->bufctx_3d);
       if (nvc0->bufctx_cp)
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_context.h mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_context.h	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_context.h	2018-05-22 11:17:46.308742617 +0200
@@ -318,6 +318,11 @@
                                     uint32_t label);
 void nvc0_program_init_tcp_empty(struct nvc0_context *);
 
+/* nvc0_query.c */
+void nvc0_render_condition(struct pipe_context *pipe,
+                           struct pipe_query *pq,
+                           boolean condition, uint mode);
+
 /* nvc0_shader_state.c */
 void nvc0_vertprog_validate(struct nvc0_context *);
 void nvc0_tctlprog_validate(struct nvc0_context *);
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query.c	2018-05-22 11:17:46.308742617 +0200
@@ -92,7 +92,7 @@
                                        index, resource, offset);
 }
 
-static void
+void
 nvc0_render_condition(struct pipe_context *pipe,
                       struct pipe_query *pq,
                       boolean condition, enum pipe_render_cond_flag mode)
@@ -171,6 +171,16 @@
    }
 }
 
+static void
+nvc0_render_condition_locked(struct pipe_context *pipe,
+                             struct pipe_query *pq,
+                             boolean condition, uint mode)
+{
+   pipe_mutex_lock(nouveau_context(pipe)->screen->push_mutex);
+   nvc0_render_condition(pipe, pq, condition, mode);
+   pipe_mutex_unlock(nouveau_context(pipe)->screen->push_mutex);
+}
+
 int
 nvc0_screen_get_driver_query_info(struct pipe_screen *pscreen,
                                   unsigned id,
@@ -280,6 +290,6 @@
    pipe->get_query_result = nvc0_get_query_result;
    pipe->get_query_result_resource = nvc0_get_query_result_resource;
    pipe->set_active_query_state = nvc0_set_active_query_state;
-   pipe->render_condition = nvc0_render_condition;
+   pipe->render_condition = nvc0_render_condition_locked;
    nvc0->cond_condmode = NVC0_3D_COND_MODE_ALWAYS;
 }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c	2018-05-22 11:29:32.371719723 +0200
@@ -48,9 +48,12 @@
       if (hq->mm) {
          if (hq->state == NVC0_HW_QUERY_STATE_READY)
             nouveau_mm_free(hq->mm);
-         else
+         else {
+            pipe_mutex_lock(screen->base.push_mutex);
             nouveau_fence_work(screen->base.fence.current,
                                nouveau_mm_free_work, hq->mm);
+            pipe_mutex_unlock(screen->base.push_mutex);
+         }
       }
    }
    if (size) {
@@ -154,6 +157,7 @@
    }
    hq->sequence++;
 
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
    switch (q->type) {
    case PIPE_QUERY_OCCLUSION_COUNTER:
    case PIPE_QUERY_OCCLUSION_PREDICATE:
@@ -203,6 +207,7 @@
    default:
       break;
    }
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
    hq->state = NVC0_HW_QUERY_STATE_ACTIVE;
    return ret;
 }
@@ -226,6 +231,7 @@
    }
    hq->state = NVC0_HW_QUERY_STATE_ENDED;
 
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
    switch (q->type) {
    case PIPE_QUERY_OCCLUSION_COUNTER:
    case PIPE_QUERY_OCCLUSION_PREDICATE:
@@ -283,6 +289,7 @@
    default:
       break;
    }
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
    if (hq->is64bit)
       nouveau_fence_ref(nvc0->screen->base.fence.current, &hq->fence);
 }
@@ -305,16 +312,21 @@
       nvc0_hw_query_update(nvc0->screen->base.client, q);
 
    if (hq->state != NVC0_HW_QUERY_STATE_READY) {
+      pipe_mutex_lock(nvc0->screen->base.push_mutex);
       if (!wait) {
          if (hq->state != NVC0_HW_QUERY_STATE_FLUSHED) {
             hq->state = NVC0_HW_QUERY_STATE_FLUSHED;
             /* flush for silly apps that spin on GL_QUERY_RESULT_AVAILABLE */
             PUSH_KICK(nvc0->base.pushbuf);
          }
+         pipe_mutex_unlock(nvc0->screen->base.push_mutex);
          return false;
       }
-      if (nouveau_bo_wait(hq->bo, NOUVEAU_BO_RD, nvc0->screen->base.client))
+      if (nouveau_bo_wait(hq->bo, NOUVEAU_BO_RD, nvc0->screen->base.client)) {
+         pipe_mutex_unlock(nvc0->screen->base.push_mutex);
          return false;
+      }
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       NOUVEAU_DRV_STAT(&nvc0->screen->base, query_sync_count, 1);
    }
    hq->state = NVC0_HW_QUERY_STATE_READY;
@@ -384,6 +396,8 @@
 
    assert(!hq->funcs || !hq->funcs->get_query_result);
 
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+
    if (index == -1) {
       /* TODO: Use a macro to write the availability of the query */
       if (hq->state != NVC0_HW_QUERY_STATE_READY)
@@ -397,6 +411,8 @@
                      offset + (result_type >= PIPE_QUERY_TYPE_I64 ? 8 : 4));
 
       nvc0_resource_validate(buf, NOUVEAU_BO_WR);
+      
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
 
       return;
    }
@@ -491,6 +507,8 @@
    }
    PUSH_DATAh(push, buf->address + offset);
    PUSH_DATA (push, buf->address + offset);
+   
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
 
    util_range_add(&buf->valid_buffer_range, offset,
                   offset + (result_type >= PIPE_QUERY_TYPE_I64 ? 8 : 4));
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c~ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c~
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c~	1970-01-01 01:00:00.000000000 +0100
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw.c~	2018-05-22 11:28:50.000000000 +0200
@@ -0,0 +1,662 @@
+/*
+ * Copyright 2011 Christoph Bumiller
+ * Copyright 2015 Samuel Pitoiset
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#define NVC0_PUSH_EXPLICIT_SPACE_CHECKING
+
+#include "nvc0/nvc0_context.h"
+#include "nvc0/nvc0_query_hw.h"
+#include "nvc0/nvc0_query_hw_metric.h"
+#include "nvc0/nvc0_query_hw_sm.h"
+
+#define NVC0_HW_QUERY_STATE_READY   0
+#define NVC0_HW_QUERY_STATE_ACTIVE  1
+#define NVC0_HW_QUERY_STATE_ENDED   2
+#define NVC0_HW_QUERY_STATE_FLUSHED 3
+
+#define NVC0_HW_QUERY_ALLOC_SPACE 256
+
+bool
+nvc0_hw_query_allocate(struct nvc0_context *nvc0, struct nvc0_query *q,
+                       int size)
+{
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+   struct nvc0_screen *screen = nvc0->screen;
+   int ret;
+
+   if (hq->bo) {
+      nouveau_bo_ref(NULL, &hq->bo);
+      if (hq->mm) {
+         if (hq->state == NVC0_HW_QUERY_STATE_READY)
+            nouveau_mm_free(hq->mm);
+         else {
+            pipe_mutex_lock(screen->base.push_mutex);
+            nouveau_fence_work(screen->base.fence.current,
+                               nouveau_mm_free_work, hq->mm);
+            pipe_mutex_unlock(screen->base.push_mutex);
+         }
+      }
+   }
+   if (size) {
+      hq->mm = nouveau_mm_allocate(screen->base.mm_GART, size, &hq->bo,
+                                   &hq->base_offset);
+      if (!hq->bo)
+         return false;
+      hq->offset = hq->base_offset;
+
+      ret = nouveau_bo_map(hq->bo, 0, screen->base.client);
+      if (ret) {
+         nvc0_hw_query_allocate(nvc0, q, 0);
+         return false;
+      }
+      hq->data = (uint32_t *)((uint8_t *)hq->bo->map + hq->base_offset);
+   }
+   return true;
+}
+
+static void
+nvc0_hw_query_get(struct nouveau_pushbuf *push, struct nvc0_query *q,
+                  unsigned offset, uint32_t get)
+{
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+
+   offset += hq->offset;
+
+   PUSH_SPACE(push, 5);
+   PUSH_REFN (push, hq->bo, NOUVEAU_BO_GART | NOUVEAU_BO_WR);
+   BEGIN_NVC0(push, NVC0_3D(QUERY_ADDRESS_HIGH), 4);
+   PUSH_DATAh(push, hq->bo->offset + offset);
+   PUSH_DATA (push, hq->bo->offset + offset);
+   PUSH_DATA (push, hq->sequence);
+   PUSH_DATA (push, get);
+}
+
+static void
+nvc0_hw_query_rotate(struct nvc0_context *nvc0, struct nvc0_query *q)
+{
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+
+   hq->offset += hq->rotate;
+   hq->data += hq->rotate / sizeof(*hq->data);
+   if (hq->offset - hq->base_offset == NVC0_HW_QUERY_ALLOC_SPACE)
+      nvc0_hw_query_allocate(nvc0, q, NVC0_HW_QUERY_ALLOC_SPACE);
+}
+
+static inline void
+nvc0_hw_query_update(struct nouveau_client *cli, struct nvc0_query *q)
+{
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+
+   if (hq->is64bit) {
+      if (nouveau_fence_signalled(hq->fence))
+         hq->state = NVC0_HW_QUERY_STATE_READY;
+   } else {
+      if (hq->data[0] == hq->sequence)
+         hq->state = NVC0_HW_QUERY_STATE_READY;
+   }
+}
+
+static void
+nvc0_hw_destroy_query(struct nvc0_context *nvc0, struct nvc0_query *q)
+{
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+
+   if (hq->funcs && hq->funcs->destroy_query) {
+      hq->funcs->destroy_query(nvc0, hq);
+      return;
+   }
+
+   nvc0_hw_query_allocate(nvc0, q, 0);
+   nouveau_fence_ref(NULL, &hq->fence);
+   FREE(hq);
+}
+
+static boolean
+nvc0_hw_begin_query(struct nvc0_context *nvc0, struct nvc0_query *q)
+{
+   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+   bool ret = true;
+
+   if (hq->funcs && hq->funcs->begin_query)
+      return hq->funcs->begin_query(nvc0, hq);
+
+   /* For occlusion queries we have to change the storage, because a previous
+    * query might set the initial render conition to false even *after* we re-
+    * initialized it to true.
+    */
+   if (hq->rotate) {
+      nvc0_hw_query_rotate(nvc0, q);
+
+      /* XXX: can we do this with the GPU, and sync with respect to a previous
+       *  query ?
+       */
+      hq->data[0] = hq->sequence; /* initialize sequence */
+      hq->data[1] = 1; /* initial render condition = true */
+      hq->data[4] = hq->sequence + 1; /* for comparison COND_MODE */
+      hq->data[5] = 0;
+   }
+   hq->sequence++;
+
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+   switch (q->type) {
+   case PIPE_QUERY_OCCLUSION_COUNTER:
+   case PIPE_QUERY_OCCLUSION_PREDICATE:
+   case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
+      hq->nesting = nvc0->screen->num_occlusion_queries_active++;
+      if (hq->nesting) {
+         nvc0_hw_query_get(push, q, 0x10, 0x0100f002);
+      } else {
+         PUSH_SPACE(push, 3);
+         BEGIN_NVC0(push, NVC0_3D(COUNTER_RESET), 1);
+         PUSH_DATA (push, NVC0_3D_COUNTER_RESET_SAMPLECNT);
+         IMMED_NVC0(push, NVC0_3D(SAMPLECNT_ENABLE), 1);
+      }
+      break;
+   case PIPE_QUERY_PRIMITIVES_GENERATED:
+      nvc0_hw_query_get(push, q, 0x10, 0x09005002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_PRIMITIVES_EMITTED:
+      nvc0_hw_query_get(push, q, 0x10, 0x05805002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_SO_STATISTICS:
+      nvc0_hw_query_get(push, q, 0x20, 0x05805002 | (q->index << 5));
+      nvc0_hw_query_get(push, q, 0x30, 0x06805002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_SO_OVERFLOW_PREDICATE:
+      nvc0_hw_query_get(push, q, 0x10, 0x03005002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_SO_OVERFLOW_ANY_PREDICATE:
+      /* XXX: This get actually writes the number of overflowed streams */
+      nvc0_hw_query_get(push, q, 0x10, 0x0f005002);
+      break;
+   case PIPE_QUERY_TIME_ELAPSED:
+      nvc0_hw_query_get(push, q, 0x10, 0x00005002);
+      break;
+   case PIPE_QUERY_PIPELINE_STATISTICS:
+      nvc0_hw_query_get(push, q, 0xc0 + 0x00, 0x00801002); /* VFETCH, VERTICES */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x10, 0x01801002); /* VFETCH, PRIMS */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x20, 0x02802002); /* VP, LAUNCHES */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x30, 0x03806002); /* GP, LAUNCHES */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x40, 0x04806002); /* GP, PRIMS_OUT */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x50, 0x07804002); /* RAST, PRIMS_IN */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x60, 0x08804002); /* RAST, PRIMS_OUT */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x70, 0x0980a002); /* ROP, PIXELS */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x80, 0x0d808002); /* TCP, LAUNCHES */
+      nvc0_hw_query_get(push, q, 0xc0 + 0x90, 0x0e809002); /* TEP, LAUNCHES */
+      break;
+   default:
+      break;
+   }
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
+   hq->state = NVC0_HW_QUERY_STATE_ACTIVE;
+   return ret;
+}
+
+static void
+nvc0_hw_end_query(struct nvc0_context *nvc0, struct nvc0_query *q)
+{
+   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+
+   if (hq->funcs && hq->funcs->end_query) {
+      hq->funcs->end_query(nvc0, hq);
+      return;
+   }
+
+   if (hq->state != NVC0_HW_QUERY_STATE_ACTIVE) {
+      /* some queries don't require 'begin' to be called (e.g. GPU_FINISHED) */
+      if (hq->rotate)
+         nvc0_hw_query_rotate(nvc0, q);
+      hq->sequence++;
+   }
+   hq->state = NVC0_HW_QUERY_STATE_ENDED;
+
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+   switch (q->type) {
+   case PIPE_QUERY_OCCLUSION_COUNTER:
+   case PIPE_QUERY_OCCLUSION_PREDICATE:
+   case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
+      nvc0_hw_query_get(push, q, 0, 0x0100f002);
+      if (--nvc0->screen->num_occlusion_queries_active == 0) {
+         PUSH_SPACE(push, 1);
+         IMMED_NVC0(push, NVC0_3D(SAMPLECNT_ENABLE), 0);
+      }
+      break;
+   case PIPE_QUERY_PRIMITIVES_GENERATED:
+      nvc0_hw_query_get(push, q, 0, 0x09005002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_PRIMITIVES_EMITTED:
+      nvc0_hw_query_get(push, q, 0, 0x05805002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_SO_STATISTICS:
+      nvc0_hw_query_get(push, q, 0x00, 0x05805002 | (q->index << 5));
+      nvc0_hw_query_get(push, q, 0x10, 0x06805002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_SO_OVERFLOW_PREDICATE:
+      nvc0_hw_query_get(push, q, 0x00, 0x03005002 | (q->index << 5));
+      break;
+   case PIPE_QUERY_SO_OVERFLOW_ANY_PREDICATE:
+      /* XXX: This get actually writes the number of overflowed streams */
+      nvc0_hw_query_get(push, q, 0x00, 0x0f005002);
+      break;
+   case PIPE_QUERY_TIMESTAMP:
+   case PIPE_QUERY_TIME_ELAPSED:
+      nvc0_hw_query_get(push, q, 0, 0x00005002);
+      break;
+   case PIPE_QUERY_GPU_FINISHED:
+      nvc0_hw_query_get(push, q, 0, 0x1000f010);
+      break;
+   case PIPE_QUERY_PIPELINE_STATISTICS:
+      nvc0_hw_query_get(push, q, 0x00, 0x00801002); /* VFETCH, VERTICES */
+      nvc0_hw_query_get(push, q, 0x10, 0x01801002); /* VFETCH, PRIMS */
+      nvc0_hw_query_get(push, q, 0x20, 0x02802002); /* VP, LAUNCHES */
+      nvc0_hw_query_get(push, q, 0x30, 0x03806002); /* GP, LAUNCHES */
+      nvc0_hw_query_get(push, q, 0x40, 0x04806002); /* GP, PRIMS_OUT */
+      nvc0_hw_query_get(push, q, 0x50, 0x07804002); /* RAST, PRIMS_IN */
+      nvc0_hw_query_get(push, q, 0x60, 0x08804002); /* RAST, PRIMS_OUT */
+      nvc0_hw_query_get(push, q, 0x70, 0x0980a002); /* ROP, PIXELS */
+      nvc0_hw_query_get(push, q, 0x80, 0x0d808002); /* TCP, LAUNCHES */
+      nvc0_hw_query_get(push, q, 0x90, 0x0e809002); /* TEP, LAUNCHES */
+      break;
+   case PIPE_QUERY_TIMESTAMP_DISJOINT:
+      /* This query is not issued on GPU because disjoint is forced to false */
+      hq->state = NVC0_HW_QUERY_STATE_READY;
+      break;
+   case NVC0_HW_QUERY_TFB_BUFFER_OFFSET:
+      /* indexed by TFB buffer instead of by vertex stream */
+      nvc0_hw_query_get(push, q, 0x00, 0x0d005002 | (q->index << 5));
+      break;
+   default:
+      break;
+   }
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
+   if (hq->is64bit)
+      nouveau_fence_ref(nvc0->screen->base.fence.current, &hq->fence);
+}
+
+static boolean
+nvc0_hw_get_query_result(struct nvc0_context *nvc0, struct nvc0_query *q,
+                         boolean wait, union pipe_query_result *result)
+{
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+   uint64_t *res64 = (uint64_t*)result;
+   uint32_t *res32 = (uint32_t*)result;
+   uint8_t *res8 = (uint8_t*)result;
+   uint64_t *data64 = (uint64_t *)hq->data;
+   unsigned i;
+
+   if (hq->funcs && hq->funcs->get_query_result)
+      return hq->funcs->get_query_result(nvc0, hq, wait, result);
+
+   if (hq->state != NVC0_HW_QUERY_STATE_READY)
+      nvc0_hw_query_update(nvc0->screen->base.client, q);
+
+   if (hq->state != NVC0_HW_QUERY_STATE_READY) {
+      pipe_mutex_lock(nvc0->screen->base.push_mutex);
+      if (!wait) {
+         if (hq->state != NVC0_HW_QUERY_STATE_FLUSHED) {
+            hq->state = NVC0_HW_QUERY_STATE_FLUSHED;
+            /* flush for silly apps that spin on GL_QUERY_RESULT_AVAILABLE */
+            PUSH_KICK(nvc0->base.pushbuf);
+         }
+         pipe_mutex_unlock(nvc0->screen->base.push_mutex);
+         return false;
+      }
+      if (nouveau_bo_wait(hq->bo, NOUVEAU_BO_RD, nvc0->screen->base.client)) {
+         pipe_mutex_unlock(nvc0->screen->base.push_mutex);
+         return false;
+      }
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
+      NOUVEAU_DRV_STAT(&nvc0->screen->base, query_sync_count, 1);
+   }
+   hq->state = NVC0_HW_QUERY_STATE_READY;
+
+   switch (q->type) {
+   case PIPE_QUERY_GPU_FINISHED:
+      res8[0] = true;
+      break;
+   case PIPE_QUERY_OCCLUSION_COUNTER: /* u32 sequence, u32 count, u64 time */
+      res64[0] = hq->data[1] - hq->data[5];
+      break;
+   case PIPE_QUERY_OCCLUSION_PREDICATE:
+   case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
+      res8[0] = hq->data[1] != hq->data[5];
+      break;
+   case PIPE_QUERY_PRIMITIVES_GENERATED: /* u64 count, u64 time */
+   case PIPE_QUERY_PRIMITIVES_EMITTED: /* u64 count, u64 time */
+      res64[0] = data64[0] - data64[2];
+      break;
+   case PIPE_QUERY_SO_STATISTICS:
+      res64[0] = data64[0] - data64[4];
+      res64[1] = data64[2] - data64[6];
+      break;
+   case PIPE_QUERY_SO_OVERFLOW_PREDICATE:
+   case PIPE_QUERY_SO_OVERFLOW_ANY_PREDICATE:
+      res8[0] = data64[0] != data64[2];
+      break;
+   case PIPE_QUERY_TIMESTAMP:
+      res64[0] = data64[1];
+      break;
+   case PIPE_QUERY_TIMESTAMP_DISJOINT:
+      res64[0] = 1000000000;
+      res8[8] = false;
+      break;
+   case PIPE_QUERY_TIME_ELAPSED:
+      res64[0] = data64[1] - data64[3];
+      break;
+   case PIPE_QUERY_PIPELINE_STATISTICS:
+      for (i = 0; i < 10; ++i)
+         res64[i] = data64[i * 2] - data64[24 + i * 2];
+      result->pipeline_statistics.cs_invocations = 0;
+      break;
+   case NVC0_HW_QUERY_TFB_BUFFER_OFFSET:
+      res32[0] = hq->data[1];
+      break;
+   default:
+      assert(0); /* can't happen, we don't create queries with invalid type */
+      return false;
+   }
+
+   return true;
+}
+
+static void
+nvc0_hw_get_query_result_resource(struct nvc0_context *nvc0,
+                                  struct nvc0_query *q,
+                                  boolean wait,
+                                  enum pipe_query_value_type result_type,
+                                  int index,
+                                  struct pipe_resource *resource,
+                                  unsigned offset)
+{
+   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+   struct nv04_resource *buf = nv04_resource(resource);
+   unsigned qoffset = 0, stride;
+
+   assert(!hq->funcs || !hq->funcs->get_query_result);
+
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+
+   if (index == -1) {
+      /* TODO: Use a macro to write the availability of the query */
+      if (hq->state != NVC0_HW_QUERY_STATE_READY)
+         nvc0_hw_query_update(nvc0->screen->base.client, q);
+      uint32_t ready[2] = {hq->state == NVC0_HW_QUERY_STATE_READY};
+      nvc0->base.push_cb(&nvc0->base, buf, offset,
+                         result_type >= PIPE_QUERY_TYPE_I64 ? 2 : 1,
+                         ready);
+
+      util_range_add(&buf->valid_buffer_range, offset,
+                     offset + (result_type >= PIPE_QUERY_TYPE_I64 ? 8 : 4));
+
+      nvc0_resource_validate(buf, NOUVEAU_BO_WR);
+      
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
+
+      return;
+   }
+
+   /* If the fence guarding this query has not been emitted, that makes a lot
+    * of the following logic more complicated.
+    */
+   if (hq->is64bit && hq->fence->state < NOUVEAU_FENCE_STATE_EMITTED)
+      nouveau_fence_emit(hq->fence);
+
+   /* We either need to compute a 32- or 64-bit difference between 2 values,
+    * and then store the result as either a 32- or 64-bit value. As such let's
+    * treat all inputs as 64-bit (and just push an extra 0 for the 32-bit
+    * ones), and have one macro that clamps result to i32, u32, or just
+    * outputs the difference (no need to worry about 64-bit clamping).
+    */
+   if (hq->state != NVC0_HW_QUERY_STATE_READY)
+      nvc0_hw_query_update(nvc0->screen->base.client, q);
+
+   if (wait && hq->state != NVC0_HW_QUERY_STATE_READY)
+      nvc0_hw_query_fifo_wait(nvc0, q);
+
+   nouveau_pushbuf_space(push, 32, 2, 0);
+   PUSH_REFN (push, hq->bo, NOUVEAU_BO_GART | NOUVEAU_BO_RD);
+   PUSH_REFN (push, buf->bo, buf->domain | NOUVEAU_BO_WR);
+   BEGIN_1IC0(push, NVC0_3D(MACRO_QUERY_BUFFER_WRITE), 9);
+   switch (q->type) {
+   case PIPE_QUERY_OCCLUSION_PREDICATE:
+   case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE: /* XXX what if 64-bit? */
+   case PIPE_QUERY_SO_OVERFLOW_PREDICATE:
+   case PIPE_QUERY_SO_OVERFLOW_ANY_PREDICATE:
+      PUSH_DATA(push, 0x00000001);
+      break;
+   default:
+      if (result_type == PIPE_QUERY_TYPE_I32)
+         PUSH_DATA(push, 0x7fffffff);
+      else if (result_type == PIPE_QUERY_TYPE_U32)
+         PUSH_DATA(push, 0xffffffff);
+      else
+         PUSH_DATA(push, 0x00000000);
+      break;
+   }
+
+   switch (q->type) {
+   case PIPE_QUERY_SO_STATISTICS:
+      stride = 2;
+      break;
+   case PIPE_QUERY_PIPELINE_STATISTICS:
+      stride = 12;
+      break;
+   case PIPE_QUERY_TIME_ELAPSED:
+   case PIPE_QUERY_TIMESTAMP:
+      qoffset = 8;
+      /* fallthrough */
+   default:
+      assert(index == 0);
+      stride = 1;
+      break;
+   }
+
+   if (hq->is64bit || qoffset) {
+      nouveau_pushbuf_data(push, hq->bo, hq->offset + qoffset + 16 * index,
+                           8 | NVC0_IB_ENTRY_1_NO_PREFETCH);
+      if (q->type == PIPE_QUERY_TIMESTAMP) {
+         PUSH_DATA(push, 0);
+         PUSH_DATA(push, 0);
+      } else {
+         nouveau_pushbuf_data(push, hq->bo, hq->offset + qoffset +
+                              16 * (index + stride),
+                              8 | NVC0_IB_ENTRY_1_NO_PREFETCH);
+      }
+   } else {
+      nouveau_pushbuf_data(push, hq->bo, hq->offset + 4,
+                           4 | NVC0_IB_ENTRY_1_NO_PREFETCH);
+      PUSH_DATA(push, 0);
+      nouveau_pushbuf_data(push, hq->bo, hq->offset + 16 + 4,
+                           4 | NVC0_IB_ENTRY_1_NO_PREFETCH);
+      PUSH_DATA(push, 0);
+   }
+
+   if (wait || hq->state == NVC0_HW_QUERY_STATE_READY) {
+      PUSH_DATA(push, 0);
+      PUSH_DATA(push, 0);
+   } else if (hq->is64bit) {
+      PUSH_DATA(push, hq->fence->sequence);
+      nouveau_pushbuf_data(push, nvc0->screen->fence.bo, 0,
+                           4 | NVC0_IB_ENTRY_1_NO_PREFETCH);
+   } else {
+      PUSH_DATA(push, hq->sequence);
+      nouveau_pushbuf_data(push, hq->bo, hq->offset,
+                           4 | NVC0_IB_ENTRY_1_NO_PREFETCH);
+   }
+   PUSH_DATAh(push, buf->address + offset);
+   PUSH_DATA (push, buf->address + offset);
+
+   util_range_add(&buf->valid_buffer_range, offset,
+                  offset + (result_type >= PIPE_QUERY_TYPE_I64 ? 8 : 4));
+
+   nvc0_resource_validate(buf, NOUVEAU_BO_WR);
+}
+
+static const struct nvc0_query_funcs hw_query_funcs = {
+   .destroy_query = nvc0_hw_destroy_query,
+   .begin_query = nvc0_hw_begin_query,
+   .end_query = nvc0_hw_end_query,
+   .get_query_result = nvc0_hw_get_query_result,
+   .get_query_result_resource = nvc0_hw_get_query_result_resource,
+};
+
+struct nvc0_query *
+nvc0_hw_create_query(struct nvc0_context *nvc0, unsigned type, unsigned index)
+{
+   struct nvc0_hw_query *hq;
+   struct nvc0_query *q;
+   unsigned space = NVC0_HW_QUERY_ALLOC_SPACE;
+
+   hq = nvc0_hw_sm_create_query(nvc0, type);
+   if (hq) {
+      hq->base.funcs = &hw_query_funcs;
+      return (struct nvc0_query *)hq;
+   }
+
+   hq = nvc0_hw_metric_create_query(nvc0, type);
+   if (hq) {
+      hq->base.funcs = &hw_query_funcs;
+      return (struct nvc0_query *)hq;
+   }
+
+   hq = CALLOC_STRUCT(nvc0_hw_query);
+   if (!hq)
+      return NULL;
+
+   q = &hq->base;
+   q->funcs = &hw_query_funcs;
+   q->type = type;
+   q->index = index;
+
+   switch (q->type) {
+   case PIPE_QUERY_OCCLUSION_COUNTER:
+   case PIPE_QUERY_OCCLUSION_PREDICATE:
+   case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
+      hq->rotate = 32;
+      space = NVC0_HW_QUERY_ALLOC_SPACE;
+      break;
+   case PIPE_QUERY_PIPELINE_STATISTICS:
+      hq->is64bit = true;
+      space = 512;
+      break;
+   case PIPE_QUERY_SO_STATISTICS:
+      hq->is64bit = true;
+      space = 64;
+      break;
+   case PIPE_QUERY_SO_OVERFLOW_PREDICATE:
+   case PIPE_QUERY_SO_OVERFLOW_ANY_PREDICATE:
+   case PIPE_QUERY_PRIMITIVES_GENERATED:
+   case PIPE_QUERY_PRIMITIVES_EMITTED:
+      hq->is64bit = true;
+      space = 32;
+      break;
+   case PIPE_QUERY_TIME_ELAPSED:
+   case PIPE_QUERY_TIMESTAMP:
+   case PIPE_QUERY_TIMESTAMP_DISJOINT:
+   case PIPE_QUERY_GPU_FINISHED:
+      space = 32;
+      break;
+   case NVC0_HW_QUERY_TFB_BUFFER_OFFSET:
+      space = 16;
+      break;
+   default:
+      debug_printf("invalid query type: %u\n", type);
+      FREE(q);
+      return NULL;
+   }
+
+   if (!nvc0_hw_query_allocate(nvc0, q, space)) {
+      FREE(hq);
+      return NULL;
+   }
+
+   if (hq->rotate) {
+      /* we advance before query_begin ! */
+      hq->offset -= hq->rotate;
+      hq->data -= hq->rotate / sizeof(*hq->data);
+   } else
+   if (!hq->is64bit)
+      hq->data[0] = 0; /* initialize sequence */
+
+   return q;
+}
+
+int
+nvc0_hw_get_driver_query_info(struct nvc0_screen *screen, unsigned id,
+                              struct pipe_driver_query_info *info)
+{
+   int num_hw_sm_queries = 0, num_hw_metric_queries = 0;
+
+   num_hw_sm_queries = nvc0_hw_sm_get_driver_query_info(screen, 0, NULL);
+   num_hw_metric_queries =
+      nvc0_hw_metric_get_driver_query_info(screen, 0, NULL);
+
+   if (!info)
+      return num_hw_sm_queries + num_hw_metric_queries;
+
+   if (id < num_hw_sm_queries)
+      return nvc0_hw_sm_get_driver_query_info(screen, id, info);
+
+   return nvc0_hw_metric_get_driver_query_info(screen,
+                                               id - num_hw_sm_queries, info);
+}
+
+void
+nvc0_hw_query_pushbuf_submit(struct nouveau_pushbuf *push,
+                             struct nvc0_query *q, unsigned result_offset)
+{
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+
+   PUSH_REFN(push, hq->bo, NOUVEAU_BO_RD | NOUVEAU_BO_GART);
+   nouveau_pushbuf_data(push, hq->bo, hq->offset + result_offset, 4 |
+                        NVC0_IB_ENTRY_1_NO_PREFETCH);
+}
+
+void
+nvc0_hw_query_fifo_wait(struct nvc0_context *nvc0, struct nvc0_query *q)
+{
+   struct nouveau_pushbuf *push = nvc0->base.pushbuf;
+   struct nvc0_hw_query *hq = nvc0_hw_query(q);
+   unsigned offset = hq->offset;
+
+   /* ensure the query's fence has been emitted */
+   if (hq->is64bit && hq->fence->state < NOUVEAU_FENCE_STATE_EMITTED)
+      nouveau_fence_emit(hq->fence);
+
+   PUSH_SPACE(push, 5);
+   PUSH_REFN (push, hq->bo, NOUVEAU_BO_GART | NOUVEAU_BO_RD);
+   BEGIN_NVC0(push, SUBC_3D(NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH), 4);
+   if (hq->is64bit) {
+      PUSH_DATAh(push, nvc0->screen->fence.bo->offset);
+      PUSH_DATA (push, nvc0->screen->fence.bo->offset);
+      PUSH_DATA (push, hq->fence->sequence);
+   } else {
+      PUSH_DATAh(push, hq->bo->offset + offset);
+      PUSH_DATA (push, hq->bo->offset + offset);
+      PUSH_DATA (push, hq->sequence);
+   }
+   PUSH_DATA (push, (1 << 12) |
+              NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_GEQUAL);
+}
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw_sm.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw_sm.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw_sm.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_query_hw_sm.c	2018-05-22 11:17:46.308742617 +0200
@@ -2325,6 +2325,7 @@
       return false;
    }
 
+   pipe_mutex_lock(screen->base.push_mutex);
    assert(cfg->num_counters <= 4);
    PUSH_SPACE(push, 4 * 8 * + 6);
 
@@ -2385,6 +2386,7 @@
       PUSH_DATA (push, 0xff);
    }
 
+   pipe_mutex_unlock(screen->base.push_mutex);
    return true;
 }
 
@@ -2408,6 +2410,7 @@
       return false;
    }
 
+   pipe_mutex_lock(screen->base.push_mutex);
    assert(cfg->num_counters <= 8);
    PUSH_SPACE(push, 8 * 8 + 2);
 
@@ -2454,6 +2457,7 @@
       BEGIN_NVC0(push, NVC0_CP(MP_PM_SET(c)), 1);
       PUSH_DATA (push, 0);
    }
+   pipe_mutex_unlock(screen->base.push_mutex);
    return true;
 }
 
@@ -2546,6 +2550,7 @@
    if (unlikely(!screen->pm.prog))
       screen->pm.prog = nvc0_hw_sm_get_program(screen);
 
+   pipe_mutex_lock(screen->base.push_mutex);
    /* disable all counting */
    PUSH_SPACE(push, 8);
    for (c = 0; c < 8; ++c)
@@ -2576,6 +2581,7 @@
 
    /* upload input data for the compute shader which reads MP counters */
    nvc0_hw_sm_upload_input(nvc0, hq);
+   pipe_mutex_unlock(screen->base.push_mutex);
 
    pipe->bind_compute_state(pipe, screen->pm.prog);
    for (i = 0; i < 3; i++) {
@@ -2589,6 +2595,7 @@
 
    nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_QUERY);
 
+   pipe_mutex_lock(screen->base.push_mutex);
    /* re-activate other counters */
    PUSH_SPACE(push, 16);
    mask = 0;
@@ -2613,6 +2620,7 @@
          PUSH_DATA (push, (cfg->ctr[i].func << 4) | cfg->ctr[i].mode);
       }
    }
+   pipe_mutex_unlock(screen->base.push_mutex);
 }
 
 static inline bool
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c	2018-05-22 11:17:46.308742617 +0200
@@ -541,7 +541,9 @@
        * _current_ one, and remove both.
        */
       nouveau_fence_ref(screen->base.fence.current, &current);
+      pipe_mutex_lock(screen->base.push_mutex);
       nouveau_fence_wait(current, NULL);
+      pipe_mutex_unlock(screen->base.push_mutex);
       nouveau_fence_ref(NULL, &current);
       nouveau_fence_ref(NULL, &screen->base.fence.current);
    }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_surface.c	2018-05-22 11:17:46.309742617 +0200
@@ -206,11 +206,14 @@
    bool m2mf;
    unsigned dst_layer = dstz, src_layer = src_box->z;
 
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+
    if (dst->target == PIPE_BUFFER && src->target == PIPE_BUFFER) {
       nouveau_copy_buffer(&nvc0->base,
                           nv04_resource(dst), dstx,
                           nv04_resource(src), src_box->x, src_box->width);
       NOUVEAU_DRV_STAT(&nvc0->screen->base, buf_copy_bytes, src_box->width);
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       return;
    }
    NOUVEAU_DRV_STAT(&nvc0->screen->base, tex_copy_count, 1);
@@ -251,6 +254,7 @@
          else
             srect.base += src_mt->layer_stride;
       }
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       return;
    }
 
@@ -273,6 +277,7 @@
          break;
    }
    nouveau_bufctx_reset(nvc0->bufctx, 0);
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
 }
 
 static void
@@ -291,8 +296,12 @@
 
    assert(dst->texture->target != PIPE_BUFFER);
 
-   if (!PUSH_SPACE(push, 32 + sf->depth))
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+
+   if (!PUSH_SPACE(push, 32 + sf->depth)) {
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       return;
+   }
 
    PUSH_REFN (push, res->bo, res->domain | NOUVEAU_BO_WR);
 
@@ -357,6 +366,8 @@
       IMMED_NVC0(push, NVC0_3D(COND_MODE), nvc0->cond_condmode);
 
    nvc0->dirty_3d |= NVC0_NEW_3D_FRAMEBUFFER;
+
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
 }
 
 static void
@@ -538,8 +549,11 @@
 
    assert(size % data_size == 0);
 
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+
    if (data_size == 12) {
       nvc0_clear_buffer_push(pipe, res, offset, size, data, data_size);
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       return;
    }
 
@@ -549,8 +563,10 @@
       nvc0_clear_buffer_push(pipe, res, offset, fixup_size, data, data_size);
       offset += fixup_size;
       size -= fixup_size;
-      if (!size)
+      if (!size) {
+         pipe_mutex_unlock(nvc0->screen->base.push_mutex);
          return;
+      }
    }
 
    elements = size / data_size;
@@ -560,8 +576,10 @@
       width &= ~0xff;
    assert(width > 0);
 
-   if (!PUSH_SPACE(push, 40))
+   if (!PUSH_SPACE(push, 40)) {
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       return;
+   }
 
    PUSH_REFN (push, buf->bo, buf->domain | NOUVEAU_BO_WR);
 
@@ -606,6 +624,8 @@
    }
 
    nvc0->dirty_3d |= NVC0_NEW_3D_FRAMEBUFFER;
+
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
 }
 
 static void
@@ -628,8 +648,11 @@
 
    assert(dst->texture->target != PIPE_BUFFER);
 
-   if (!PUSH_SPACE(push, 32 + sf->depth))
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+   if (!PUSH_SPACE(push, 32 + sf->depth)) {
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       return;
+   }
 
    PUSH_REFN (push, mt->base.bo, mt->base.domain | NOUVEAU_BO_WR);
 
@@ -678,6 +701,8 @@
       IMMED_NVC0(push, NVC0_3D(COND_MODE), nvc0->cond_condmode);
 
    nvc0->dirty_3d |= NVC0_NEW_3D_FRAMEBUFFER;
+
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
 }
 
 void
@@ -691,9 +716,13 @@
    unsigned i, j, k;
    uint32_t mode = 0;
 
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+
    /* don't need NEW_BLEND, COLOR_MASK doesn't affect CLEAR_BUFFERS */
-   if (!nvc0_state_validate_3d(nvc0, NVC0_NEW_3D_FRAMEBUFFER))
+   if (!nvc0_state_validate_3d(nvc0, NVC0_NEW_3D_FRAMEBUFFER)) {
+      pipe_mutex_unlock(nvc0->screen->base.push_mutex);
       return;
+   }
 
    if (buffers & PIPE_CLEAR_COLOR && fb->nr_cbufs) {
       BEGIN_NVC0(push, NVC0_3D(CLEAR_COLOR(0)), 4);
@@ -752,6 +781,8 @@
                     (j << NVC0_3D_CLEAR_BUFFERS_LAYER__SHIFT));
       }
    }
+
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
 }
 
 
@@ -1164,8 +1195,8 @@
    nvc0->samplers_dirty[4] |= 3;
 
    if (nvc0->cond_query && !blit->render_condition_enable)
-      nvc0->base.pipe.render_condition(&nvc0->base.pipe, nvc0->cond_query,
-                                       nvc0->cond_cond, nvc0->cond_mode);
+      nvc0_render_condition(&nvc0->base.pipe, nvc0->cond_query,
+                            nvc0->cond_cond, nvc0->cond_mode);
 
    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_3D_VTX_TMP);
    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_3D_FB);
@@ -1627,6 +1658,8 @@
    if (info->num_window_rectangles > 0 || info->window_rectangle_include)
       eng3d = true;
 
+   pipe_mutex_lock(nvc0->screen->base.push_mutex);
+
    if (nvc0->screen->num_occlusion_queries_active)
       IMMED_NVC0(push, NVC0_3D(SAMPLECNT_ENABLE), 0);
 
@@ -1638,6 +1671,8 @@
    if (nvc0->screen->num_occlusion_queries_active)
       IMMED_NVC0(push, NVC0_3D(SAMPLECNT_ENABLE), 1);
 
+   pipe_mutex_unlock(nvc0->screen->base.push_mutex);
+
    NOUVEAU_DRV_STAT(&nvc0->screen->base, tex_blit_count, 1);
 }
 
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_transfer.c	2018-05-22 11:17:46.309742617 +0200
@@ -366,16 +366,18 @@
    return !mt->base.fence_wr || nouveau_fence_wait(mt->base.fence_wr, &nvc0->base.debug);
 }
 
-void *
-nvc0_miptree_transfer_map(struct pipe_context *pctx,
-                          struct pipe_resource *res,
-                          unsigned level,
-                          unsigned usage,
-                          const struct pipe_box *box,
-                          struct pipe_transfer **ptransfer)
+static void *
+nvc0_miptree_transfer_map_unlocked(
+      struct pipe_context *pctx,
+      struct pipe_resource *res,
+      unsigned level,
+      unsigned usage,
+      const struct pipe_box *box,
+      struct pipe_transfer **ptransfer)
 {
    struct nvc0_context *nvc0 = nvc0_context(pctx);
-   struct nouveau_device *dev = nvc0->screen->base.device;
+   struct nvc0_screen *screen = nvc0->screen;
+   struct nouveau_device *dev = screen->base.device;
    struct nv50_miptree *mt = nv50_miptree(res);
    struct nvc0_transfer *tx;
    uint32_t size;
@@ -489,9 +491,29 @@
    return tx->rect[1].bo->map;
 }
 
-void
-nvc0_miptree_transfer_unmap(struct pipe_context *pctx,
-                            struct pipe_transfer *transfer)
+void *
+nvc0_miptree_transfer_map(
+      struct pipe_context *pctx,
+      struct pipe_resource *res,
+      unsigned level,
+      unsigned usage,
+      const struct pipe_box *box,
+      struct pipe_transfer **ptransfer)
+{
+   struct nvc0_context *nvc0 = nvc0_context(pctx);
+   struct nvc0_screen *screen = nvc0->screen;
+
+   pipe_mutex_lock(screen->base.push_mutex);
+   void *ret = nvc0_miptree_transfer_map_unlocked(
+         pctx, res, level, usage, box, ptransfer);
+   pipe_mutex_unlock(screen->base.push_mutex);
+
+   return ret;
+}
+
+static void
+nvc0_miptree_transfer_unmap_unlocked(struct pipe_context *pctx,
+                                     struct pipe_transfer *transfer)
 {
    struct nvc0_context *nvc0 = nvc0_context(pctx);
    struct nvc0_transfer *tx = (struct nvc0_transfer *)transfer;
@@ -531,6 +553,18 @@
    FREE(tx);
 }
 
+void
+nvc0_miptree_transfer_unmap(struct pipe_context *pctx,
+                            struct pipe_transfer *transfer)
+{
+   struct nvc0_context *nvc0 = nvc0_context(pctx);
+   struct nvc0_screen *screen = nvc0->screen;
+
+   pipe_mutex_lock(screen->base.push_mutex);
+   nvc0_miptree_transfer_unmap_unlocked(pctx, transfer);
+   pipe_mutex_unlock(screen->base.push_mutex);
+}
+
 /* This happens rather often with DTD9/st. */
 static void
 nvc0_cb_push(struct nouveau_context *nv,
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c	2018-05-22 11:17:46.309742617 +0200
@@ -921,6 +921,8 @@
    struct nvc0_screen *screen = nvc0->screen;
    int s;
 
+   pipe_mutex_lock(screen->base.push_mutex);
+
    /* NOTE: caller must ensure that (min_index + index_bias) is >= 0 */
    nvc0->vb_elt_first = info->min_index + info->index_bias;
    nvc0->vb_elt_limit = info->max_index - info->min_index;
@@ -1094,4 +1096,5 @@
 
    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_3D_IDX);
    nouveau_bufctx_reset(nvc0->bufctx_3d, NVC0_BIND_3D_BINDLESS);
+   pipe_mutex_unlock(screen->base.push_mutex);
 }
diff -Naur mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nve4_compute.c mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nve4_compute.c
--- mesa-18.1.0/src/gallium/drivers/nouveau/nvc0/nve4_compute.c	2018-05-19 01:28:40.000000000 +0200
+++ mesa-18.1.0.new/src/gallium/drivers/nouveau/nvc0/nve4_compute.c	2018-05-22 11:17:46.309742617 +0200
@@ -668,12 +668,15 @@
 nve4_launch_grid(struct pipe_context *pipe, const struct pipe_grid_info *info)
 {
    struct nvc0_context *nvc0 = nvc0_context(pipe);
+   struct nvc0_screen *screen = nvc0->screen;
    struct nouveau_pushbuf *push = nvc0->base.pushbuf;
    void *desc;
    uint64_t desc_gpuaddr;
    struct nouveau_bo *desc_bo;
    int ret;
 
+   pipe_mutex_lock(screen->base.push_mutex);
+
    desc = nve4_compute_alloc_launch_desc(&nvc0->base, &desc_bo, &desc_gpuaddr);
    if (!desc) {
       ret = -1;
@@ -754,6 +757,7 @@
    nouveau_scratch_done(&nvc0->base);
    nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_DESC);
    nouveau_bufctx_reset(nvc0->bufctx_cp, NVC0_BIND_CP_BINDLESS);
+   pipe_mutex_unlock(screen->base.push_mutex);
 }
 
 
