Index: trunk/src/VBox/Additions/linux/drm/vbox_drv.c
===================================================================
--- trunk/src/VBox/Additions/linux/drm/vbox_drv.c	(revision 140593)
+++ trunk/src/VBox/Additions/linux/drm/vbox_drv.c	(working copy)
@@ -262,7 +262,12 @@
 	.read = drm_read,
 };
 
-static int vbox_master_set(struct drm_device *dev,
+#if RTLNX_VER_MIN(5,9,0)
+static void
+#else
+static int
+#endif
+            vbox_master_set(struct drm_device *dev,
 			   struct drm_file *file_priv, bool from_open)
 {
 	struct vbox_private *vbox = dev->dev_private;
@@ -281,7 +286,9 @@
 	schedule_delayed_work(&vbox->refresh_work, VBOX_REFRESH_PERIOD);
 	mutex_unlock(&vbox->hw_mutex);
 
+#if RTLNX_VER_MAX(5,9,0)
 	return 0;
+#endif
 }
 
 #if RTLNX_VER_MAX(4,8,0) && !RTLNX_RHEL_MAJ_PREREQ(7,4)
Index: trunk/src/VBox/Additions/linux/drm/vbox_fb.c
===================================================================
--- trunk/src/VBox/Additions/linux/drm/vbox_fb.c	(revision 140593)
+++ trunk/src/VBox/Additions/linux/drm/vbox_fb.c	(working copy)
@@ -405,7 +405,11 @@
 				vbox_bo_unpin(bo);
 			vbox_bo_unreserve(bo);
 		}
+#if RTLNX_VER_MIN(5,9,0)
+		drm_gem_object_put(afb->obj);
+#else
 		drm_gem_object_put_unlocked(afb->obj);
+#endif
 		afb->obj = NULL;
 	}
 	drm_fb_helper_fini(&fbdev->helper);
Index: trunk/src/VBox/Additions/linux/drm/vbox_main.c
===================================================================
--- trunk/src/VBox/Additions/linux/drm/vbox_main.c	(revision 140593)
+++ trunk/src/VBox/Additions/linux/drm/vbox_main.c	(working copy)
@@ -46,7 +46,11 @@
 	struct vbox_framebuffer *vbox_fb = to_vbox_framebuffer(fb);
 
 	if (vbox_fb->obj)
+#if RTLNX_VER_MIN(5,9,0)
+		drm_gem_object_put(vbox_fb->obj);
+#else
 		drm_gem_object_put_unlocked(vbox_fb->obj);
+#endif
 
 	drm_framebuffer_cleanup(fb);
 	kfree(fb);
@@ -221,7 +225,11 @@
 err_free_vbox_fb:
 	kfree(vbox_fb);
 err_unref_obj:
+#if RTLNX_VER_MIN(5,9,0)
+	drm_gem_object_put(obj);
+#else
 	drm_gem_object_put_unlocked(obj);
+#endif
 	return ERR_PTR(ret);
 }
 
@@ -588,7 +596,11 @@
 		return ret;
 
 	ret = drm_gem_handle_create(file, gobj, &handle);
+#if RTLNX_VER_MIN(5,9,0)
+	drm_gem_object_put(gobj);
+#else
 	drm_gem_object_put_unlocked(gobj);
+#endif
 	if (ret)
 		return ret;
 
Index: trunk/src/VBox/Additions/linux/drm/vbox_mode.c
===================================================================
--- trunk/src/VBox/Additions/linux/drm/vbox_mode.c	(revision 140593)
+++ trunk/src/VBox/Additions/linux/drm/vbox_mode.c	(working copy)
@@ -884,7 +884,11 @@
 out_unreserve_bo:
 	vbox_bo_unreserve(bo);
 out_unref_obj:
+#if RTLNX_VER_MIN(5,9,0)
+	drm_gem_object_put(obj);
+#else
 	drm_gem_object_put_unlocked(obj);
+#endif
 
 	return ret;
 }
Index: trunk/src/VBox/Additions/linux/drm/vbox_ttm.c
===================================================================
--- trunk/src/VBox/Additions/linux/drm/vbox_ttm.c	(revision 140593)
+++ trunk/src/VBox/Additions/linux/drm/vbox_ttm.c	(working copy)
@@ -445,7 +445,11 @@
 
 static inline u64 vbox_bo_gpu_offset(struct vbox_bo *bo)
 {
+#if RTLNX_VER_MIN(5,9,0)
+	return bo->bo.mem.start << PAGE_SHIFT;
+#else
 	return bo->bo.offset;
+#endif
 }
 
 int vbox_bo_pin(struct vbox_bo *bo, u32 pl_flag, u64 *gpu_addr)
Index: trunk/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c
===================================================================
--- trunk/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c	(revision 140593)
+++ trunk/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c	(working copy)
@@ -1181,7 +1181,9 @@
          */
         else
             rc = get_user_pages_remote(
+# if GET_USER_PAGES_API < KERNEL_VERSION(5, 9, 0)
                                 pTask,                  /* Task for fault accounting. */
+# endif
                                 pTask->mm,              /* Whose pages. */
                                 R3Ptr,                  /* Where from. */
                                 cPages,                 /* How many pages. */
Index: trunk/src/VBox/Runtime/r0drv/linux/the-linux-kernel.h
===================================================================
--- trunk/src/VBox/Runtime/r0drv/linux/the-linux-kernel.h	(revision 140593)
+++ trunk/src/VBox/Runtime/r0drv/linux/the-linux-kernel.h	(working copy)
@@ -137,7 +137,11 @@
 #include <linux/interrupt.h>
 #include <linux/completion.h>
 #include <linux/compiler.h>
-#ifndef HAVE_UNLOCKED_IOCTL /* linux/fs.h defines this */
+/* linux/fs.h defines HAVE_UNLOCKED_IOCTL from 2.6.11 till 5.9, but its meaning remains valid */
+#if RTLNX_VER_MIN(5,9,0)
+# define HAVE_UNLOCKED_IOCTL 1
+#endif
+#if !defined(HAVE_UNLOCKED_IOCTL) && RTLNX_VER_MAX(2,6,38)
 # include <linux/smp_lock.h>
 #endif
 /* For the shared folders module */
Index: trunk/src/VBox/Runtime/r0drv/linux/thread2-r0drv-linux.c
===================================================================
--- trunk/src/VBox/Runtime/r0drv/linux/thread2-r0drv-linux.c	(revision 140593)
+++ trunk/src/VBox/Runtime/r0drv/linux/thread2-r0drv-linux.c	(working copy)
@@ -54,51 +54,44 @@
 
 DECLHIDDEN(int) rtThreadNativeSetPriority(PRTTHREADINT pThread, RTTHREADTYPE enmType)
 {
-#if RTLNX_VER_MIN(2,6,11)
-    /* See comment near MAX_RT_PRIO in linux/sched.h for details on
-       sched_priority. */
-    int                 iSchedClass = SCHED_NORMAL;
-    struct sched_param  Param       = { .sched_priority = MAX_PRIO - 1 };
+    int                 iSchedClass = SCHED_FIFO;
+    int                 rc = VINF_SUCCESS;
+    struct sched_param  Param = { 0 };
+
+    RT_NOREF_PV(pThread);
+#if RTLNX_VER_MIN(5,9,0)
+    RT_NOREF_PV(iSchedClass);
+    RT_NOREF_PV(Param);
+#endif
     switch (enmType)
     {
-        case RTTHREADTYPE_INFREQUENT_POLLER:
-            Param.sched_priority = MAX_RT_PRIO + 5;
-            break;
-
-        case RTTHREADTYPE_EMULATION:
-            Param.sched_priority = MAX_RT_PRIO + 4;
-            break;
-
-        case RTTHREADTYPE_DEFAULT:
-            Param.sched_priority = MAX_RT_PRIO + 3;
-            break;
-
-        case RTTHREADTYPE_MSG_PUMP:
-            Param.sched_priority = MAX_RT_PRIO + 2;
-            break;
-
         case RTTHREADTYPE_IO:
-            iSchedClass = SCHED_FIFO;
+#if RTLNX_VER_MAX(5,9,0)
+            /* Set max. priority to preempt all other threads on this CPU. */
             Param.sched_priority = MAX_RT_PRIO - 1;
+#else 
+            /* Effectively changes prio to 50 */
+            sched_set_fifo(current);
+#endif
             break;
-
         case RTTHREADTYPE_TIMER:
-            iSchedClass = SCHED_FIFO;
+#if RTLNX_VER_MAX(5,9,0)
             Param.sched_priority = 1; /* not 0 just in case */
+#else
+            /* Just one above SCHED_NORMAL class */
+            sched_set_fifo_low(current);
+#endif
             break;
-
         default:
-            AssertMsgFailed(("enmType=%d\n", enmType));
-            return VERR_INVALID_PARAMETER;
+            /* pretend success instead of VERR_NOT_SUPPORTED */
+            return rc;
+    }
+#if RTLNX_VER_MAX(5,9,0)
+    if ((sched_setscheduler(current, iSchedClass, &Param)) != 0) {
+        rc = VERR_GENERAL_FAILURE;
     }
-
-    sched_setscheduler(current, iSchedClass, &Param);
-#else
-    RT_NOREF_PV(enmType);
 #endif
-    RT_NOREF_PV(pThread);
-
-    return VINF_SUCCESS;
+    return rc;
 }
 
 
