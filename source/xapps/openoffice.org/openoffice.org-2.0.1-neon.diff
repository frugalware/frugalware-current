diff -Naur ooo-build-2.0.1.orig/patches/src680/apply ooo-build-2.0.1/patches/src680/apply
--- ooo-build-2.0.1.orig/patches/src680/apply	2006-02-16 23:18:15.000000000 +0100
+++ ooo-build-2.0.1/patches/src680/apply	2006-02-16 23:22:57.000000000 +0100
@@ -481,6 +481,7 @@
 ooo-longnames-54730.diff
 ooo-db-4.4.diff
 buildfix-link-libxau.diff
+system-neon-0.25.diff
 
 
 [ Frugalware64Only ]
diff -Naur ooo-build-2.0.1.orig/patches/src680/system-neon-0.25.diff ooo-build-2.0.1/patches/src680/system-neon-0.25.diff
--- ooo-build-2.0.1.orig/patches/src680/system-neon-0.25.diff	1970-01-01 01:00:00.000000000 +0100
+++ ooo-build-2.0.1/patches/src680/system-neon-0.25.diff	2006-02-16 23:19:00.000000000 +0100
@@ -0,0 +1,275 @@
+--- ucb/source/ucp/webdav/LinkSequence.cxx	20 Jan 2006 14:19:24 -0000	1.7
++++ ucb/source/ucp/webdav/LinkSequence.cxx	26 Jan 2006 09:51:37 -0000
+@@ -181,7 +181,11 @@
+                       rInData.getStr() + nStart,
+                       nEnd - nStart + TOKEN_LENGTH );
+ 
++#ifdef NEONTWOFIVE
++	success = !ne_xml_failed( parser );
++#else
+         success = !!ne_xml_valid( parser );
++#endif
+ 
+         ne_xml_destroy( parser );
+ 
+--- ucb/source/ucp/webdav/LockEntrySequence.cxx	20 Jan 2006 14:19:37 -0000	1.7
++++ ucb/source/ucp/webdav/LockEntrySequence.cxx	26 Jan 2006 09:51:38 -0000
+@@ -206,7 +206,11 @@
+                        rInData.getStr() + nStart,
+                        nEnd - nStart + TOKEN_LENGTH );
+ 
++#ifdef NEONTWOFIVE
++        success = !ne_xml_failed( parser );
++#else
+         success = !!ne_xml_valid( parser );
++#endif
+ 
+         ne_xml_destroy( parser );
+ 
+--- ucb/source/ucp/webdav/LockSequence.cxx	20 Jan 2006 14:19:52 -0000	1.8
++++ ucb/source/ucp/webdav/LockSequence.cxx	26 Jan 2006 09:51:38 -0000
+@@ -339,7 +339,11 @@
+                       rInData.getStr() + nStart,
+                       nEnd - nStart + TOKEN_LENGTH );
+ 
++#ifdef NEONTWOFIVE
++        success = !ne_xml_failed( parser );
++#else
+         success = !!ne_xml_valid( parser );
++#endif
+ 
+         ne_xml_destroy( parser );
+ 
+--- ucb/source/ucp/webdav/NeonHeadRequest.cxx	9 Sep 2005 16:11:23 -0000	1.3
++++ ucb/source/ucp/webdav/NeonHeadRequest.cxx	26 Jan 2006 09:51:38 -0000
+@@ -51,6 +51,58 @@
+ using namespace webdav_ucp;
+ using namespace com::sun::star;
+ 
++#ifdef NEONTWOFIVE
++static void process_headers(ne_request *req,
++                            DAVResource &rResource,
++                            const std::vector< ::rtl::OUString > &rHeaderNames)
++{
++    void *cursor = NULL;
++    const char *name, *value;
++
++    while ((cursor = ne_response_header_iterate(req, cursor,
++                                                &name, &value)) != NULL) {
++        rtl::OUString aHeaderName( rtl::OUString::createFromAscii( name ) );
++        rtl::OUString aHeaderValue( rtl::OUString::createFromAscii( value ) );
++
++        // Note: Empty vector means that all headers are requested.
++        bool bIncludeIt = ( rHeaderNames.size() == 0 );
++
++        if ( !bIncludeIt )
++        {
++            // Check whether this header was requested.
++            std::vector< ::rtl::OUString >::const_iterator it(
++                rHeaderNames.begin() );
++            const std::vector< ::rtl::OUString >::const_iterator end(
++                rHeaderNames.end() );
++
++            while ( it != end )
++            {
++                if ( (*it) == aHeaderName )
++                    break;
++
++                ++it;
++            }
++
++            if ( it != end )
++                bIncludeIt = true;
++        }
++
++        if ( bIncludeIt )
++        {
++            // Create & set the PropertyValue
++            beans::PropertyValue thePropertyValue;
++            thePropertyValue.Handle = -1;
++            thePropertyValue.Name   = aHeaderName;
++            thePropertyValue.State  = beans::PropertyState_DIRECT_VALUE;
++
++            thePropertyValue.Value  <<= aHeaderValue;
++
++            // Add the newly created PropertyValue
++            rResource.properties.push_back( thePropertyValue );
++        }
++    }
++}
++#else
+ struct NeonHeadRequestContext
+ {
+     DAVResource * pResource;
+@@ -113,6 +165,7 @@
+         }
+     }
+ }
++#endif
+ 
+ 
+ // -------------------------------------------------------------------
+@@ -137,11 +190,17 @@
+                                             inPath,
+                                             RTL_TEXTENCODING_UTF8 ) );
+ 
++#ifndef NEONTWOFIVE
+     NeonHeadRequestContext aCtx( &ioResource, &inHeaderNames );
+     ne_add_response_header_catcher( req, NHR_ResponseHeaderCatcher, &aCtx );
++#endif
+ 
+     nError = ne_request_dispatch( req );
+ 
++#ifdef NEONTWOFIVE
++    process_headers(req, ioResource, inHeaderNames);
++#endif
++
+     if ( nError == NE_OK && ne_get_status( req )->klass != 2 )
+         nError = NE_ERROR;
+ 
+--- ucb/source/ucp/webdav/NeonSession.cxx	20 Jan 2006 14:20:06 -0000	1.37
++++ ucb/source/ucp/webdav/NeonSession.cxx	26 Jan 2006 09:51:41 -0000
+@@ -106,6 +106,10 @@
+ using namespace com::sun::star;
+ using namespace webdav_ucp;
+ 
++#ifndef EOL
++#    define EOL "\r\n"
++#endif
++
+ // -------------------------------------------------------------------
+ // RequestData
+ // -------------------------------------------------------------------
+@@ -233,9 +237,12 @@
+ // ResponseBlockReader
+ // A simple Neon response_block_reader for use with an XInputStream
+ // -------------------------------------------------------------------
+-extern "C" void NeonSession_ResponseBlockReader( void *       inUserData,
+-                                                 const char * inBuf,
+-                                                 size_t       inLen )
++#ifdef NEONTWOFIVE
++extern "C" int NeonSession_ResponseBlockReader
++#else
++extern "C" void NeonSession_ResponseBlockReader
++#endif
++    (void * inUserData, const char * inBuf, size_t inLen )
+ {
+ 	// neon calls this function with (inLen == 0)...
+ 	if ( inLen > 0 )
+@@ -253,15 +260,21 @@
+                 xInputStream->AddToStream( inBuf, inLen );
+         }
+ 	}
++#ifdef NEONTWOFIVE
++	return 0;
++#endif
+ }
+ 
+ // -------------------------------------------------------------------
+ // ResponseBlockWriter
+ // A simple Neon response_block_reader for use with an XOutputStream
+ // -------------------------------------------------------------------
+-extern "C" void NeonSession_ResponseBlockWriter( void *       inUserData,
+-                                                 const char * inBuf,
+-                                                 size_t       inLen )
++#ifdef NEONTWOFIVE
++extern "C" int NeonSession_ResponseBlockWriter
++#else
++extern "C" void NeonSession_ResponseBlockWriter
++#endif
++    ( void *       inUserData, const char * inBuf, size_t inLen )
+ {
+ 	// neon calls this function with (inLen == 0)...
+ 	if ( inLen > 0 )
+@@ -276,6 +289,9 @@
+             xOutputStream->writeBytes( aSeq );
+         }
+ 	}
++#ifdef NEONTWOFIVE
++	return 0;
++#endif
+ }
+ 
+ // -------------------------------------------------------------------
+@@ -1538,6 +1554,23 @@
+ }
+ */
+ 
++#ifdef NEONTWOFIVE
++static void run_header_handler(ne_request *req, ne_header_handler handler, void *userdata)
++{
++    void *cursor = NULL;
++    const char *name, *value;
++
++    while ((cursor = ne_response_header_iterate(req, cursor, &name, &value)) != NULL) 
++    {
++        char buffer[8192];
++
++        ne_snprintf(buffer, sizeof buffer, "%s: %s", name, value);
++
++        handler(userdata, buffer);
++    }
++}
++#endif
++
+ // -------------------------------------------------------------------
+ // static
+ int NeonSession::GET( ne_session * sess,
+@@ -1549,12 +1582,15 @@
+     //struct get_context ctx;
+     ne_request * req = ne_request_create( sess, "GET", uri );
+     int ret;
+-
++#ifndef NEONTWOFIVE
+     ne_add_response_header_catcher( req, handler, userdata );
+-
++#endif
+     ne_add_response_body_reader( req, ne_accept_2xx, reader, userdata );
+ 
+     ret = ne_request_dispatch( req );
++#ifdef NEONTWOFIVE
++    run_header_handler(req, handler, userdata);
++#endif
+ 
+     if ( ret == NE_OK && ne_get_status( req )->klass != 2 )
+         ret = NE_ERROR;
+--- ucb/source/ucp/webdav/NeonSession.hxx	18 Oct 2005 08:47:16 -0000	1.23
++++ ucb/source/ucp/webdav/NeonSession.hxx	26 Jan 2006 09:51:41 -0000
+@@ -49,6 +49,10 @@
+ #include "NeonTypes.hxx"
+ #endif
+ 
++#ifdef NEONTWOFIVE
++typedef void (*ne_header_handler)(void *userdata, const char *value);
++#endif
++
+ namespace ucbhelper { class ProxyDecider; }
+ 
+ namespace webdav_ucp
+--- ucb/source/ucp/webdav/UCBDeadPropertyValue.cxx	20 Jan 2006 14:20:45 -0000	1.8
++++ ucb/source/ucp/webdav/UCBDeadPropertyValue.cxx	26 Jan 2006 09:51:42 -0000
+@@ -394,7 +394,11 @@
+ 
+         ne_xml_parse( parser, rInData.getStr(), rInData.getLength() );
+ 
++#ifdef NEONTWOFIVE
++        success = !ne_xml_failed( parser );
++#else
+         success = !!ne_xml_valid( parser );
++#endif
+ 
+         ne_xml_destroy( parser );
+ 
+--- ucb/source/ucp/webdav/makefile.mk	10 Nov 2005 16:43:55 -0000	1.26
++++ ucb/source/ucp/webdav/makefile.mk	26 Jan 2006 09:51:42 -0000
+@@ -59,6 +59,10 @@
+ 
+ .IF "$(SYSTEM_NEON)" == "YES"
+ CFLAGS+= $(NEON_CFLAGS)
++TWOFIVE:=$(shell pkg-config --atleast-version=0.25.0 neon && echo YES || echo NO)
++.IF "$(TWOFIVE)" == "YES"
++CFLAGS+=-DNEONTWOFIVE
++.ENDIF
+ .ELSE
+ NEONINCDIR=external$/neon
+ CFLAGS+= -I$(SOLARINCDIR)$/$(NEONINCDIR)
