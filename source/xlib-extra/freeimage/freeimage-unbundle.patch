diff -Naur FreeImage/genfipsrclist.sh FreeImage.new/genfipsrclist.sh
--- FreeImage/genfipsrclist.sh	2018-07-28 18:53:18.000000000 +0200
+++ FreeImage.new/genfipsrclist.sh	2022-05-12 16:25:38.630261867 +0200
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-DIRLIST=". Source Source/Metadata Source/FreeImageToolkit Source/LibJPEG Source/LibPNG Source/LibTIFF4 Source/ZLib Source/LibOpenJPEG Source/OpenEXR Source/OpenEXR/Half Source/OpenEXR/Iex Source/OpenEXR/IlmImf Source/OpenEXR/IlmThread Source/OpenEXR/Imath Source/OpenEXR/IexMath Source/LibRawLite Source/LibRawLite/dcraw Source/LibRawLite/internal Source/LibRawLite/libraw Source/LibRawLite/src Source/LibWebP Source/LibJXR Source/LibJXR/common/include Source/LibJXR/image/sys Source/LibJXR/jxrgluelib Wrapper/FreeImagePlus"
+DIRLIST="Wrapper/FreeImagePlus"
 
 
 echo "VER_MAJOR = 3" > fipMakefile.srcs
@@ -19,5 +19,6 @@
 for DIR in $DIRLIST; do
 	echo -n " -I$DIR" >> fipMakefile.srcs
 done
+echo -n " -IDist" >> fipMakefile.srcs
 echo >> fipMakefile.srcs
 
diff -Naur FreeImage/gensrclist.sh FreeImage.new/gensrclist.sh
--- FreeImage/gensrclist.sh	2018-07-28 18:52:50.000000000 +0200
+++ FreeImage.new/gensrclist.sh	2022-05-12 16:25:38.630261867 +0200
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-DIRLIST=". Source Source/Metadata Source/FreeImageToolkit Source/LibJPEG Source/LibPNG Source/LibTIFF4 Source/ZLib Source/LibOpenJPEG Source/OpenEXR Source/OpenEXR/Half Source/OpenEXR/Iex Source/OpenEXR/IlmImf Source/OpenEXR/IlmThread Source/OpenEXR/Imath Source/OpenEXR/IexMath Source/LibRawLite Source/LibRawLite/dcraw Source/LibRawLite/internal Source/LibRawLite/libraw Source/LibRawLite/src Source/LibWebP Source/LibJXR Source/LibJXR/common/include Source/LibJXR/image/sys Source/LibJXR/jxrgluelib"
+DIRLIST=". Source Source/Metadata Source/FreeImageToolkit"
 
 echo "VER_MAJOR = 3" > Makefile.srcs
 echo "VER_MINOR = 18.0" >> Makefile.srcs
diff -Naur FreeImage/Makefile.fip FreeImage.new/Makefile.fip
--- FreeImage/Makefile.fip	2015-03-10 09:03:56.000000000 +0100
+++ FreeImage.new/Makefile.fip	2022-05-12 16:25:38.631261874 +0200
@@ -17,20 +17,22 @@
 MODULES := $(MODULES:.cpp=.o)
 CFLAGS ?= -O3 -fPIC -fexceptions -fvisibility=hidden
 # OpenJPEG
-CFLAGS += -DOPJ_STATIC
+override CFLAGS += -DOPJ_STATIC
 # LibRaw
-CFLAGS += -DNO_LCMS
+override CFLAGS += -DNO_LCMS
 # LibJXR
-CFLAGS += -DDISABLE_PERF_MEASUREMENT -D__ANSI__
-CFLAGS += $(INCLUDE)
+override CFLAGS += -DDISABLE_PERF_MEASUREMENT -D__ANSI__
+override CFLAGS += $(INCLUDE)
 CXXFLAGS ?= -O3 -fPIC -fexceptions -fvisibility=hidden -Wno-ctor-dtor-privacy
 # LibJXR
-CXXFLAGS += -D__ANSI__
-CXXFLAGS += $(INCLUDE)
+override CXXFLAGS += -D__ANSI__
+override CXXFLAGS += $(INCLUDE)
+LDFLAGS ?=
+override LDFLAGS += -LDist -lfreeimage-$(VER_MAJOR).$(VER_MINOR)
 
 ifeq ($(shell sh -c 'uname -m 2>/dev/null || echo not'),x86_64)
-	CFLAGS += -fPIC
-	CXXFLAGS += -fPIC
+	override CFLAGS += -fPIC
+	override CXXFLAGS += -fPIC
 endif
 
 TARGET  = freeimageplus
@@ -68,7 +70,7 @@
 	$(AR) r $@ $(MODULES)
 
 $(SHAREDLIB): $(MODULES)
-	$(CC) -s -shared -Wl,-soname,$(VERLIBNAME) $(LDFLAGS) -o $@ $(MODULES) $(LIBRARIES)
+	$(CC) -shared -Wl,-soname,$(VERLIBNAME) -o $@ $(MODULES) $(LIBRARIES) $(LDFLAGS)
 
 install:
 	install -d $(INCDIR) $(INSTALLDIR)
diff -Naur FreeImage/Makefile.gnu FreeImage.new/Makefile.gnu
--- FreeImage/Makefile.gnu	2015-03-10 09:04:00.000000000 +0100
+++ FreeImage.new/Makefile.gnu	2022-05-12 16:25:38.631261874 +0200
@@ -16,21 +16,11 @@
 MODULES = $(SRCS:.c=.o)
 MODULES := $(MODULES:.cpp=.o)
 CFLAGS ?= -O3 -fPIC -fexceptions -fvisibility=hidden
-# OpenJPEG
-CFLAGS += -DOPJ_STATIC
-# LibRaw
-CFLAGS += -DNO_LCMS
-# LibJXR
-CFLAGS += -DDISABLE_PERF_MEASUREMENT -D__ANSI__
-CFLAGS += $(INCLUDE)
-CXXFLAGS ?= -O3 -fPIC -fexceptions -fvisibility=hidden -Wno-ctor-dtor-privacy
-# LibJXR
-CXXFLAGS += -D__ANSI__
-CXXFLAGS += $(INCLUDE)
+override CFLAGS += $(INCLUDE) -D__ANSI__ $(shell pkg-config --cflags OpenEXR libopenjp2 libraw libpng libtiff-4 libwebp libwebpmux zlib libjxr)
+override LDFLAGS += -ljpeg $(shell pkg-config --libs OpenEXR libopenjp2 libraw libpng libtiff-4 libwebp libwebpmux zlib libjxr)
 
 ifeq ($(shell sh -c 'uname -m 2>/dev/null || echo not'),x86_64)
-	CFLAGS += -fPIC
-	CXXFLAGS += -fPIC
+	override CFLAGS += -fPIC
 endif
 
 TARGET  = freeimage
@@ -61,13 +51,13 @@
 	$(CC) $(CFLAGS) -c $< -o $@
 
 .cpp.o:
-	$(CXX) $(CXXFLAGS) -c $< -o $@
+	$(CXX) $(CFLAGS) -c $< -o $@
 
 $(STATICLIB): $(MODULES)
 	$(AR) r $@ $(MODULES)
 
 $(SHAREDLIB): $(MODULES)
-	$(CC) -s -shared -Wl,-soname,$(VERLIBNAME) $(LDFLAGS) -o $@ $(MODULES) $(LIBRARIES)
+	$(CC) -shared -Wl,-soname,$(VERLIBNAME) -o $@ $(MODULES) $(LIBRARIES) $(LDFLAGS)
 
 install:
 	install -d $(INCDIR) $(INSTALLDIR)
diff -Naur FreeImage/Source/FreeImage/J2KHelper.cpp FreeImage.new/Source/FreeImage/J2KHelper.cpp
--- FreeImage/Source/FreeImage/J2KHelper.cpp	2015-03-04 00:07:08.000000000 +0100
+++ FreeImage.new/Source/FreeImage/J2KHelper.cpp	2022-05-12 16:25:38.631261874 +0200
@@ -21,7 +21,7 @@
 
 #include "FreeImage.h"
 #include "Utilities.h"
-#include "../LibOpenJPEG/openjpeg.h"
+#include <openjpeg.h>
 #include "J2KHelper.h"
 
 // --------------------------------------------------------------------------
diff -Naur FreeImage/Source/FreeImage/Plugin.cpp FreeImage.new/Source/FreeImage/Plugin.cpp
--- FreeImage/Source/FreeImage/Plugin.cpp	2017-02-18 15:09:28.000000000 +0100
+++ FreeImage.new/Source/FreeImage/Plugin.cpp	2022-05-12 16:25:38.631261874 +0200
@@ -263,7 +263,12 @@
 			s_plugins->AddNode(InitDDS);
 	        s_plugins->AddNode(InitGIF);
 	        s_plugins->AddNode(InitHDR);
-			s_plugins->AddNode(InitG3);
+/* The G3 fax format plugin is deliberately disabled in the Fedora build of
+   FreeImage as it requires that FreeImage uses a private copy of libtiff
+   which is a no no because of security reasons. */
+#if 0
+ 			s_plugins->AddNode(InitG3);
+#endif
 			s_plugins->AddNode(InitSGI);
 			s_plugins->AddNode(InitEXR);
 			s_plugins->AddNode(InitJ2K);
diff -Naur FreeImage/Source/FreeImage/PluginEXR.cpp FreeImage.new/Source/FreeImage/PluginEXR.cpp
--- FreeImage/Source/FreeImage/PluginEXR.cpp	2015-03-04 00:07:08.000000000 +0100
+++ FreeImage.new/Source/FreeImage/PluginEXR.cpp	2022-05-12 16:25:38.632261881 +0200
@@ -28,16 +28,17 @@
 #pragma warning (disable : 4800) // ImfVersion.h - 'const int' : forcing value to bool 'true' or 'false' (performance warning)
 #endif 
 
-#include "../OpenEXR/IlmImf/ImfIO.h"
-#include "../OpenEXR/Iex/Iex.h"
-#include "../OpenEXR/IlmImf/ImfOutputFile.h"
-#include "../OpenEXR/IlmImf/ImfInputFile.h"
-#include "../OpenEXR/IlmImf/ImfRgbaFile.h"
-#include "../OpenEXR/IlmImf/ImfChannelList.h"
-#include "../OpenEXR/IlmImf/ImfRgba.h"
-#include "../OpenEXR/IlmImf/ImfArray.h"
-#include "../OpenEXR/IlmImf/ImfPreviewImage.h"
-#include "../OpenEXR/Half/half.h"
+#include <OpenEXR/ImfIO.h>
+#include <OpenEXR/Iex.h>
+#include <OpenEXR/ImfOutputFile.h>
+#include <OpenEXR/ImfInputFile.h>
+#include <OpenEXR/ImfRgbaFile.h>
+#include <OpenEXR/ImfChannelList.h>
+#include <OpenEXR/ImfRgba.h>
+#include <OpenEXR/ImfArray.h>
+#include <OpenEXR/ImfPreviewImage.h>
+#include <Imath/half.h>
+#include <Imath/ImathInt64.h>
 
 
 // ==========================================================
diff -Naur FreeImage/Source/FreeImage/PluginG3.cpp FreeImage.new/Source/FreeImage/PluginG3.cpp
--- FreeImage/Source/FreeImage/PluginG3.cpp	2015-03-04 00:07:08.000000000 +0100
+++ FreeImage.new/Source/FreeImage/PluginG3.cpp	2022-05-12 16:25:45.677312626 +0200
@@ -1,433 +0,0 @@
-// ==========================================================
-// G3 Fax Loader
-//
-// Design and implementation by
-// - Hervé Drolon (drolon@infonie.fr)
-// - Petr Pytelka (pyta@lightcomp.com)
-//
-// This file is part of FreeImage 3
-//
-// COVERED CODE IS PROVIDED UNDER THIS LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTY
-// OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES
-// THAT THE COVERED CODE IS FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE
-// OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE COVERED
-// CODE IS WITH YOU. SHOULD ANY COVERED CODE PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT
-// THE INITIAL DEVELOPER OR ANY OTHER CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY
-// SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL
-// PART OF THIS LICENSE. NO USE OF ANY COVERED CODE IS AUTHORIZED HEREUNDER EXCEPT UNDER
-// THIS DISCLAIMER.
-//
-// Use at your own risk!
-// ==========================================================
-
-#include "../LibTIFF4/tiffiop.h"
-
-#include "FreeImage.h"
-#include "Utilities.h"
-
-// ==========================================================
-// Plugin Interface
-// ==========================================================
-
-static int s_format_id;
-
-// ==========================================================
-//   Constant/Macro declarations
-// ==========================================================
-
-#define G3_DEFAULT_WIDTH	1728
-
-#define TIFFhowmany8(x) (((x)&0x07)?((uint32)(x)>>3)+1:(uint32)(x)>>3)
-
-// ==========================================================
-//   libtiff interface 
-// ==========================================================
-
-static tmsize_t 
-_g3ReadProc(thandle_t handle, void *buf, tmsize_t size) {
-	// returns an error when reading the TIFF header
-	return 0;
-}
-
-static tmsize_t
-_g3WriteProc(thandle_t handle, void *buf, tmsize_t size) {
-	// returns ok when writing the TIFF header
-	return size;
-}
-
-static toff_t
-_g3SeekProc(thandle_t handle, toff_t off, int whence) {
-	return 0;
-}
-
-static int
-_g3CloseProc(thandle_t handle) {
-	return 0;
-}
-
-static toff_t
-_g3SizeProc(thandle_t handle) {
-	return 0;
-}
-
-static int
-_g3MapProc(thandle_t, void** base, toff_t* size) {
-	return 0;
-}
-
-static void
-_g3UnmapProc(thandle_t, void* base, toff_t size) {
-}
-
-// --------------------------------------------------------------
-
-static tmsize_t
-G3GetFileSize(FreeImageIO *io, fi_handle handle) {
-    long currentPos = io->tell_proc(handle);
-    io->seek_proc(handle, 0, SEEK_END);
-    long fileSize = io->tell_proc(handle);
-    io->seek_proc(handle, currentPos, SEEK_SET);
-    return fileSize;
-}
-
-static BOOL 
-G3ReadFile(FreeImageIO *io, fi_handle handle, uint8 *tif_rawdata, tmsize_t tif_rawdatasize) {
-	return ((tmsize_t)(io->read_proc(tif_rawdata, (unsigned)tif_rawdatasize, 1, handle) * tif_rawdatasize) == tif_rawdatasize);
-}
-
-// ==========================================================
-// Internal functions
-// ==========================================================
-
-static int 
-copyFaxFile(FreeImageIO *io, fi_handle handle, TIFF* tifin, uint32 xsize, int stretch, FIMEMORY *memory) {
-	BYTE *rowbuf = NULL;
-	BYTE *refbuf = NULL;
-	uint32 row;
-	uint16 badrun;
-	uint16	badfaxrun;
-	uint32	badfaxlines;
-	int ok;
-
-	try {
-
-		uint32 linesize = TIFFhowmany8(xsize);
-		rowbuf = (BYTE*) _TIFFmalloc(linesize);
-		refbuf = (BYTE*) _TIFFmalloc(linesize);
-		if (rowbuf == NULL || refbuf == NULL) {
-			throw FI_MSG_ERROR_MEMORY;
-		}
-
-		tifin->tif_rawdatasize = G3GetFileSize(io, handle);
-		tifin->tif_rawdata = (tidata_t) _TIFFmalloc(tifin->tif_rawdatasize);
-		if (tifin->tif_rawdata == NULL) {
-			throw FI_MSG_ERROR_MEMORY;
-		}
-			
-		if(!G3ReadFile(io, handle, tifin->tif_rawdata, tifin->tif_rawdatasize)) {
-			throw "Read error at scanline 0";
-		}
-		tifin->tif_rawcp = tifin->tif_rawdata;
-		tifin->tif_rawcc = tifin->tif_rawdatasize;
-
-		(*tifin->tif_setupdecode)(tifin);
-		(*tifin->tif_predecode)(tifin, (uint16) 0);
-		tifin->tif_row = 0;
-		badfaxlines = 0;
-		badfaxrun = 0;
-
-		_TIFFmemset(refbuf, 0, linesize);
-		row = 0;
-		badrun = 0;		// current run of bad lines 
-		while (tifin->tif_rawcc > 0) {
-			ok = (*tifin->tif_decoderow)(tifin, rowbuf, linesize, 0);
-			if (!ok) {
-				badfaxlines++;
-				badrun++;
-				// regenerate line from previous good line 
-				_TIFFmemcpy(rowbuf, refbuf, linesize);
-			} else {
-				if (badrun > badfaxrun)
-					badfaxrun = badrun;
-				badrun = 0;
-				_TIFFmemcpy(refbuf, rowbuf, linesize);
-			}
-			tifin->tif_row++;
-
-			FreeImage_WriteMemory(rowbuf, linesize, 1, memory);
-			row++;
-			if (stretch) {
-				FreeImage_WriteMemory(rowbuf, linesize, 1, memory);
-				row++;
-			}
-		}
-		if (badrun > badfaxrun)
-			badfaxrun = badrun;
-
-		_TIFFfree(tifin->tif_rawdata);
-		tifin->tif_rawdata = NULL;
-
-		_TIFFfree(rowbuf);
-		_TIFFfree(refbuf);
-
-		/*
-		if (verbose) {
-			fprintf(stderr, "%d rows in input\n", rows);
-			fprintf(stderr, "%ld total bad rows\n", (long) badfaxlines);
-			fprintf(stderr, "%d max consecutive bad rows\n", badfaxrun);
-		}
-		*/
-
-	} catch(const char *message) {
-		if(rowbuf) _TIFFfree(rowbuf);
-		if(refbuf) _TIFFfree(refbuf);
-		if(tifin->tif_rawdata) {
-			_TIFFfree(tifin->tif_rawdata);
-			tifin->tif_rawdata = NULL;
-		}
-		FreeImage_OutputMessageProc(s_format_id, message);
-
-		return -1;
-	}
-
-	return (row);
-}
-
-
-// ==========================================================
-// Plugin Implementation
-// ==========================================================
-
-static const char * DLL_CALLCONV
-Format() {
-	return "G3";
-}
-
-static const char * DLL_CALLCONV 
-Description() {
-	return "Raw fax format CCITT G.3";
-}
-
-static const char * DLL_CALLCONV 
-Extension() {
-	return "g3";
-}
-
-static const char * DLL_CALLCONV 
-RegExpr() {
-	return NULL; // there is now reasonable regexp for raw G3
-}
-
-static const char * DLL_CALLCONV 
-MimeType() {
-	return "image/fax-g3";
-}
-
-static BOOL DLL_CALLCONV 
-SupportsExportDepth(int depth) {
-	return	FALSE;
-}
-
-// ----------------------------------------------------------
-
-static FIBITMAP * DLL_CALLCONV
-Load(FreeImageIO *io, fi_handle handle, int page, int flags, void *data) {
-	TIFF *faxTIFF = NULL;
-	FIBITMAP *dib = NULL;
-	FIMEMORY *memory = NULL;
-
-	//int verbose = 0;
-	int	stretch = 0;
-	int rows;
-	float resX = 204.0;
-	float resY = 196.0;
-
-	uint32 xsize = G3_DEFAULT_WIDTH;
-	int compression_in = COMPRESSION_CCITTFAX3;
-	int fillorder_in = FILLORDER_LSB2MSB;
-	uint32 group3options_in = 0;	// 1d-encoded 
-	uint32 group4options_in = 0;	// compressed 
-	int photometric_in = PHOTOMETRIC_MINISWHITE;
-
-	if(handle==NULL) return NULL;
-
-	try {
-		// set default load options
-
-		compression_in = COMPRESSION_CCITTFAX3;			// input is g3-encoded 
-		group3options_in &= ~GROUP3OPT_2DENCODING;		// input is 1d-encoded (g3 only) 
-		fillorder_in = FILLORDER_MSB2LSB;				// input has msb-to-lsb fillorder 
-
-		/*
-		Original input-related fax2tiff options
-
-		while ((c = getopt(argc, argv, "R:X:o:1234ABLMPUW5678abcflmprsuvwz?")) != -1) {
-			switch (c) {
-					// input-related options 
-				case '3':		// input is g3-encoded 
-					compression_in = COMPRESSION_CCITTFAX3;
-					break;
-				case '4':		// input is g4-encoded 
-					compression_in = COMPRESSION_CCITTFAX4;
-					break;
-				case 'U':		// input is uncompressed (g3 and g4) 
-					group3options_in |= GROUP3OPT_UNCOMPRESSED;
-					group4options_in |= GROUP4OPT_UNCOMPRESSED;
-					break;
-				case '1':		// input is 1d-encoded (g3 only) 
-					group3options_in &= ~GROUP3OPT_2DENCODING;
-					break;
-				case '2':		// input is 2d-encoded (g3 only) 
-					group3options_in |= GROUP3OPT_2DENCODING;
-					break;
-				case 'P':	// input has not-aligned EOL (g3 only) 
-					group3options_in &= ~GROUP3OPT_FILLBITS;
-					break;
-				case 'A':		// input has aligned EOL (g3 only) 
-					group3options_in |= GROUP3OPT_FILLBITS;
-					break;
-				case 'W':		// input has 0 mean white 
-					photometric_in = PHOTOMETRIC_MINISWHITE;
-					break;
-				case 'B':		// input has 0 mean black 
-					photometric_in = PHOTOMETRIC_MINISBLACK;
-					break;
-				case 'L':		// input has lsb-to-msb fillorder 
-					fillorder_in = FILLORDER_LSB2MSB;
-					break;
-				case 'M':		// input has msb-to-lsb fillorder 
-					fillorder_in = FILLORDER_MSB2LSB;
-					break;
-				case 'R':		// input resolution 
-					resY = (float) atof(optarg);
-					break;
-				case 'X':		// input width 
-					xsize = (uint32) atoi(optarg);
-					break;
-
-					// output-related options 
-				case 's':		// stretch image by dup'ng scanlines 
-					stretch = 1;
-					break;
-				case 'v':		// -v for info 
-					verbose++;
-					break;
-			}
-		}
-
-		*/
-
-		// open a temporary memory buffer to save decoded scanlines
-		memory = FreeImage_OpenMemory();
-		if(!memory) throw FI_MSG_ERROR_MEMORY;
-		
-		// wrap the raw fax file
-		faxTIFF = TIFFClientOpen("(FakeInput)", "w",
-			// TIFFClientOpen() fails if we don't set existing value here 
-			NULL,
-			_g3ReadProc, _g3WriteProc,
-			_g3SeekProc, _g3CloseProc,
-			_g3SizeProc, _g3MapProc,
-			_g3UnmapProc);
-
-		if (faxTIFF == NULL) {
-			throw "Can not create fake input file";
-		}
-		TIFFSetMode(faxTIFF, O_RDONLY);
-		TIFFSetField(faxTIFF, TIFFTAG_IMAGEWIDTH, xsize);
-		TIFFSetField(faxTIFF, TIFFTAG_SAMPLESPERPIXEL, 1);
-		TIFFSetField(faxTIFF, TIFFTAG_BITSPERSAMPLE, 1);
-		TIFFSetField(faxTIFF, TIFFTAG_FILLORDER, fillorder_in);
-		TIFFSetField(faxTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
-		TIFFSetField(faxTIFF, TIFFTAG_PHOTOMETRIC, photometric_in);
-		TIFFSetField(faxTIFF, TIFFTAG_YRESOLUTION, resY);
-		TIFFSetField(faxTIFF, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);
-
-		// NB: this must be done after directory info is setup 
-		TIFFSetField(faxTIFF, TIFFTAG_COMPRESSION, compression_in);
-		if (compression_in == COMPRESSION_CCITTFAX3)
-			TIFFSetField(faxTIFF, TIFFTAG_GROUP3OPTIONS, group3options_in);
-		else if (compression_in == COMPRESSION_CCITTFAX4)
-			TIFFSetField(faxTIFF, TIFFTAG_GROUP4OPTIONS, group4options_in);
-		
-		resX = 204;
-		if (!stretch) {
-			TIFFGetField(faxTIFF, TIFFTAG_YRESOLUTION, &resY);
-		} else {
-			resY = 196;
-		}
-
-		// decode the raw fax data
-		rows = copyFaxFile(io, handle, faxTIFF, xsize, stretch, memory);
-		if(rows <= 0) throw "Error when decoding raw fax file : check the decoder options";
-
-
-		// allocate the output dib
-		dib = FreeImage_Allocate(xsize, rows, 1);
-		unsigned pitch = FreeImage_GetPitch(dib);
-		uint32 linesize = TIFFhowmany8(xsize);
-
-		// fill the bitmap structure ...
-		// ... palette
-		RGBQUAD *pal = FreeImage_GetPalette(dib);
-		if(photometric_in == PHOTOMETRIC_MINISWHITE) {
-			pal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;
-			pal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 0;
-		} else {
-			pal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 0;
-			pal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;
-		}
-		// ... resolution
-		FreeImage_SetDotsPerMeterX(dib, (unsigned)(resX/0.0254000 + 0.5));
-		FreeImage_SetDotsPerMeterY(dib, (unsigned)(resY/0.0254000 + 0.5));
-
-		// read the decoded scanline and fill the bitmap data
-		FreeImage_SeekMemory(memory, 0, SEEK_SET);
-		BYTE *bits = FreeImage_GetScanLine(dib, rows - 1);
-		for(int k = 0; k < rows; k++) {
-			FreeImage_ReadMemory(bits, linesize, 1, memory);
-			bits -= pitch;
-		}
-
-		// free the TIFF wrapper
-		TIFFClose(faxTIFF);
-
-		// free the memory buffer
-		FreeImage_CloseMemory(memory);
-
-	} catch(const char *message) {
-		if(memory) FreeImage_CloseMemory(memory);
-		if(faxTIFF) TIFFClose(faxTIFF);
-		if(dib) FreeImage_Unload(dib);
-		FreeImage_OutputMessageProc(s_format_id, message);
-		return NULL;
-	}
-
-	return dib;
-
-}
-
-// ==========================================================
-//   Init
-// ==========================================================
-
-void DLL_CALLCONV
-InitG3(Plugin *plugin, int format_id) {
-	s_format_id = format_id;
-
-	plugin->format_proc = Format;
-	plugin->description_proc = Description;
-	plugin->extension_proc = Extension;
-	plugin->regexpr_proc = RegExpr;
-	plugin->open_proc = NULL;
-	plugin->close_proc = NULL;
-	plugin->pagecount_proc = NULL;
-	plugin->pagecapability_proc = NULL;
-	plugin->load_proc = Load;
-	plugin->save_proc = NULL;
-	plugin->validate_proc = NULL;
-	plugin->mime_proc = MimeType;
-	plugin->supports_export_bpp_proc = SupportsExportDepth;
-	plugin->supports_export_type_proc = NULL;
-	plugin->supports_icc_profiles_proc = NULL;
-}
diff -Naur FreeImage/Source/FreeImage/PluginJ2K.cpp FreeImage.new/Source/FreeImage/PluginJ2K.cpp
--- FreeImage/Source/FreeImage/PluginJ2K.cpp	2015-03-04 00:07:08.000000000 +0100
+++ FreeImage.new/Source/FreeImage/PluginJ2K.cpp	2022-05-12 16:25:38.632261881 +0200
@@ -21,7 +21,7 @@
 
 #include "FreeImage.h"
 #include "Utilities.h"
-#include "../LibOpenJPEG/openjpeg.h"
+#include <openjpeg.h>
 #include "J2KHelper.h"
 
 // ==========================================================
diff -Naur FreeImage/Source/FreeImage/PluginJP2.cpp FreeImage.new/Source/FreeImage/PluginJP2.cpp
--- FreeImage/Source/FreeImage/PluginJP2.cpp	2015-03-04 00:07:08.000000000 +0100
+++ FreeImage.new/Source/FreeImage/PluginJP2.cpp	2022-05-12 16:25:38.632261881 +0200
@@ -21,7 +21,7 @@
 
 #include "FreeImage.h"
 #include "Utilities.h"
-#include "../LibOpenJPEG/openjpeg.h"
+#include <openjpeg.h>
 #include "J2KHelper.h"
 
 // ==========================================================
diff -Naur FreeImage/Source/FreeImage/PluginJPEG.cpp FreeImage.new/Source/FreeImage/PluginJPEG.cpp
--- FreeImage/Source/FreeImage/PluginJPEG.cpp	2018-07-28 19:22:24.000000000 +0200
+++ FreeImage.new/Source/FreeImage/PluginJPEG.cpp	2022-05-12 16:25:38.633261888 +0200
@@ -35,9 +35,9 @@
 #undef FAR
 #include <setjmp.h>
 
-#include "../LibJPEG/jinclude.h"
-#include "../LibJPEG/jpeglib.h"
-#include "../LibJPEG/jerror.h"
+#include <stdio.h>
+#include <jpeglib.h>
+#include <jerror.h>
 }
 
 #include "FreeImage.h"
@@ -485,116 +485,6 @@
 }
 
 /**
-  See if there was an ICC profile in the JPEG file being read;
-  if so, reassemble and return the profile data.
-
-  TRUE is returned if an ICC profile was found, FALSE if not.
-  If TRUE is returned, *icc_data_ptr is set to point to the
-  returned data, and *icc_data_len is set to its length.
-  
-  IMPORTANT: the data at **icc_data_ptr has been allocated with malloc()
-  and must be freed by the caller with free() when the caller no longer
-  needs it.  (Alternatively, we could write this routine to use the
-  IJG library's memory allocator, so that the data would be freed implicitly
-  at jpeg_finish_decompress() time.  But it seems likely that many apps
-  will prefer to have the data stick around after decompression finishes.)
-  
-  NOTE: if the file contains invalid ICC APP2 markers, we just silently
-  return FALSE.  You might want to issue an error message instead.
-*/
-static BOOL 
-jpeg_read_icc_profile(j_decompress_ptr cinfo, JOCTET **icc_data_ptr, unsigned *icc_data_len) {
-	jpeg_saved_marker_ptr marker;
-	int num_markers = 0;
-	int seq_no;
-	JOCTET *icc_data;
-	unsigned total_length;
-
-	const int MAX_SEQ_NO = 255;			// sufficient since marker numbers are bytes
-	BYTE marker_present[MAX_SEQ_NO+1];	// 1 if marker found
-	unsigned data_length[MAX_SEQ_NO+1];	// size of profile data in marker
-	unsigned data_offset[MAX_SEQ_NO+1];	// offset for data in marker
-	
-	*icc_data_ptr = NULL;		// avoid confusion if FALSE return
-	*icc_data_len = 0;
-	
-	/**
-	this first pass over the saved markers discovers whether there are
-	any ICC markers and verifies the consistency of the marker numbering.
-	*/
-	
-	memset(marker_present, 0, (MAX_SEQ_NO + 1));
-	
-	for(marker = cinfo->marker_list; marker != NULL; marker = marker->next) {
-		if (marker_is_icc(marker)) {
-			if (num_markers == 0) {
-				// number of markers
-				num_markers = GETJOCTET(marker->data[13]);
-			}
-			else if (num_markers != GETJOCTET(marker->data[13])) {
-				return FALSE;		// inconsistent num_markers fields 
-			}
-			// sequence number
-			seq_no = GETJOCTET(marker->data[12]);
-			if (seq_no <= 0 || seq_no > num_markers) {
-				return FALSE;		// bogus sequence number 
-			}
-			if (marker_present[seq_no]) {
-				return FALSE;		// duplicate sequence numbers 
-			}
-			marker_present[seq_no] = 1;
-			data_length[seq_no] = marker->data_length - ICC_HEADER_SIZE;
-		}
-	}
-	
-	if (num_markers == 0)
-		return FALSE;
-		
-	/**
-	check for missing markers, count total space needed,
-	compute offset of each marker's part of the data.
-	*/
-	
-	total_length = 0;
-	for(seq_no = 1; seq_no <= num_markers; seq_no++) {
-		if (marker_present[seq_no] == 0) {
-			return FALSE;		// missing sequence number
-		}
-		data_offset[seq_no] = total_length;
-		total_length += data_length[seq_no];
-	}
-	
-	if (total_length <= 0)
-		return FALSE;		// found only empty markers ?
-	
-	// allocate space for assembled data 
-	icc_data = (JOCTET *) malloc(total_length * sizeof(JOCTET));
-	if (icc_data == NULL)
-		return FALSE;		// out of memory
-	
-	// and fill it in
-	for (marker = cinfo->marker_list; marker != NULL; marker = marker->next) {
-		if (marker_is_icc(marker)) {
-			JOCTET FAR *src_ptr;
-			JOCTET *dst_ptr;
-			unsigned length;
-			seq_no = GETJOCTET(marker->data[12]);
-			dst_ptr = icc_data + data_offset[seq_no];
-			src_ptr = marker->data + ICC_HEADER_SIZE;
-			length = data_length[seq_no];
-			while (length--) {
-				*dst_ptr++ = *src_ptr++;
-			}
-		}
-	}
-	
-	*icc_data_ptr = icc_data;
-	*icc_data_len = total_length;
-	
-	return TRUE;
-}
-
-/**
 	Read JPEG_APPD marker (IPTC or Adobe Photoshop profile)
 */
 static BOOL 
diff -Naur FreeImage/Source/FreeImage/PluginJXR.cpp FreeImage.new/Source/FreeImage/PluginJXR.cpp
--- FreeImage/Source/FreeImage/PluginJXR.cpp	2015-03-04 00:07:08.000000000 +0100
+++ FreeImage.new/Source/FreeImage/PluginJXR.cpp	2022-05-12 16:25:38.633261888 +0200
@@ -23,7 +23,7 @@
 #include "Utilities.h"
 #include "../Metadata/FreeImageTag.h"
 
-#include "../LibJXR/jxrgluelib/JXRGlue.h"
+#include <JXRGlue.h>
 
 // ==========================================================
 // Plugin Interface
diff -Naur FreeImage/Source/FreeImage/PluginPNG.cpp FreeImage.new/Source/FreeImage/PluginPNG.cpp
--- FreeImage/Source/FreeImage/PluginPNG.cpp	2018-07-28 20:15:26.000000000 +0200
+++ FreeImage.new/Source/FreeImage/PluginPNG.cpp	2022-05-12 16:25:38.633261888 +0200
@@ -40,8 +40,8 @@
 
 // ----------------------------------------------------------
 
-#include "../ZLib/zlib.h"
-#include "../LibPNG/png.h"
+#include <zlib.h>
+#include <png.h>
 
 // ----------------------------------------------------------
 
diff -Naur FreeImage/Source/FreeImage/PluginRAW.cpp FreeImage.new/Source/FreeImage/PluginRAW.cpp
--- FreeImage/Source/FreeImage/PluginRAW.cpp	2015-03-10 11:12:04.000000000 +0100
+++ FreeImage.new/Source/FreeImage/PluginRAW.cpp	2022-05-12 16:25:38.633261888 +0200
@@ -19,7 +19,7 @@
 // Use at your own risk!
 // ==========================================================
 
-#include "../LibRawLite/libraw/libraw.h"
+#include <libraw/libraw.h>
 
 #include "FreeImage.h"
 #include "Utilities.h"
diff -Naur FreeImage/Source/FreeImage/PluginTIFF.cpp FreeImage.new/Source/FreeImage/PluginTIFF.cpp
--- FreeImage/Source/FreeImage/PluginTIFF.cpp	2018-07-29 00:24:44.000000000 +0200
+++ FreeImage.new/Source/FreeImage/PluginTIFF.cpp	2022-05-12 16:25:38.634261895 +0200
@@ -37,9 +37,9 @@
 
 #include "FreeImage.h"
 #include "Utilities.h"
-#include "../LibTIFF4/tiffiop.h"
+#include <tiffio.h>
 #include "../Metadata/FreeImageTag.h"
-#include "../OpenEXR/Half/half.h"
+#include <Imath/half.h>
 
 #include "FreeImageIO.h"
 #include "PSDParser.h"
@@ -193,17 +193,6 @@
 
 	return tif;
 }
-
-/**
-Open a TIFF file for reading or writing
-@param name
-@param mode
-*/
-TIFF*
-TIFFOpen(const char* name, const char* mode) {
-	return 0;
-}
-
 // ----------------------------------------------------------
 //   TIFF library FreeImage-specific routines.
 // ----------------------------------------------------------
diff -Naur FreeImage/Source/FreeImage/PluginWebP.cpp FreeImage.new/Source/FreeImage/PluginWebP.cpp
--- FreeImage/Source/FreeImage/PluginWebP.cpp	2016-06-15 15:48:12.000000000 +0200
+++ FreeImage.new/Source/FreeImage/PluginWebP.cpp	2022-05-12 16:25:38.634261895 +0200
@@ -24,9 +24,9 @@
 
 #include "../Metadata/FreeImageTag.h"
 
-#include "../LibWebP/src/webp/decode.h"
-#include "../LibWebP/src/webp/encode.h"
-#include "../LibWebP/src/webp/mux.h"
+#include <webp/decode.h>
+#include <webp/encode.h>
+#include <webp/mux.h>
 
 // ==========================================================
 // Plugin Interface
diff -Naur FreeImage/Source/FreeImage/PSDParser.cpp FreeImage.new/Source/FreeImage/PSDParser.cpp
--- FreeImage/Source/FreeImage/PSDParser.cpp	2016-02-11 04:18:02.000000000 +0100
+++ FreeImage.new/Source/FreeImage/PSDParser.cpp	2022-05-12 16:25:38.634261895 +0200
@@ -133,8 +133,8 @@
 template <>
 class PSDGetValue<8> {
 public:
-	static inline UINT64 get(const BYTE * iprBuffer) {
-		UINT64 v = ((const UINT64*)iprBuffer)[0];
+	static inline uint64_t get(const BYTE * iprBuffer) {
+		uint64_t v = ((const uint64_t*)iprBuffer)[0];
 #ifndef FREEIMAGE_BIGENDIAN
 		SwapInt64(&v);
 #endif
@@ -147,7 +147,7 @@
 
 // --------------------------------------------------------------------------
 
-static UINT64
+static uint64_t
 psdReadSize(FreeImageIO *io, fi_handle handle, const psdHeaderInfo& header) {
 	if(header._Version == 1) {
 		BYTE Length[4];
@@ -199,11 +199,11 @@
 template <>
 class PSDSetValue<8> {
 public:
-	static inline void set(const BYTE * iprBuffer, UINT64 v) {
+	static inline void set(const BYTE * iprBuffer, uint64_t v) {
 #ifndef FREEIMAGE_BIGENDIAN
 		SwapInt64(&v);
 #endif
-		((UINT64*)iprBuffer)[0] = v;
+		((uint64_t*)iprBuffer)[0] = v;
 	}
 };
 
@@ -213,7 +213,7 @@
 // --------------------------------------------------------------------------
 
 static inline bool
-psdWriteSize(FreeImageIO *io, fi_handle handle, const psdHeaderInfo& header, UINT64 v) {
+psdWriteSize(FreeImageIO *io, fi_handle handle, const psdHeaderInfo& header, uint64_t v) {
 	if(header._Version == 1) {
 		BYTE Length[4];
 		psdSetLongValue(Length, sizeof(Length), (DWORD)v);
@@ -1063,10 +1063,10 @@
 bool psdParser::ReadLayerAndMaskInfoSection(FreeImageIO *io, fi_handle handle)	{
 	bool bSuccess = true;
 
-	UINT64 nTotalBytes = psdReadSize(io, handle, _headerInfo);
+	uint64_t nTotalBytes = psdReadSize(io, handle, _headerInfo);
 
 	// Hack to handle large PSB files without using fseeko().
-	if (sizeof(long) < sizeof(UINT64)) {
+	if (sizeof(long) < sizeof(uint64_t)) {
 		const long offset = 0x10000000;
 		while (nTotalBytes > offset) {
 			if (io->seek_proc(handle, offset, SEEK_CUR) != 0) {
@@ -1672,7 +1672,7 @@
 	// Short section with no layers.
 	BYTE IntValue[4];
 
-	UINT64 size;
+	uint64_t size;
 	if(_headerInfo._Version == 1) {
 		size = 8;
 	} else {
diff -Naur FreeImage/Source/FreeImage/ZLibInterface.cpp FreeImage.new/Source/FreeImage/ZLibInterface.cpp
--- FreeImage/Source/FreeImage/ZLibInterface.cpp	2015-03-04 00:07:10.000000000 +0100
+++ FreeImage.new/Source/FreeImage/ZLibInterface.cpp	2022-05-12 16:25:38.634261895 +0200
@@ -19,10 +19,9 @@
 // Use at your own risk!
 // ==========================================================
 
-#include "../ZLib/zlib.h"
+#include <zlib.h>
 #include "FreeImage.h"
 #include "Utilities.h"
-#include "../ZLib/zutil.h"	/* must be the last header because of error C3163 in VS2008 (_vsnprintf defined in stdio.h) */
 
 /**
 Compresses a source buffer into a target buffer, using the ZLib library. 
@@ -115,7 +114,7 @@
 			return 0;
         case Z_OK: {
             // patch header, setup crc and length (stolen from mod_trace_output)
-            BYTE *p = target + 8; *p++ = 2; *p = OS_CODE; // xflags, os_code
+            BYTE *p = target + 8; *p++ = 2; *p = 0x03; // xflags, os_code (unix)
  	        crc = crc32(crc, source, source_size);
 	        memcpy(target + 4 + dest_len, &crc, 4);
 	        memcpy(target + 8 + dest_len, &source_size, 4);
diff -Naur FreeImage/Source/FreeImage.h FreeImage.new/Source/FreeImage.h
--- FreeImage/Source/FreeImage.h	2018-03-25 18:42:20.000000000 +0200
+++ FreeImage.new/Source/FreeImage.h	2022-05-12 16:25:38.634261895 +0200
@@ -155,8 +155,11 @@
 typedef uint16_t WORD;
 typedef uint32_t DWORD;
 typedef int32_t LONG;
+// Disable these, they conflict with the (wrong) ones of libraw
+#if 0
 typedef int64_t INT64;
 typedef uint64_t UINT64;
+#endif
 #else
 // MS is not C99 ISO compliant
 typedef long BOOL;
@@ -410,7 +413,12 @@
 	FIF_DDS		= 24,
 	FIF_GIF     = 25,
 	FIF_HDR		= 26,
-	FIF_FAXG3	= 27,
+/* The G3 fax format plugin is deliberately disabled in the Fedora build of
+   FreeImage as it requires that FreeImage uses a private copy of libtiff
+   which is a no no because of security reasons. */
+#if 0
+ 	FIF_FAXG3	= 27,
+#endif
 	FIF_SGI		= 28,
 	FIF_EXR		= 29,
 	FIF_J2K		= 30,
@@ -473,6 +481,10 @@
 	FID_BAYER16x16	= 6		//! Bayer ordered dispersed dot dithering (order 4 dithering matrix)
 };
 
+/* The FreeImage_JPEGTransform functions are deliberately disabled in the
+   Fedora build of FreeImage as they require that FreeImage uses a private copy
+   of libjpeg which is a no no because of security reasons. */
+#if 0
 /** Lossless JPEG transformations
 Constants used in FreeImage_JPEGTransform
 */
@@ -486,6 +498,7 @@
 	FIJPEG_OP_ROTATE_180	= 6,	//! 180-degree rotation
 	FIJPEG_OP_ROTATE_270	= 7		//! 270-degree clockwise (or 90 ccw)
 };
+#endif
 
 /** Tone mapping operators.
 Constants used in FreeImage_ToneMapping.
@@ -1088,7 +1101,10 @@
 // --------------------------------------------------------------------------
 // JPEG lossless transformation routines
 // --------------------------------------------------------------------------
-
+/* The FreeImage_JPEGTransform functions are deliberately disabled in the
++   Fedora build of FreeImage as they require that FreeImage uses a private copy
++   of libjpeg which is a no no because of security reasons. */
+#if 0
 DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransform(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect FI_DEFAULT(TRUE));
 DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect FI_DEFAULT(TRUE));
 DLL_API BOOL DLL_CALLCONV FreeImage_JPEGCrop(const char *src_file, const char *dst_file, int left, int top, int right, int bottom);
@@ -1097,6 +1113,7 @@
 DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformCombined(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect FI_DEFAULT(TRUE));
 DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformCombinedU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect FI_DEFAULT(TRUE));
 DLL_API BOOL DLL_CALLCONV FreeImage_JPEGTransformCombinedFromMemory(FIMEMORY* src_stream, FIMEMORY* dst_stream, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect FI_DEFAULT(TRUE));
+#endif
 
 
 // --------------------------------------------------------------------------
diff -Naur FreeImage/Source/FreeImageToolkit/JPEGTransform.cpp FreeImage.new/Source/FreeImageToolkit/JPEGTransform.cpp
--- FreeImage/Source/FreeImageToolkit/JPEGTransform.cpp	2015-03-04 00:07:10.000000000 +0100
+++ FreeImage.new/Source/FreeImageToolkit/JPEGTransform.cpp	2022-05-12 16:25:42.317288421 +0200
@@ -1,623 +0,0 @@
-// ==========================================================
-// JPEG lossless transformations
-//
-// Design and implementation by
-// - Petr Pytelka (pyta@lightcomp.com)
-// - HervÃ© Drolon (drolon@infonie.fr)
-// - Mihail Naydenov (mnaydenov@users.sourceforge.net)
-//
-// This file is part of FreeImage 3
-//
-// COVERED CODE IS PROVIDED UNDER THIS LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTY
-// OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES
-// THAT THE COVERED CODE IS FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE
-// OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE COVERED
-// CODE IS WITH YOU. SHOULD ANY COVERED CODE PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT
-// THE INITIAL DEVELOPER OR ANY OTHER CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY
-// SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL
-// PART OF THIS LICENSE. NO USE OF ANY COVERED CODE IS AUTHORIZED HEREUNDER EXCEPT UNDER
-// THIS DISCLAIMER.
-//
-// Use at your own risk!
-// ==========================================================
-
-extern "C" {
-#define XMD_H
-#undef FAR
-#include <setjmp.h>
-
-#include "../LibJPEG/jinclude.h"
-#include "../LibJPEG/jpeglib.h"
-#include "../LibJPEG/jerror.h"
-#include "../LibJPEG/transupp.h"
-}
-
-#include "FreeImage.h"
-#include "Utilities.h"
-#include "FreeImageIO.h"
-
-// ----------------------------------------------------------
-//   Source manager & Destination manager setup
-//   (see PluginJPEG.cpp)
-// ----------------------------------------------------------
-
-void jpeg_freeimage_src(j_decompress_ptr cinfo, fi_handle infile, FreeImageIO *io);
-void jpeg_freeimage_dst(j_compress_ptr cinfo, fi_handle outfile, FreeImageIO *io);
-
-// ----------------------------------------------------------
-//   Error handling
-//   (see also PluginJPEG.cpp)
-// ----------------------------------------------------------
-
-/**
-	Receives control for a fatal error.  Information sufficient to
-	generate the error message has been stored in cinfo->err; call
-	output_message to display it.  Control must NOT return to the caller;
-	generally this routine will exit() or longjmp() somewhere.
-*/
-METHODDEF(void)
-ls_jpeg_error_exit (j_common_ptr cinfo) {
-	// always display the message
-	(*cinfo->err->output_message)(cinfo);
-
-	// allow JPEG with a premature end of file
-	if((cinfo)->err->msg_parm.i[0] != 13) {
-
-		// let the memory manager delete any temp files before we die
-		jpeg_destroy(cinfo);
-
-		throw FIF_JPEG;
-	}
-}
-
-/**
-	Actual output of any JPEG message.  Note that this method does not know
-	how to generate a message, only where to send it.
-*/
-METHODDEF(void)
-ls_jpeg_output_message (j_common_ptr cinfo) {
-	char buffer[JMSG_LENGTH_MAX];
-
-	// create the message
-	(*cinfo->err->format_message)(cinfo, buffer);
-	// send it to user's message proc
-	FreeImage_OutputMessageProc(FIF_JPEG, buffer);
-}
-
-// ----------------------------------------------------------
-//   Main program
-// ----------------------------------------------------------
-
-/**
-Build a crop string. 
-
-@param crop Output crop string
-@param left Specifies the left position of the cropped rectangle
-@param top Specifies the top position of the cropped rectangle
-@param right Specifies the right position of the cropped rectangle
-@param bottom Specifies the bottom position of the cropped rectangle
-@param width Image width
-@param height Image height
-@return Returns TRUE if successful, returns FALSE otherwise
-*/
-static BOOL
-getCropString(char* crop, int* left, int* top, int* right, int* bottom, int width, int height) {
-	if(!left || !top || !right || !bottom) {
-		return FALSE;
-	}
-
-	*left = CLAMP(*left, 0, width);
-	*top = CLAMP(*top, 0, height);
-
-	// negative/zero right and bottom count from the edges inwards
-
-	if(*right <= 0) {
-		*right = width + *right;
-	}
-	if(*bottom <= 0) {
-		*bottom = height + *bottom;
-	}
-
-	*right = CLAMP(*right, 0, width);
-	*bottom = CLAMP(*bottom, 0, height);
-
-	// test for empty rect
-
-	if(((*left - *right) == 0) || ((*top - *bottom) == 0)) {
-		return FALSE;
-	}
-
-	// normalize the rectangle
-
-	if(*right < *left) {
-		INPLACESWAP(*left, *right);
-	}
-	if(*bottom < *top) {
-		INPLACESWAP(*top, *bottom);
-	}
-
-	// test for "noop" rect
-
-	if(*left == 0 && *right == width && *top == 0 && *bottom == height) {
-		return FALSE;
-	}
-
-	// build the crop option
-	sprintf(crop, "%dx%d+%d+%d", *right - *left, *bottom - *top, *left, *top);
-
-	return TRUE;
-}
-
-static BOOL
-JPEGTransformFromHandle(FreeImageIO* src_io, fi_handle src_handle, FreeImageIO* dst_io, fi_handle dst_handle, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect) {
-	const BOOL onlyReturnCropRect = (dst_io == NULL) || (dst_handle == NULL);
-	const long stream_start = onlyReturnCropRect ? 0 : dst_io->tell_proc(dst_handle);
-	BOOL swappedDim = FALSE;
-	BOOL trimH = FALSE;
-	BOOL trimV = FALSE;
-
-	// Set up the jpeglib structures
-	jpeg_decompress_struct srcinfo;
-	jpeg_compress_struct dstinfo;
-	jpeg_error_mgr jsrcerr, jdsterr;
-	jvirt_barray_ptr *src_coef_arrays = NULL;
-	jvirt_barray_ptr *dst_coef_arrays = NULL;
-	// Support for copying optional markers from source to destination file
-	JCOPY_OPTION copyoption;
-	// Image transformation options
-	jpeg_transform_info transfoptions;
-
-	// Initialize structures
-	memset(&srcinfo, 0, sizeof(srcinfo));
-	memset(&jsrcerr, 0, sizeof(jsrcerr));
-	memset(&jdsterr, 0, sizeof(jdsterr));
-	memset(&dstinfo, 0, sizeof(dstinfo));
-	memset(&transfoptions, 0, sizeof(transfoptions));
-
-	// Copy all extra markers from source file
-	copyoption = JCOPYOPT_ALL;
-
-	// Set up default JPEG parameters
-	transfoptions.force_grayscale = FALSE;
-	transfoptions.crop = FALSE;
-
-	// Select the transform option
-	switch(operation) {
-		case FIJPEG_OP_FLIP_H:		// horizontal flip
-			transfoptions.transform = JXFORM_FLIP_H;
-			trimH = TRUE;
-			break;
-		case FIJPEG_OP_FLIP_V:		// vertical flip
-			transfoptions.transform = JXFORM_FLIP_V;
-			trimV = TRUE;
-			break;
-		case FIJPEG_OP_TRANSPOSE:	// transpose across UL-to-LR axis
-			transfoptions.transform = JXFORM_TRANSPOSE;
-			swappedDim = TRUE;
-			break;
-		case FIJPEG_OP_TRANSVERSE:	// transpose across UR-to-LL axis
-			transfoptions.transform = JXFORM_TRANSVERSE;
-			trimH = TRUE;
-			trimV = TRUE;
-			swappedDim = TRUE;
-			break;
-		case FIJPEG_OP_ROTATE_90:	// 90-degree clockwise rotation
-			transfoptions.transform = JXFORM_ROT_90;
-			trimH = TRUE;
-			swappedDim = TRUE;
-			break;
-		case FIJPEG_OP_ROTATE_180:	// 180-degree rotation
-			trimH = TRUE;
-			trimV = TRUE;
-			transfoptions.transform = JXFORM_ROT_180;
-			break;
-		case FIJPEG_OP_ROTATE_270:	// 270-degree clockwise (or 90 ccw)
-			transfoptions.transform = JXFORM_ROT_270;
-			trimV = TRUE;
-			swappedDim = TRUE;
-			break;
-		default:
-		case FIJPEG_OP_NONE:		// no transformation
-			transfoptions.transform = JXFORM_NONE;
-			break;
-	}
-	// (perfect == TRUE) ==> fail if there is non-transformable edge blocks
-	transfoptions.perfect = (perfect == TRUE) ? TRUE : FALSE;
-	// Drop non-transformable edge blocks: trim off any partial edge MCUs that the transform can't handle.
-	transfoptions.trim = TRUE;
-
-	try {
-
-		// Initialize the JPEG decompression object with default error handling
-		srcinfo.err = jpeg_std_error(&jsrcerr);
-		srcinfo.err->error_exit = ls_jpeg_error_exit;
-		srcinfo.err->output_message = ls_jpeg_output_message;
-		jpeg_create_decompress(&srcinfo);
-
-		// Initialize the JPEG compression object with default error handling
-		dstinfo.err = jpeg_std_error(&jdsterr);
-		dstinfo.err->error_exit = ls_jpeg_error_exit;
-		dstinfo.err->output_message = ls_jpeg_output_message;
-		jpeg_create_compress(&dstinfo);
-
-		// Specify data source for decompression
-		jpeg_freeimage_src(&srcinfo, src_handle, src_io);
-
-		// Enable saving of extra markers that we want to copy
-		jcopy_markers_setup(&srcinfo, copyoption);
-
-		// Read the file header
-		jpeg_read_header(&srcinfo, TRUE);
-
-		// crop option
-		char crop[64];
-		const BOOL hasCrop = getCropString(crop, left, top, right, bottom, swappedDim ? srcinfo.image_height : srcinfo.image_width, swappedDim ? srcinfo.image_width : srcinfo.image_height);
-
-		if(hasCrop) {
-			if(!jtransform_parse_crop_spec(&transfoptions, crop)) {
-				FreeImage_OutputMessageProc(FIF_JPEG, "Bogus crop argument %s", crop);
-				throw(1);
-			}
-		}
-
-		// Any space needed by a transform option must be requested before
-		// jpeg_read_coefficients so that memory allocation will be done right
-
-		// Prepare transformation workspace
-		// Fails right away if perfect flag is TRUE and transformation is not perfect
-		if( !jtransform_request_workspace(&srcinfo, &transfoptions) ) {
-			FreeImage_OutputMessageProc(FIF_JPEG, "Transformation is not perfect");
-			throw(1);
-		}
-
-		if(left || top) {
-			// compute left and top offsets, it's a bit tricky, taking into account both
-			// transform, which might have trimed the image,
-			// and crop itself, which is adjusted to lie on a iMCU boundary
-
-			const int fullWidth = swappedDim ? srcinfo.image_height : srcinfo.image_width;
-			const int fullHeight = swappedDim ? srcinfo.image_width : srcinfo.image_height;
-
-			int transformedFullWidth = fullWidth;
-			int transformedFullHeight = fullHeight;
-
-			if(trimH && transformedFullWidth/transfoptions.iMCU_sample_width > 0) {
-				transformedFullWidth = (transformedFullWidth/transfoptions.iMCU_sample_width) * transfoptions.iMCU_sample_width;
-			}
-			if(trimV && transformedFullHeight/transfoptions.iMCU_sample_height > 0) {
-				transformedFullHeight = (transformedFullHeight/transfoptions.iMCU_sample_height) * transfoptions.iMCU_sample_height;
-			}
-
-			const int trimmedWidth = fullWidth - transformedFullWidth;
-			const int trimmedHeight = fullHeight - transformedFullHeight;
-
-			if(left) {
-				*left = trimmedWidth + transfoptions.x_crop_offset * transfoptions.iMCU_sample_width;
-			}
-			if(top) {
-				*top = trimmedHeight + transfoptions.y_crop_offset * transfoptions.iMCU_sample_height;
-			}
-		}
-
-		if(right) {
-			*right = (left ? *left : 0) + transfoptions.output_width;
-		}
-		if(bottom) {
-			*bottom = (top ? *top : 0) + transfoptions.output_height;
-		}
-
-		// if only the crop rect is requested, we are done
-
-		if(onlyReturnCropRect) {
-			jpeg_destroy_compress(&dstinfo);
-			jpeg_destroy_decompress(&srcinfo);
-			return TRUE;
-		}
-
-		// Read source file as DCT coefficients
-		src_coef_arrays = jpeg_read_coefficients(&srcinfo);
-
-		// Initialize destination compression parameters from source values
-		jpeg_copy_critical_parameters(&srcinfo, &dstinfo);
-
-		// Adjust destination parameters if required by transform options;
-		// also find out which set of coefficient arrays will hold the output
-		dst_coef_arrays = jtransform_adjust_parameters(&srcinfo, &dstinfo, src_coef_arrays, &transfoptions);
-
-		// Note: we assume that jpeg_read_coefficients consumed all input
-		// until JPEG_REACHED_EOI, and that jpeg_finish_decompress will
-		// only consume more while (! cinfo->inputctl->eoi_reached).
-		// We cannot call jpeg_finish_decompress here since we still need the
-		// virtual arrays allocated from the source object for processing.
-
-		if(src_handle == dst_handle) {
-			dst_io->seek_proc(dst_handle, stream_start, SEEK_SET);
-		}
-
-		// Specify data destination for compression
-		jpeg_freeimage_dst(&dstinfo, dst_handle, dst_io);
-
-		// Start compressor (note no image data is actually written here)
-		jpeg_write_coefficients(&dstinfo, dst_coef_arrays);
-
-		// Copy to the output file any extra markers that we want to preserve
-		jcopy_markers_execute(&srcinfo, &dstinfo, copyoption);
-
-		// Execute image transformation, if any
-		jtransform_execute_transformation(&srcinfo, &dstinfo, src_coef_arrays, &transfoptions);
-
-		// Finish compression and release memory
-		jpeg_finish_compress(&dstinfo);
-		jpeg_destroy_compress(&dstinfo);
-		jpeg_finish_decompress(&srcinfo);
-		jpeg_destroy_decompress(&srcinfo);
-
-	}
-	catch(...) {
-		jpeg_destroy_compress(&dstinfo);
-		jpeg_destroy_decompress(&srcinfo);
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-// ----------------------------------------------------------
-//   FreeImage interface
-// ----------------------------------------------------------
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGTransformFromHandle(FreeImageIO* src_io, fi_handle src_handle, FreeImageIO* dst_io, fi_handle dst_handle, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect) {
-	return JPEGTransformFromHandle(src_io, src_handle, dst_io, dst_handle, operation, left, top, right, bottom, perfect);
-}
-
-static void
-closeStdIO(fi_handle src_handle, fi_handle dst_handle) {
-	if(src_handle) {
-		fclose((FILE*)src_handle);
-	}
-	if(dst_handle && (dst_handle != src_handle)) {
-		fclose((FILE*)dst_handle);
-	}
-}
-
-static BOOL
-openStdIO(const char* src_file, const char* dst_file, FreeImageIO* dst_io, fi_handle* src_handle, fi_handle* dst_handle) {
-	*src_handle = NULL;
-	*dst_handle = NULL;
-	
-	FreeImageIO io;
-	SetDefaultIO (&io);
-	
-	const BOOL isSameFile = (dst_file && (strcmp(src_file, dst_file) == 0)) ? TRUE : FALSE;
-	
-	FILE* srcp = NULL;
-	FILE* dstp = NULL;
-	
-	if(isSameFile) {
-		srcp = fopen(src_file, "r+b");
-		dstp = srcp;
-	}
-	else {
-		srcp = fopen(src_file, "rb");
-		if(dst_file) {
-			dstp = fopen(dst_file, "wb");
-		}
-	}
-	
-	if(!srcp || (dst_file && !dstp)) {
-		if(!srcp) {
-			FreeImage_OutputMessageProc(FIF_JPEG, "Cannot open \"%s\" for reading", src_file);
-		} else {
-			FreeImage_OutputMessageProc(FIF_JPEG, "Cannot open \"%s\" for writing", dst_file);
-		}
-		closeStdIO(srcp, dstp);
-		return FALSE;
-	}
-
-	if(FreeImage_GetFileTypeFromHandle(&io, srcp) != FIF_JPEG) {
-		FreeImage_OutputMessageProc(FIF_JPEG, " Source file \"%s\" is not jpeg", src_file);
-		closeStdIO(srcp, dstp);
-		return FALSE;
-	}
-
-	*dst_io = io;
-	*src_handle = srcp;
-	*dst_handle = dstp;
-
-	return TRUE;
-}
-
-static BOOL
-openStdIOU(const wchar_t* src_file, const wchar_t* dst_file, FreeImageIO* dst_io, fi_handle* src_handle, fi_handle* dst_handle) {
-#ifdef _WIN32
-
-	*src_handle = NULL;
-	*dst_handle = NULL;
-
-	FreeImageIO io;
-	SetDefaultIO (&io);
-	
-	const BOOL isSameFile = (dst_file && (wcscmp(src_file, dst_file) == 0)) ? TRUE : FALSE;
-
-	FILE* srcp = NULL;
-	FILE* dstp = NULL;
-
-	if(isSameFile) {
-		srcp = _wfopen(src_file, L"r+b");
-		dstp = srcp;
-	} else {
-		srcp = _wfopen(src_file, L"rb");
-		if(dst_file) {
-			dstp = _wfopen(dst_file, L"wb");
-		}
-	}
-
-	if(!srcp || (dst_file && !dstp)) {
-		if(!srcp) {
-			FreeImage_OutputMessageProc(FIF_JPEG, "Cannot open source file for reading");
-		} else {
-			FreeImage_OutputMessageProc(FIF_JPEG, "Cannot open destination file for writing");
-		}
-		closeStdIO(srcp, dstp);
-		return FALSE;
-	}
-
-	if(FreeImage_GetFileTypeFromHandle(&io, srcp) != FIF_JPEG) {
-		FreeImage_OutputMessageProc(FIF_JPEG, " Source file is not jpeg");
-		closeStdIO(srcp, dstp);
-		return FALSE;
-	}
-
-	*dst_io = io;
-	*src_handle = srcp;
-	*dst_handle = dstp;
-
-	return TRUE;
-
-#else
-	return FALSE;
-#endif // _WIN32
-}
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGTransform(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect) {
-	FreeImageIO io;
-	fi_handle src;
-	fi_handle dst;
-	
-	if(!openStdIO(src_file, dst_file, &io, &src, &dst)) {
-		return FALSE;
-	}
-	
-	BOOL ret = JPEGTransformFromHandle(&io, src, &io, dst, operation, NULL, NULL, NULL, NULL, perfect);
-
-	closeStdIO(src, dst);
-
-	return ret;
-}
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGCrop(const char *src_file, const char *dst_file, int left, int top, int right, int bottom) {
-	FreeImageIO io;
-	fi_handle src;
-	fi_handle dst;
-	
-	if(!openStdIO(src_file, dst_file, &io, &src, &dst)) {
-		return FALSE;
-	}
-	
-	BOOL ret = FreeImage_JPEGTransformFromHandle(&io, src, &io, dst, FIJPEG_OP_NONE, &left, &top, &right, &bottom, FALSE);
-	
-	closeStdIO(src, dst);
-	
-	return ret;
-}
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGTransformU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect) {
-	FreeImageIO io;
-	fi_handle src;
-	fi_handle dst;
-	
-	if(!openStdIOU(src_file, dst_file, &io, &src, &dst)) {
-		return FALSE;
-	}
-	
-	BOOL ret = JPEGTransformFromHandle(&io, src, &io, dst, operation, NULL, NULL, NULL, NULL, perfect);
-	
-	closeStdIO(src, dst);
-
-	return ret;
-}
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGCropU(const wchar_t *src_file, const wchar_t *dst_file, int left, int top, int right, int bottom) {
-	FreeImageIO io;
-	fi_handle src;
-	fi_handle dst;
-	
-	if(!openStdIOU(src_file, dst_file, &io, &src, &dst)) {
-		return FALSE;
-	}
-	
-	BOOL ret = FreeImage_JPEGTransformFromHandle(&io, src, &io, dst, FIJPEG_OP_NONE, &left, &top, &right, &bottom, FALSE);
-
-	closeStdIO(src, dst);
-
-	return ret;
-}
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGTransformCombined(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect) {
-	FreeImageIO io;
-	fi_handle src;
-	fi_handle dst;
-	
-	if(!openStdIO(src_file, dst_file, &io, &src, &dst)) {
-		return FALSE;
-	}
-	
-	BOOL ret = FreeImage_JPEGTransformFromHandle(&io, src, &io, dst, operation, left, top, right, bottom, perfect);
-
-	closeStdIO(src, dst);
-
-	return ret;
-}
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGTransformCombinedU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect) {
-	FreeImageIO io;
-	fi_handle src;
-	fi_handle dst;
-	
-	if(!openStdIOU(src_file, dst_file, &io, &src, &dst)) {
-		return FALSE;
-	}
-	
-	BOOL ret = FreeImage_JPEGTransformFromHandle(&io, src, &io, dst, operation, left, top, right, bottom, perfect);
-
-	closeStdIO(src, dst);
-
-	return ret;
-}
-
-// --------------------------------------------------------------------------
-
-static BOOL
-getMemIO(FIMEMORY* src_stream, FIMEMORY* dst_stream, FreeImageIO* dst_io, fi_handle* src_handle, fi_handle* dst_handle) {
-	*src_handle = NULL;
-	*dst_handle = NULL;
-
-	FreeImageIO io;
-	SetMemoryIO (&io);
-
-	if(dst_stream) {
-		FIMEMORYHEADER *mem_header = (FIMEMORYHEADER*)(dst_stream->data);
-		if(mem_header->delete_me != TRUE) {
-			// do not save in a user buffer
-			FreeImage_OutputMessageProc(FIF_JPEG, "Destination memory buffer is read only");
-			return FALSE;
-		}
-	}
-
-	*dst_io = io;
-	*src_handle = src_stream;
-	*dst_handle = dst_stream;
-
-	return TRUE;
-}
-
-BOOL DLL_CALLCONV
-FreeImage_JPEGTransformCombinedFromMemory(FIMEMORY* src_stream, FIMEMORY* dst_stream, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect) {
-	FreeImageIO io;
-	fi_handle src;
-	fi_handle dst;
-	
-	if(!getMemIO(src_stream, dst_stream, &io, &src, &dst)) {
-		return FALSE;
-	}
-	
-	return FreeImage_JPEGTransformFromHandle(&io, src, &io, dst, operation, left, top, right, bottom, perfect);
-}
-
diff -Naur FreeImage/Source/Metadata/TagConversion.cpp FreeImage.new/Source/Metadata/TagConversion.cpp
--- FreeImage/Source/Metadata/TagConversion.cpp	2018-03-25 12:30:54.000000000 +0200
+++ FreeImage.new/Source/Metadata/TagConversion.cpp	2022-05-12 16:25:38.635261903 +0200
@@ -30,6 +30,11 @@
 
 #define MAX_TEXT_EXTENT	512
 
+// These were in FreeImage.h, but are moved here to avoid conflicts (see note in FreeImage.h)
+typedef int64_t INT64;
+typedef uint64_t UINT64;
+
+
 /**
 Convert a tag to a C string
 */
diff -Naur FreeImage/Source/Metadata/XTIFF.cpp FreeImage.new/Source/Metadata/XTIFF.cpp
--- FreeImage/Source/Metadata/XTIFF.cpp	2015-03-04 00:07:10.000000000 +0100
+++ FreeImage.new/Source/Metadata/XTIFF.cpp	2022-05-12 16:25:38.635261903 +0200
@@ -29,13 +29,18 @@
 #pragma warning (disable : 4786) // identifier was truncated to 'number' characters
 #endif
 
-#include "../LibTIFF4/tiffiop.h"
+#include <tiffio.h>
 
 #include "FreeImage.h"
 #include "Utilities.h"
 #include "FreeImageTag.h"
 #include "FIRational.h"
 
+extern "C"
+{
+    int _TIFFDataSize(TIFFDataType type);
+}
+
 // ----------------------------------------------------------
 //   Extended TIFF Directory GEO Tag Support
 // ----------------------------------------------------------
@@ -224,6 +229,33 @@
 //   TIFF EXIF tag reading & writing
 // ----------------------------------------------------------
 
+static uint32 exif_tag_ids[] = {
+  EXIFTAG_EXPOSURETIME, EXIFTAG_FNUMBER, EXIFTAG_EXPOSUREPROGRAM,
+  EXIFTAG_SPECTRALSENSITIVITY, EXIFTAG_ISOSPEEDRATINGS, EXIFTAG_OECF,
+  EXIFTAG_EXIFVERSION, EXIFTAG_DATETIMEORIGINAL, EXIFTAG_DATETIMEDIGITIZED,
+  EXIFTAG_COMPONENTSCONFIGURATION, EXIFTAG_COMPRESSEDBITSPERPIXEL,
+  EXIFTAG_SHUTTERSPEEDVALUE, EXIFTAG_APERTUREVALUE,
+  EXIFTAG_BRIGHTNESSVALUE, EXIFTAG_EXPOSUREBIASVALUE,
+  EXIFTAG_MAXAPERTUREVALUE, EXIFTAG_SUBJECTDISTANCE, EXIFTAG_METERINGMODE,
+  EXIFTAG_LIGHTSOURCE, EXIFTAG_FLASH, EXIFTAG_FOCALLENGTH,
+  EXIFTAG_SUBJECTAREA, EXIFTAG_MAKERNOTE, EXIFTAG_USERCOMMENT,
+  EXIFTAG_SUBSECTIME, EXIFTAG_SUBSECTIMEORIGINAL,
+  EXIFTAG_SUBSECTIMEDIGITIZED, EXIFTAG_FLASHPIXVERSION, EXIFTAG_COLORSPACE,
+  EXIFTAG_PIXELXDIMENSION, EXIFTAG_PIXELYDIMENSION,
+  EXIFTAG_RELATEDSOUNDFILE, EXIFTAG_FLASHENERGY,
+  EXIFTAG_SPATIALFREQUENCYRESPONSE, EXIFTAG_FOCALPLANEXRESOLUTION,
+  EXIFTAG_FOCALPLANEYRESOLUTION, EXIFTAG_FOCALPLANERESOLUTIONUNIT,
+  EXIFTAG_SUBJECTLOCATION, EXIFTAG_EXPOSUREINDEX, EXIFTAG_SENSINGMETHOD,
+  EXIFTAG_FILESOURCE, EXIFTAG_SCENETYPE, EXIFTAG_CFAPATTERN,
+  EXIFTAG_CUSTOMRENDERED, EXIFTAG_EXPOSUREMODE, EXIFTAG_WHITEBALANCE,
+  EXIFTAG_DIGITALZOOMRATIO, EXIFTAG_FOCALLENGTHIN35MMFILM,
+  EXIFTAG_SCENECAPTURETYPE, EXIFTAG_GAINCONTROL, EXIFTAG_CONTRAST,
+  EXIFTAG_SATURATION, EXIFTAG_SHARPNESS, EXIFTAG_DEVICESETTINGDESCRIPTION,
+  EXIFTAG_SUBJECTDISTANCERANGE, EXIFTAG_GAINCONTROL, EXIFTAG_GAINCONTROL,
+  EXIFTAG_IMAGEUNIQUEID
+};
+static int nExifTags = sizeof(exif_tag_ids) / sizeof(exif_tag_ids[0]);
+
 /**
 Read a single Exif tag
 
@@ -575,45 +607,11 @@
 
 	// loop over all Core Directory Tags
 	// ### uses private data, but there is no other way
+	// -> Fedora: Best we can do without private headers is to hard-code a list of known EXIF tags and read those
 	if(md_model == TagLib::EXIF_MAIN) {
-		const TIFFDirectory *td = &tif->tif_dir;
-
-		uint32 lastTag = 0;	//<- used to prevent reading some tags twice (as stored in tif_fieldinfo)
-
-		for (int fi = 0, nfi = (int)tif->tif_nfields; nfi > 0; nfi--, fi++) {
-			const TIFFField *fld = tif->tif_fields[fi];
-
-			const uint32 tag_id = TIFFFieldTag(fld);
-
-			if(tag_id == lastTag) {
-				continue;
-			}
-
-			// test if tag value is set
-			// (lifted directly from LibTiff _TIFFWriteDirectory)
-
-			if( fld->field_bit == FIELD_CUSTOM ) {
-				int is_set = FALSE;
-
-				for(int ci = 0; ci < td->td_customValueCount; ci++ ) {
-					is_set |= (td->td_customValues[ci].info == fld);
-				}
-
-				if( !is_set ) {
-					continue;
-				}
-
-			} else if(!TIFFFieldSet(tif, fld->field_bit)) {
-				continue;
-			}
-
-			// process *all* other tags (some will be ignored)
-
-			tiff_read_exif_tag(tif, tag_id, dib, md_model);
-
-			lastTag = tag_id;
+		for (int i = 0; i < nExifTags; ++i) {
+			tiff_read_exif_tag(tif, exif_tag_ids[i], dib, md_model);
 		}
-
 	}
 
 	return TRUE;
@@ -723,10 +721,9 @@
 	
 	TagLib& tag_lib = TagLib::instance();
 	
-	for (int fi = 0, nfi = (int)tif->tif_nfields; nfi > 0; nfi--, fi++) {
-		const TIFFField *fld = tif->tif_fields[fi];
-		
-		const uint32 tag_id = TIFFFieldTag(fld);
+	for (int fi = 0; fi < nExifTags; fi++) {
+		const uint32 tag_id = exif_tag_ids[fi];
+		const TIFFField *fld = TIFFFieldWithTag(tif, tag_id);
 
 		if(skip_write_field(tif, tag_id)) {
 			// skip tags that are already handled by the LibTIFF writing process
diff -Naur FreeImage/Source/Utilities.h FreeImage.new/Source/Utilities.h
--- FreeImage/Source/Utilities.h	2016-04-11 15:15:32.000000000 +0200
+++ FreeImage.new/Source/Utilities.h	2022-05-12 16:25:38.635261903 +0200
@@ -446,12 +446,12 @@
 }
  
 inline void
-SwapInt64(UINT64 *arg) {
+SwapInt64(uint64_t *arg) {
 #if defined(_MSC_VER) && _MSC_VER >= 1310
 	*arg = _byteswap_uint64(*arg);
 #else
 	union Swap {
-		UINT64 sv;
+		uint64_t sv;
 		DWORD ul[2];
 	} tmp, result;
 	tmp.sv = *arg;
