#!/usr/bin/perl
use Cwd;
use Digest::SHA1 qw(sha1_hex);

# CIA Client and Mailer for Darcs
# Copyright (C) 2005 Patrick McFarland <diablod3@gmail.com>
# Copyright (C) 2006 Miklos Vajna <vmiklos@frugalware.org>

# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License version 2, as published by the
# Free Software Foundation.

# Based on a darcs mailing list log script written by:
# (C) 2004-12-10 Thomas Radke <tradke@aei.mpg.de>
# Some changes by Erik Schnetter <schnetter@aei.mpg.de>
# http://www.mail-archive.com/darcs-devel@darcs.net/msg00831/darcs

# Also based on a CIA CVS bot written by:
# Loosely based on cvslog by Russ Allbery <rra@stanford.edu>
# Copyright 1998  Board of Trustees, Leland Stanford Jr. University
# Copyright 2001, 2003, 2004  Petr Baudis <pasky@ucw.cz>
# http://cia.navi.cx/clients/cvs/ciabot_cvs.pl

# The getpatchname() function is from darcshive
# Copyright (c) 2004 by Anthony Towns <aj@azure.humbug.org.au>

# Notes:
#
# This script acts as a wrapper for darcs. Simply rename darcs (to, say,
# 'darcs.real'), and then put this script where darcs used to be. You
# execute this script instead of the real darcs, and everything works fine.
#
# This script requires darcs to access a remote darcs and execute it using
# 'darcs apply --all', local push/pull methods do not do this; ssh, however,
# does. If you need to run darcs locally, just do `darcs push
# localhost:/path/to/your/repo` to make darcs trigger `darcs apply --all`.
# 

require '/etc/darcs.conf';

### some constants
my $project = "Frugalware";

# 0 uses xml-rpc, 1 uses email
my $use_method = 1;

# Path to your real darcs executable
my $darcs = '/usr/bin/darcs.real';

# If using XML-RPC, connect to this URI.
my $rpc_uri = 'http://cia.navi.cx/RPC2';

# If using email, the From: address in generated mails
#my $from_email = 'diablo-d3@users.sourceforge.net';
my $from_email = 'diablod3@gmail.com';

# If using email, the To: address in generated mails
my $dest_email = 'cia@cia.navi.cx';
#my $dest_email = 'vmiklos@gmail.com';

# the To: address in generated -darcs list mails
my $dest_darcs_email = 'frugalware-darcs@frugalware.org';

# If using email, path to your USCD sendmail compatible binary 
my $sendmail = '/usr/sbin/sendmail';

### nothing below should be changed

# patch database
my %submitters = ();
my %timestamps = ();
my %rawtimestamps = ();
my %comments   = ();
my %raws   = ();
my %files = ();

my ($VERSION) = '0.1';
my ($URL) = 'http://shadowconflict.com/';
my $ts = time;

sub getpatchname {
	my ($email, $desc, $log, $date, $inv) = @_;
	my $realdate;

	if ($date =~ m/^(\d{14}).*/) {
		$realdate = $1;
	} elsif ($date =~ m/(...) (...) (.\d) (\d\d):(\d\d):(\d\d) (.*) (\d{4})$/) {
		my $mos = "/Jan/Feb/Mar/Apr/May/Jun/Jul/Aug/Sep/Oct/Nov/Dec/";
		my ($weekday, $mo, $da, $hr, $min, $sec, $tz, $yr) = 
			($1,$2,$3,$4,$5,$6,$7,$8);
		my $mon = sprintf "%02d", (index ($mos,"/$mo/"))/4+1;
		$da=sprintf "%02d", $da;
		$realdate = "$yr$mon$da$hr$min$sec";
	} else {
		die "odd patch date: $date\n"
	}

	return sprintf("%s-%s-%s", $realdate, substr(sha1_hex($email), 0, 5),
		sha1_hex("$desc$email$date$log$inv"));
}

# get repo name for this project
if($ARGV[3]) {
  chdir($ARGV[3]);
}
my $module = getcwd();
chomp $module;
foreach(split(/\//, $module)) {
  $module = $_;
}
$module =~ s/\///g;

my $line;

# sanity check
die "Couldn't find executable '$darcs'!\n\n" if (! -x $darcs);

#foreach(@ARGV) { print "$_ "; } # uncomment this to enable debugging
#print "\n";                     # of what darcs gets passed via script

# short cut for darcs commands other than 'apply --all'
exec ($darcs, @ARGV)
  if (! (($#ARGV == 1 || ($#ARGV == 3  && $ARGV[2] eq '--repodir')) && $ARGV[0] eq 'apply' && $ARGV[1] eq '--all'));

# open a pipe for running darcs on the other end
open (DARCS, "| $darcs @ARGV") || die "Couldn't open pipe to darcs !\n";

# skip everything before the 'New patches:' section
while (<STDIN>)
{
  print DARCS;
  last if (/^New patches:$/);
}

# separator for a patch's header and its contents
my $endmarker = '] {';

# now parse individual patches
while (<STDIN>)
{
  print DARCS;

  if(/Context:/)
  {
  # skip everything till the 'Patch bundle hash:' section
  while (<STDIN>)
  {
    print DARCS;
    last if (/^Patch bundle hash:$/);
  }
  }

  # each patch starts with a line '[<patch name>'
  next if (! /^\[(.+)$/);
  my $patch = $1;
  $raws{$patch} .= $_;

  # on the next line follow the submitter's email address
  # and the timestamp of the patch
  $_ = <STDIN>;
  print DARCS;
  $raws{$patch} .= $_;
  next if (! /^(.+)\*\*(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})($endmarker)??$/o);

  # add this patch to the database
  $submitters{$patch} = $1;
  $senders{$patch} = $1;
  # convert the timestamp into some readable form 'YYYY-MM-DD HH:MM:SS'
  $timestamps{$patch} = "$2-$3-$4 $5:$6:$7";
  $rawtimestamps{$patch} = "$2$3$4$5$6$7";

  # everything until an end-marker string belongs to
  # a long comment for this patch
  if (! $8)
  {
    while (<STDIN>)
    {
      print DARCS;
      $raws{$patch} .= $_;
      last if (/^$endmarker$/);
      $comments{$patch} .= $_;
    }
  }

  # this grabs the file names from all the patches. If darcs gains any
  # new patch types that use filenames, those will have to be added here.
  while ($_ = <STDIN>) {
    print DARCS;
    $raws{$patch} .= $_;
    $l = $_;
    $l =~ s/\.\///g;
    if($l =~ /adddir (.*)\n/) { push @{$files{$patch}}, "$1 " unless grep {/^$1/} @{$files{$patch}} }
    if($l =~ /addfile (.*)\n/) { push @{$files{$patch}}, "$1 " unless grep {/^$1/} @{$files{$patch}} }
    if($l =~ /rmdir (.*)\n/) { push @{$files{$patch}}, "$1 " unless grep {/^$1/} @{$files{$patch}} }
    if($l =~ /rmfile (.*)\n/) { push @{$files{$patch}}, "$1 " unless grep {/^$1/} @{$files{$patch}} }
    if($l =~ /binary (.*)\n/) { push @{$files{$patch}}, "$1 " unless grep {/^$1/} @{$files{$patch}} }
    if($l =~ /hunk (.*)\n/) {
      $m = $1;
      $m .= "\n";
      $m =~ s/[0-9]\n/\n/;
      $m =~ s/[0-9]\n/\n/;
      $m =~ s/[0-9]\n/\n/;
      $m =~ s/[0-9]\n/\n/;
      $m =~ s/ \n//;
      push @{$files{$patch}}, "$m " unless grep {/^\Q$m\E/} @{$files{$patch}};
    }
    if($l =~ /move (.*)\n/) {
      $m = $1;
      foreach(split(/ /, $m)) {
        $n = $_;
        $n =~ s/\+/\\+/;
	$n =~ s/\(/\\(/;
	$n =~ s/\)/\\)/;
        push @{$files{$patch}}, "$_ " unless grep {/^$n/} @{$files{$patch}};
      }
    }
    last if (/^}$/);
  }
}

close (DARCS) || die "Failed to run darcs command '$darcs @ARGV'\n";

# now send out notification if necessary

$skiprepo = 0;
for (@ignorerepos) {
	if ($module =~ /$_/) {
		$skiprepo = 1;
	}
}

if($skiprepo)
{
	exit;
}

foreach $patch (keys %submitters)
{
  ${submitters{$patch}} =~ s/&/&amp;/g;
  ${submitters{$patch}} =~ s/</&lt;/g;
  ${submitters{$patch}} =~ s/>/&gt;/g;

  $message = <<EM
<message>
  <generator>
    <name>CIA Perl client for Darcs</name>
    <version>$VERSION</version>
    <url>$URL</url>
  </generator>
  <source>
    <project>$project</project>
    <module>$module</module>
  </source>
  <timestamp>
    $ts
  </timestamp>
  <body>
    <commit>
      <author>${submitters{$patch}}</author>
      <files>
EM
;

foreach (@{$files{$patch}}) { $message .= "<file>$_</file>\n"; }

$message .= "</files>\n<log>";

if ($comments{$patch}) {
  $message .= "$patch:$comments{$patch}";
} else {
  $message .= "$patch";
}

$message .= "</log>\n<url>";

$_ = $comments{$patch};
$_ =~ s/^ //gm;
$_ =~ s/\n//gm;
my $hash = getpatchname($senders{$patch}, $patch, $_, $rawtimestamps{$patch}, "f");
$message .= "http://darcs.frugalware.org/darcsweb/darcsweb.cgi?r=$module;a=darcs_commitdiff;h=$hash.gz;\n";

$message .= <<EM
      </url>
    </commit>
  </body>
</message>
EM
;

  $message =~ tr/ÁÉÍÓÖÕÚÜÛáéíóöõúüû/AEIOOOUUUaeiooouuu/;
  if($use_method == 1) {
    # send mail to cia
    open (MAIL, "| $sendmail -t -oi") or die "Cannot execute $sendmail : " . ($?>>8);

print MAIL <<EOM;
From: $from_email
To: $dest_email
Content-type: text/xml
Subject: DeliverXML

EOM

  print MAIL $message;

  close MAIL;
  die "$0: sendmail exit status " . ($? >> 8) . "\n" unless ($? == 0);
  # to -darcs
    open (MAIL, "| $sendmail -t -oi") or die "Cannot execute $sendmail : " . ($?>>8);

print MAIL <<EOM;
From: ${senders{$patch}}
To: $dest_darcs_email
Subject: $module: $patch

EOM

  $_ = $comments{$patch};
  $_ =~ s/^ //gm;
  $_ =~ s/\n//gm;
  my $hash = getpatchname($senders{$patch}, $patch, $_, $rawtimestamps{$patch}, "f");
  print MAIL "Darcsweb-Url: http://darcs.frugalware.org/darcsweb/darcsweb.cgi?r=$module;a=darcs_commitdiff;h=$hash.gz;\n\n";
  print MAIL $raws{$patch};

  close MAIL;
  die "$0: sendmail exit status " . ($? >> 8) . "\n" unless ($? == 0);
  } else {
    $^W = 0;
    $RPC::XML::ERROR if (0);

    require RPC::XML;
    require RPC::XML::Client;

    my $rpc_client = new RPC::XML::Client $rpc_uri;
    my $rpc_request = RPC::XML::request->new('hub.deliver', $message);
    my $rpc_response = $rpc_client->send_request($rpc_request);

    unless (ref $rpc_response) {
    die "XML-RPC Error: $RPC::XML::ERROR\n";
    }
  }
}
